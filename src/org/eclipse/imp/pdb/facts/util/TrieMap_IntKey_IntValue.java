/*******************************************************************************
 * Copyright (c) 2013-2014 CWI
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *
 *   * Michael Steindorfer - Michael.Steindorfer@cwi.nl - CWI  
 *******************************************************************************/
package org.eclipse.imp.pdb.facts.util;

import static org.eclipse.imp.pdb.facts.util.AbstractSpecialisedImmutableMap.entryOf;

import java.text.DecimalFormat;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

@SuppressWarnings("rawtypes")
public class TrieMap_IntKey_IntValue extends
				AbstractImmutableMap<java.lang.Integer, java.lang.Integer> {

	@SuppressWarnings("unchecked")
	private static final TrieMap_IntKey_IntValue EMPTY_MAP = new TrieMap_IntKey_IntValue(
					CompactMapNode.EMPTY_NODE, 0, 0);

	private static final boolean DEBUG = false;

	private final AbstractMapNode rootNode;
	private final int hashCode;
	private final int cachedSize;

	TrieMap_IntKey_IntValue(AbstractMapNode rootNode, int hashCode, int cachedSize) {
		this.rootNode = rootNode;
		this.hashCode = hashCode;
		this.cachedSize = cachedSize;
		if (DEBUG) {
			assert checkHashCodeAndSize(hashCode, cachedSize);
		}
	}

	@SuppressWarnings("unchecked")
	public static final ImmutableMap<java.lang.Integer, java.lang.Integer> of() {
		return TrieMap_IntKey_IntValue.EMPTY_MAP;
	}

	@SuppressWarnings("unchecked")
	public static final ImmutableMap<java.lang.Integer, java.lang.Integer> of(
					Object... keyValuePairs) {
		if (keyValuePairs.length % 2 != 0) {
			throw new IllegalArgumentException(
							"Length of argument list is uneven: no key/value pairs.");
		}

		ImmutableMap<java.lang.Integer, java.lang.Integer> result = TrieMap_IntKey_IntValue.EMPTY_MAP;

		for (int i = 0; i < keyValuePairs.length; i += 2) {
			final int key = (int) keyValuePairs[i];
			final int val = (int) keyValuePairs[i + 1];

			result = result.__put(key, val);
		}

		return result;
	}

	@SuppressWarnings("unchecked")
	public static final TransientMap<java.lang.Integer, java.lang.Integer> transientOf() {
		return TrieMap_IntKey_IntValue.EMPTY_MAP.asTransient();
	}

	@SuppressWarnings("unchecked")
	public static final TransientMap<java.lang.Integer, java.lang.Integer> transientOf(
					Object... keyValuePairs) {
		if (keyValuePairs.length % 2 != 0) {
			throw new IllegalArgumentException(
							"Length of argument list is uneven: no key/value pairs.");
		}

		final TransientMap<java.lang.Integer, java.lang.Integer> result = TrieMap_IntKey_IntValue.EMPTY_MAP
						.asTransient();

		for (int i = 0; i < keyValuePairs.length; i += 2) {
			final int key = (int) keyValuePairs[i];
			final int val = (int) keyValuePairs[i + 1];

			result.__put(key, val);
		}

		return result;
	}

	private boolean checkHashCodeAndSize(final int targetHash, final int targetSize) {
		int hash = 0;
		int size = 0;

		for (Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> it = entryIterator(); it
						.hasNext();) {
			final Map.Entry<java.lang.Integer, java.lang.Integer> entry = it.next();
			final int key = entry.getKey();
			final int val = entry.getValue();

			hash += (int) key ^ (int) val;
			size += 1;
		}

		return hash == targetHash && size == targetSize;
	}

	@Override
	public TrieMap_IntKey_IntValue __put(final java.lang.Integer key, final java.lang.Integer val) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
						.updated(null, key, val, keyHash, 0);

		if (result.isModified()) {

			if (result.hasReplacedValue()) {
				final int valHashOld = result.getReplacedValue().hashCode();
				final int valHashNew = (int) val;

				return new TrieMap_IntKey_IntValue(result.getNode(), hashCode
								+ (keyHash ^ valHashNew) - (keyHash ^ valHashOld), cachedSize);
			}

			final int valHash = (int) val;
			return new TrieMap_IntKey_IntValue(result.getNode(), hashCode + (keyHash ^ valHash),
							cachedSize + 1);

		}

		return this;
	}

	@Override
	public TrieMap_IntKey_IntValue __putEquivalent(final java.lang.Integer key,
					final java.lang.Integer val, Comparator<Object> cmp) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
						.updated(null, key, val, keyHash, 0, cmp);

		if (result.isModified()) {

			if (result.hasReplacedValue()) {
				final int valHashOld = result.getReplacedValue().hashCode();
				final int valHashNew = (int) val;

				return new TrieMap_IntKey_IntValue(result.getNode(), hashCode
								+ (keyHash ^ valHashNew) - (keyHash ^ valHashOld), cachedSize);
			}

			final int valHash = (int) val;
			return new TrieMap_IntKey_IntValue(result.getNode(), hashCode + (keyHash ^ valHash),
							cachedSize + 1);

		}

		return this;
	}

	@Override
	public ImmutableMap<java.lang.Integer, java.lang.Integer> __putAll(
					Map<? extends java.lang.Integer, ? extends java.lang.Integer> map) {
		TransientMap<java.lang.Integer, java.lang.Integer> tmp = asTransient();
		tmp.__putAll(map);
		return tmp.freeze();
	}

	@Override
	public ImmutableMap<java.lang.Integer, java.lang.Integer> __putAllEquivalent(
					Map<? extends java.lang.Integer, ? extends java.lang.Integer> map,
					Comparator<Object> cmp) {
		TransientMap<java.lang.Integer, java.lang.Integer> tmp = asTransient();
		tmp.__putAllEquivalent(map, cmp);
		return tmp.freeze();
	}

	@Override
	public TrieMap_IntKey_IntValue __remove(final java.lang.Integer key) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
						.removed(null, key, keyHash, 0);

		if (result.isModified()) {

			// TODO: carry deleted value in result
			// assert result.hasReplacedValue();
			// final int valHash = result.getReplacedValue().hashCode();

			final int valHash = rootNode.findByKey(key, keyHash, 0).get().hashCode();

			return new TrieMap_IntKey_IntValue(result.getNode(), hashCode - (keyHash ^ valHash),
							cachedSize - 1);

		}

		return this;
	}

	@Override
	public TrieMap_IntKey_IntValue __removeEquivalent(final java.lang.Integer key,
					Comparator<Object> cmp) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
						.removed(null, key, keyHash, 0, cmp);

		if (result.isModified()) {

			// TODO: carry deleted value in result
			// assert result.hasReplacedValue();
			// final int valHash = result.getReplacedValue().hashCode();

			final int valHash = rootNode.findByKey(key, keyHash, 0, cmp).get().hashCode();

			return new TrieMap_IntKey_IntValue(result.getNode(), hashCode - (keyHash ^ valHash),
							cachedSize - 1);

		}

		return this;
	}

	@Override
	public boolean containsKey(Object o) {
		try {
			final int key = (int) o;
			return rootNode.containsKey(key, (int) key, 0);
		} catch (ClassCastException unused) {
			return false;
		}
	}

	@Override
	public boolean containsKeyEquivalent(Object o, Comparator<Object> cmp) {
		try {
			final int key = (int) o;
			return rootNode.containsKey(key, (int) key, 0, cmp);
		} catch (ClassCastException unused) {
			return false;
		}
	}

	@Override
	public boolean containsValue(Object o) {
		for (Iterator<java.lang.Integer> iterator = valueIterator(); iterator.hasNext();) {
			if (iterator.next().equals(o)) {
				return true;
			}
		}
		return false;
	}

	@Override
	public boolean containsValueEquivalent(Object o, Comparator<Object> cmp) {
		for (Iterator<java.lang.Integer> iterator = valueIterator(); iterator.hasNext();) {
			if (cmp.compare(iterator.next(), o) == 0) {
				return true;
			}
		}
		return false;
	}

	@Override
	public java.lang.Integer get(Object o) {
		try {
			final int key = (int) o;
			final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0);

			if (result.isPresent()) {
				return result.get();
			} else {
				return null;
			}
		} catch (ClassCastException unused) {
			return null;
		}
	}

	@Override
	public java.lang.Integer getEquivalent(Object o, Comparator<Object> cmp) {
		try {
			final int key = (int) o;
			final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0, cmp);

			if (result.isPresent()) {
				return result.get();
			} else {
				return null;
			}
		} catch (ClassCastException unused) {
			return null;
		}
	}

	@Override
	public int size() {
		return cachedSize;
	}

	@Override
	public SupplierIterator<java.lang.Integer, java.lang.Integer> keyIterator() {
		return new MapKeyIterator(rootNode);
	}

	@Override
	public Iterator<java.lang.Integer> valueIterator() {
		return new MapValueIterator(rootNode);
	}

	@Override
	public Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> entryIterator() {
		return new MapEntryIterator(rootNode);
	}

	@Override
	public Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet() {
		Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet = null;

		if (entrySet == null) {
			entrySet = new AbstractSet<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>>() {
				@Override
				public Iterator<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> iterator() {
					return new Iterator<Entry<java.lang.Integer, java.lang.Integer>>() {
						private final Iterator<Entry<java.lang.Integer, java.lang.Integer>> i = entryIterator();

						@Override
						public boolean hasNext() {
							return i.hasNext();
						}

						@Override
						public Entry<java.lang.Integer, java.lang.Integer> next() {
							return i.next();
						}

						@Override
						public void remove() {
							i.remove();
						}
					};
				}

				@Override
				public int size() {
					return TrieMap_IntKey_IntValue.this.size();
				}

				@Override
				public boolean isEmpty() {
					return TrieMap_IntKey_IntValue.this.isEmpty();
				}

				@SuppressWarnings("deprecation")
				@Override
				public void clear() {
					TrieMap_IntKey_IntValue.this.clear();
				}

				@Override
				public boolean contains(Object k) {
					return TrieMap_IntKey_IntValue.this.containsKey(k);
				}
			};
		}
		return entrySet;
	}

	@Override
	public boolean isTransientSupported() {
		return true;
	}

	@Override
	public TransientMap<java.lang.Integer, java.lang.Integer> asTransient() {
		return new TransientTrieMap_IntKey_IntValue(this);
	}

	@Override
	public int hashCode() {
		return hashCode;
	}

	@Override
	public boolean equals(Object other) {
		if (other == this) {
			return true;
		}
		if (other == null) {
			return false;
		}

		if (other instanceof TrieMap_IntKey_IntValue) {
			TrieMap_IntKey_IntValue that = (TrieMap_IntKey_IntValue) other;

			if (this.size() != that.size()) {
				return false;
			}

			return rootNode.equals(that.rootNode);
		}

		return super.equals(other);
	}

	/*
	 * For analysis purposes only.
	 */
	protected AbstractMapNode getRootNode() {
		return rootNode;
	}

	/*
	 * For analysis purposes only.
	 */
	protected Iterator<AbstractMapNode> nodeIterator() {
		return new TrieMap_IntKey_IntValueNodeIterator(rootNode);
	}

	/*
	 * For analysis purposes only.
	 */
	protected int getNodeCount() {
		final Iterator<AbstractMapNode> it = nodeIterator();
		int sumNodes = 0;

		for (; it.hasNext(); it.next()) {
			sumNodes += 1;
		}

		return sumNodes;
	}

	/*
	 * For analysis purposes only. Payload X Node
	 */
	protected int[][] arityCombinationsHistogram() {
		final Iterator<AbstractMapNode> it = nodeIterator();
		final int[][] sumArityCombinations = new int[17][17];

		while (it.hasNext()) {
			final AbstractMapNode node = it.next();
			sumArityCombinations[node.payloadArity()][node.nodeArity()] += 1;
		}

		return sumArityCombinations;
	}

	/*
	 * For analysis purposes only.
	 */
	protected int[] arityHistogram() {
		final int[][] sumArityCombinations = arityCombinationsHistogram();
		final int[] sumArity = new int[17];

		final int maxArity = 16; // TODO: factor out constant

		for (int j = 0; j <= maxArity; j++) {
			for (int maxRestArity = maxArity - j, k = 0; k <= maxRestArity - j; k++) {
				sumArity[j + k] += sumArityCombinations[j][k];
			}
		}

		return sumArity;
	}

	/*
	 * For analysis purposes only.
	 */
	public void printStatistics() {
		final int[][] sumArityCombinations = arityCombinationsHistogram();
		final int[] sumArity = arityHistogram();
		final int sumNodes = getNodeCount();

		final int[] cumsumArity = new int[17];
		for (int cumsum = 0, i = 0; i < 17; i++) {
			cumsum += sumArity[i];
			cumsumArity[i] = cumsum;
		}

		final float threshhold = 0.01f; // for printing results
		for (int i = 0; i < 17; i++) {
			float arityPercentage = (float) (sumArity[i]) / sumNodes;
			float cumsumArityPercentage = (float) (cumsumArity[i]) / sumNodes;

			if (arityPercentage != 0 && arityPercentage >= threshhold) {
				// details per level
				StringBuilder bldr = new StringBuilder();
				int max = i;
				for (int j = 0; j <= max; j++) {
					for (int k = max - j; k <= max - j; k++) {
						float arityCombinationsPercentage = (float) (sumArityCombinations[j][k])
										/ sumNodes;

						if (arityCombinationsPercentage != 0
										&& arityCombinationsPercentage >= threshhold) {
							bldr.append(String.format("%d/%d: %s, ", j, k, new DecimalFormat(
											"0.00%").format(arityCombinationsPercentage)));
						}
					}
				}
				final String detailPercentages = bldr.toString();

				// overview
				System.out.println(String.format("%2d: %s\t[cumsum = %s]\t%s", i,
								new DecimalFormat("0.00%").format(arityPercentage),
								new DecimalFormat("0.00%").format(cumsumArityPercentage),
								detailPercentages));
			}
		}
	}

	abstract static class Optional<T> {
		private static final Optional EMPTY = new Optional() {
			@Override
			boolean isPresent() {
				return false;
			}

			@Override
			Object get() {
				return null;
			}
		};

		@SuppressWarnings("unchecked")
		static <T> Optional<T> empty() {
			return EMPTY;
		}

		static <T> Optional<T> of(T value) {
			return new Value<T>(value);
		}

		abstract boolean isPresent();

		abstract T get();

		private static final class Value<T> extends Optional<T> {
			private final T value;

			private Value(T value) {
				this.value = value;
			}

			@Override
			boolean isPresent() {
				return true;
			}

			@Override
			T get() {
				return value;
			}
		}
	}

	static final class Result<T1, T2, N extends AbstractNode<T1, T2>> {
		private final N result;
		private final T2 replacedValue;
		private final boolean isModified;

		// update: inserted/removed single element, element count changed
		public static <T1, T2, N extends AbstractNode<T1, T2>> Result<T1, T2, N> modified(N node) {
			return new Result<>(node, null, true);
		}

		// update: replaced single mapping, but element count unchanged
		public static <T1, T2, N extends AbstractNode<T1, T2>> Result<T1, T2, N> updated(N node,
						T2 replacedValue) {
			return new Result<>(node, replacedValue, true);
		}

		// update: neither element, nor element count changed
		public static <T1, T2, N extends AbstractNode<T1, T2>> Result<T1, T2, N> unchanged(N node) {
			return new Result<>(node, null, false);
		}

		private Result(N node, T2 replacedValue, boolean isMutated) {
			this.result = node;
			this.replacedValue = replacedValue;
			this.isModified = isMutated;
		}

		public N getNode() {
			return result;
		}

		public boolean isModified() {
			return isModified;
		}

		public boolean hasReplacedValue() {
			return replacedValue != null;
		}

		public T2 getReplacedValue() {
			return replacedValue;
		}
	}

	protected static abstract class AbstractNode<K, V> {
	}

	protected static abstract class AbstractMapNode extends
					AbstractNode<java.lang.Integer, java.lang.Integer> {

		static final int TUPLE_LENGTH = 2;

		abstract boolean containsKey(final int key, int keyHash, int shift);

		abstract boolean containsKey(final int key, int keyHash, int shift, Comparator<Object> cmp);

		abstract Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift);

		abstract Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift,
						Comparator<Object> cmp);

		abstract Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> updated(
						AtomicReference<Thread> mutator, final int key, final int val, int keyHash,
						int shift);

		abstract Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> updated(
						AtomicReference<Thread> mutator, final int key, final int val, int keyHash,
						int shift, Comparator<Object> cmp);

		abstract Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift);

		abstract Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp);

		static final boolean isAllowedToEdit(AtomicReference<Thread> x, AtomicReference<Thread> y) {
			return x != null && y != null && (x == y || x.get() == y.get());
		}

		abstract int getKey(int index);

		abstract int getValue(int index);

		abstract java.util.Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(
						int index);

		abstract AbstractMapNode getNode(int index);

		abstract boolean hasNodes();

		@Deprecated
		Iterator<? extends AbstractMapNode> nodeIterator() {
			return new Iterator<AbstractMapNode>() {

				int nextIndex = 0;

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}

				@Override
				public AbstractMapNode next() {
					if (!hasNext())
						throw new NoSuchElementException();
					return AbstractMapNode.this.getNode(nextIndex++);
				}

				@Override
				public boolean hasNext() {
					return nextIndex < AbstractMapNode.this.nodeArity();
				}
			};
		}

		abstract int nodeArity();

		abstract boolean hasPayload();

		@Deprecated
		SupplierIterator<java.lang.Integer, java.lang.Integer> payloadIterator() {
			return new SupplierIterator<java.lang.Integer, java.lang.Integer>() {

				int nextIndex = 0;

				@Override
				public java.lang.Integer get() {
					if (nextIndex == 0 || nextIndex > AbstractMapNode.this.payloadArity()) {
						throw new NoSuchElementException();
					}

					return AbstractMapNode.this.getValue(nextIndex - 1);
				}

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}

				@Override
				public java.lang.Integer next() {
					if (!hasNext())
						throw new NoSuchElementException();
					return AbstractMapNode.this.getKey(nextIndex++);
				}

				@Override
				public boolean hasNext() {
					return nextIndex < AbstractMapNode.this.payloadArity();
				}
			};
		}

		abstract int payloadArity();

		/**
		 * The arity of this trie node (i.e. number of values and nodes stored
		 * on this level).
		 * 
		 * @return sum of nodes and values stored within
		 */
		int arity() {
			return payloadArity() + nodeArity();
		}

		int size() {
			final SupplierIterator<java.lang.Integer, java.lang.Integer> it = new MapKeyIterator(
							this);

			int size = 0;
			while (it.hasNext()) {
				size += 1;
				it.next();
			}

			return size;
		}
	}

	private static abstract class CompactMapNode extends AbstractMapNode {

		protected static final int BIT_PARTITION_SIZE = 4;
		protected static final int BIT_PARTITION_MASK = 0b1111;

		short nodeMap() {
			throw new UnsupportedOperationException();
		}

		short dataMap() {
			throw new UnsupportedOperationException();
		}

		static final byte SIZE_EMPTY = 0b00;
		static final byte SIZE_ONE = 0b01;
		static final byte SIZE_MORE_THAN_ONE = 0b10;

		/**
		 * Abstract predicate over a node's size. Value can be either
		 * {@value #SIZE_EMPTY}, {@value #SIZE_ONE}, or
		 * {@value #SIZE_MORE_THAN_ONE}.
		 * 
		 * @return size predicate
		 */
		abstract byte sizePredicate();

		/**
		 * Returns the first key stored within this node.
		 * 
		 * @return first key
		 */
		@Deprecated
		int headKey() {
			return getKey(0);
		}

		/**
		 * Returns the first value stored within this node.
		 * 
		 * @return first value
		 */
		@Deprecated
		int headVal() {
			return getValue(0);
		}

		@Override
		abstract CompactMapNode getNode(int index);

		@Deprecated
		@Override
		Iterator<? extends CompactMapNode> nodeIterator() {
			throw new UnsupportedOperationException();
		}

		boolean nodeInvariant() {
			boolean inv1 = (size() - payloadArity() >= 2 * (arity() - payloadArity()));
			boolean inv2 = (this.arity() == 0) ? sizePredicate() == SIZE_EMPTY : true;
			boolean inv3 = (this.arity() == 1 && payloadArity() == 1) ? sizePredicate() == SIZE_ONE
							: true;
			boolean inv4 = (this.arity() >= 2) ? sizePredicate() == SIZE_MORE_THAN_ONE : true;

			boolean inv5 = (this.nodeArity() >= 0) && (this.payloadArity() >= 0)
							&& ((this.payloadArity() + this.nodeArity()) == this.arity());

			return inv1 && inv2 && inv3 && inv4 && inv5;
		}

		abstract CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator,
						final short bitpos, final int val);

		abstract CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator,
						final short bitpos, final int key, final int val);

		abstract CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator,
						final short bitpos);

		abstract CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node);

		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new UnsupportedOperationException();
		}

		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new UnsupportedOperationException();
		}

		CompactMapNode copyAndMigrateFromInlineToNode(AtomicReference<Thread> mutator,
						final short bitpos, CompactMapNode node) {
			throw new UnsupportedOperationException();
		}

		CompactMapNode copyAndMigrateFromNodeToInline(AtomicReference<Thread> mutator,
						final short bitpos, CompactMapNode node) {
			throw new UnsupportedOperationException();
		}

		@SuppressWarnings("unchecked")
		static final CompactMapNode mergeNodes(final int key0, final int val0, int keyHash0,
						final int key1, final int val1, int keyHash1, int shift) {
			assert !(key0 == key1);

			if (keyHash0 == keyHash1) {
				return new HashCollisionMapNode_IntKey_IntValue(keyHash0, (int[]) new int[] { key0,
								key1 }, (int[]) new int[] { val0, val1 });
			}

			final int mask0 = (keyHash0 >>> shift) & BIT_PARTITION_MASK;
			final int mask1 = (keyHash1 >>> shift) & BIT_PARTITION_MASK;

			if (mask0 != mask1) {
				// both nodes fit on same level
				final short dataMap = (short) (1L << mask0 | 1L << mask1);

				if (mask0 < mask1) {
					return nodeOf(null, (short) 0, dataMap, key0, val0, key1, val1);
				} else {
					return nodeOf(null, (short) 0, dataMap, key1, val1, key0, val0);
				}
			} else {
				// values fit on next level
				final CompactMapNode node = mergeNodes(key0, val0, keyHash0, key1, val1, keyHash1,
								shift + BIT_PARTITION_SIZE);

				final short nodeMap = (short) (1L << mask0);
				return nodeOf(null, nodeMap, (short) 0, node);
			}
		}

		static final CompactMapNode mergeNodes(CompactMapNode node0, int keyHash0, final int key1,
						final int val1, int keyHash1, int shift) {
			final int mask0 = (keyHash0 >>> shift) & BIT_PARTITION_MASK;
			final int mask1 = (keyHash1 >>> shift) & BIT_PARTITION_MASK;

			if (mask0 != mask1) {
				// both nodes fit on same level
				final short nodeMap = (short) (1L << mask0);
				final short dataMap = (short) (1L << mask1);

				// store values before node
				return nodeOf(null, nodeMap, dataMap, key1, val1, node0);
			} else {
				// values fit on next level
				final CompactMapNode node = mergeNodes(node0, keyHash0, key1, val1, keyHash1, shift
								+ BIT_PARTITION_SIZE);

				final short nodeMap = (short) (1L << mask0);
				return nodeOf(null, nodeMap, (short) 0, node);
			}
		}

		static final CompactMapNode EMPTY_NODE;

		static {
			EMPTY_NODE = new Map0To0Node_IntKey_IntValue(null, (short) 0, (short) 0);
		};

		// TODO: consolidate and remove
		static final CompactMapNode nodeOf(AtomicReference<Thread> mutator) {
			return nodeOf(mutator, (short) 0, (short) 0);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap) {
			return EMPTY_NODE;
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1) {
			return new Map0To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map0To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map0To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map0To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			return new Map0To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			return new Map0To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			return new Map0To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			return new Map0To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			return new Map0To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			return new Map0To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11) {
			return new Map0To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12) {
			return new Map0To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13) {
			return new Map0To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14) {
			return new Map0To14Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14, final CompactMapNode node15) {
			return new Map0To15Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node15);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14, final CompactMapNode node15,
						final CompactMapNode node16) {
			return new Map0To16Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node15, node16);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1) {
			return new Map1To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1) {
			return new Map1To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map1To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map1To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			return new Map1To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			return new Map1To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			return new Map1To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			return new Map1To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			return new Map1To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			return new Map1To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			return new Map1To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11) {
			return new Map1To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12) {
			return new Map1To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13) {
			return new Map1To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13, final CompactMapNode node14) {
			return new Map1To14Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13, final CompactMapNode node14,
						final CompactMapNode node15) {
			return new Map1To15Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2) {
			return new Map2To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1) {
			return new Map2To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map2To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map2To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map2To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			return new Map2To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			return new Map2To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			return new Map2To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			return new Map2To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			return new Map2To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			return new Map2To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11) {
			return new Map2To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12) {
			return new Map2To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13) {
			return new Map2To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14) {
			return new Map2To14Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13, node14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3) {
			return new Map3To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1) {
			return new Map3To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map3To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map3To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			return new Map3To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			return new Map3To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			return new Map3To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			return new Map3To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			return new Map3To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
							node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			return new Map3To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
							node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			return new Map3To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11) {
			return new Map3To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12) {
			return new Map3To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13) {
			return new Map3To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4) {
			return new Map4To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1) {
			return new Map4To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map4To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map4To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map4To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			return new Map4To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			return new Map4To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			return new Map4To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			return new Map4To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			return new Map4To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			return new Map4To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11) {
			return new Map4To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12) {
			return new Map4To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5) {
			return new Map5To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1) {
			return new Map5To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map5To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map5To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			return new Map5To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			return new Map5To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			return new Map5To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			return new Map5To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			return new Map5To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			return new Map5To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			return new Map5To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11) {
			return new Map5To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6) {
			return new Map6To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1) {
			return new Map6To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map6To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map6To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map6To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			return new Map6To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			return new Map6To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			return new Map6To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			return new Map6To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			return new Map6To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			return new Map6To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7) {
			return new Map7To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1) {
			return new Map7To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map7To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map7To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			return new Map7To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			return new Map7To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			return new Map7To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			return new Map7To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			return new Map7To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			return new Map7To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8) {
			return new Map8To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1) {
			return new Map8To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map8To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map8To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map8To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			return new Map8To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			return new Map8To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			return new Map8To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			return new Map8To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9) {
			return new Map9To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1) {
			return new Map9To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map9To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map9To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			return new Map9To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			return new Map9To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			return new Map9To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			return new Map9To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10) {
			return new Map10To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final CompactMapNode node1) {
			return new Map10To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map10To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map10To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map10To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			return new Map10To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			return new Map10To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5,
							node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11) {
			return new Map11To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final CompactMapNode node1) {
			return new Map11To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map11To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map11To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			return new Map11To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			return new Map11To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12) {
			return new Map12To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final CompactMapNode node1) {
			return new Map12To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map12To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			return new Map12To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			return new Map12To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13) {
			return new Map13To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final CompactMapNode node1) {
			return new Map13To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final CompactMapNode node1, final CompactMapNode node2) {
			return new Map13To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			return new Map13To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final int key14, final int val14) {
			return new Map14To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final int key14, final int val14, final CompactMapNode node1) {
			return new Map14To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final int key14, final int val14, final CompactMapNode node1,
						final CompactMapNode node2) {
			return new Map14To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final int key14, final int val14, final int key15, final int val15) {
			return new Map15To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final int key14, final int val14, final int key15, final int val15,
						final CompactMapNode node1) {
			return new Map15To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int val1,
						final int key2, final int val2, final int key3, final int val3,
						final int key4, final int val4, final int key5, final int val5,
						final int key6, final int val6, final int key7, final int val7,
						final int key8, final int val8, final int key9, final int val9,
						final int key10, final int val10, final int key11, final int val11,
						final int key12, final int val12, final int key13, final int val13,
						final int key14, final int val14, final int key15, final int val15,
						final int key16, final int val16) {
			return new Map16To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, val1, key2,
							val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15, key16, val16);
		}

		final int dataIndex(final short bitpos) {
			return java.lang.Integer.bitCount((int) (dataMap() & 0xFFFF) & (bitpos - 1));
		}

		final int nodeIndex(final short bitpos) {
			return java.lang.Integer.bitCount((int) (nodeMap() & 0xFFFF) & (bitpos - 1));
		}

		int keyAt(final short bitpos) {
			return getKey(dataIndex(bitpos));
		}

		int valAt(final short bitpos) {
			return getValue(dataIndex(bitpos));
		}

		CompactMapNode nodeAt(final short bitpos) {
			return getNode(nodeIndex(bitpos));
		}

		@Override
		boolean containsKey(final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) {
				return keyAt(bitpos) == key;
			}

			if ((nodeMap() & bitpos) != 0) {
				return nodeAt(bitpos).containsKey(key, keyHash, shift + BIT_PARTITION_SIZE);
			}

			return false;
		}

		@Override
		boolean containsKey(final int key, int keyHash, int shift, Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) {
				return keyAt(bitpos) == key;
			}

			if ((nodeMap() & bitpos) != 0) {
				return nodeAt(bitpos).containsKey(key, keyHash, shift + BIT_PARTITION_SIZE, cmp);
			}

			return false;
		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					final int _val = valAt(bitpos);

					return Optional.of(_val);
				}

				return Optional.empty();
			}

			if ((nodeMap() & bitpos) != 0) { // node (not value)
				final AbstractMapNode subNode = nodeAt(bitpos);

				return subNode.findByKey(key, keyHash, shift + BIT_PARTITION_SIZE);
			}

			return Optional.empty();
		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift,
						Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					final int _val = valAt(bitpos);

					return Optional.of(_val);
				}

				return Optional.empty();
			}

			if ((nodeMap() & bitpos) != 0) { // node (not value)
				final AbstractMapNode subNode = nodeAt(bitpos);

				return subNode.findByKey(key, keyHash, shift + BIT_PARTITION_SIZE, cmp);
			}

			return Optional.empty();
		}

		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> updated(
						AtomicReference<Thread> mutator, final int key, final int val, int keyHash,
						int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int currentKey = keyAt(bitpos);

				if (currentKey == key) {
					final int currentVal = valAt(bitpos);

					if (currentVal == val) {
						return Result.unchanged(this);
					}

					// update mapping
					final CompactMapNode thisNew = copyAndSetValue(mutator, bitpos, val);

					return Result.updated(thisNew, currentVal);
				} else {
					final CompactMapNode nodeNew = mergeNodes(keyAt(bitpos), valAt(bitpos),
									(int) keyAt(bitpos), key, val, keyHash, shift
													+ BIT_PARTITION_SIZE);

					final CompactMapNode thisNew = copyAndRemoveValue(mutator, bitpos)
									.copyAndInsertNode(mutator, bitpos, nodeNew);

					return Result.modified(thisNew);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);

				final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> nestedResult = subNode
								.updated(mutator, key, val, keyHash, shift + BIT_PARTITION_SIZE);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactMapNode thisNew = copyAndSetNode(mutator, bitpos,
								nestedResult.getNode());

				if (nestedResult.hasReplacedValue()) {
					return Result.updated(thisNew, nestedResult.getReplacedValue());
				}

				return Result.modified(thisNew);
			} else {
				// no value
				final CompactMapNode thisNew = copyAndInsertValue(mutator, bitpos, key, val);

				return Result.modified(thisNew);
			}
		}

		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> updated(
						AtomicReference<Thread> mutator, final int key, final int val, int keyHash,
						int shift, Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int currentKey = keyAt(bitpos);

				if (currentKey == key) {
					final int currentVal = valAt(bitpos);

					if (currentVal == val) {
						return Result.unchanged(this);
					}

					// update mapping
					final CompactMapNode thisNew = copyAndSetValue(mutator, bitpos, val);

					return Result.updated(thisNew, currentVal);
				} else {
					final CompactMapNode nodeNew = mergeNodes(keyAt(bitpos), valAt(bitpos),
									(int) keyAt(bitpos), key, val, keyHash, shift
													+ BIT_PARTITION_SIZE);

					final CompactMapNode thisNew = copyAndRemoveValue(mutator, bitpos)
									.copyAndInsertNode(mutator, bitpos, nodeNew);

					return Result.modified(thisNew);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);

				final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> nestedResult = subNode
								.updated(mutator, key, val, keyHash, shift + BIT_PARTITION_SIZE,
												cmp);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactMapNode thisNew = copyAndSetNode(mutator, bitpos,
								nestedResult.getNode());

				if (nestedResult.hasReplacedValue()) {
					return Result.updated(thisNew, nestedResult.getReplacedValue());
				}

				return Result.modified(thisNew);
			} else {
				// no value
				final CompactMapNode thisNew = copyAndInsertValue(mutator, bitpos, key, val);

				return Result.modified(thisNew);
			}
		}

		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					if (this.payloadArity() == 2 && this.nodeArity() == 0) {
						/*
						 * Create new node with remaining pair. The new node
						 * will a) either become the new root returned, or b)
						 * unwrapped and inlined during returning.
						 */
						final CompactMapNode thisNew;
						final short newDataMap = (shift == 0) ? (short) (dataMap() ^ bitpos)
										: (short) (1L << (keyHash & BIT_PARTITION_MASK));

						if (dataIndex(bitpos) == 0) {
							thisNew = CompactMapNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(1), getValue(1));
						} else {
							thisNew = CompactMapNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(0), getValue(0));
						}

						return Result.modified(thisNew);
					} else {
						final CompactMapNode thisNew = copyAndRemoveValue(mutator, bitpos);

						return Result.modified(thisNew);
					}
				} else {
					return Result.unchanged(this);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);
				final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> nestedResult = subNode
								.removed(mutator, key, keyHash, shift + BIT_PARTITION_SIZE);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactMapNode subNodeNew = nestedResult.getNode();

				if (subNodeNew.sizePredicate() == 0) {
					throw new IllegalStateException("Sub-node must have at least one element.");
				}
				assert subNodeNew.sizePredicate() > 0;

				switch (subNodeNew.sizePredicate()) {
				case 1: {
					// inline value (move to front)
					// final CompactMapNode thisNew =
					// copyAndMigrateFromNodeToInline(mutator, bitpos,
					// subNodeNew);
					final CompactMapNode thisNew = copyAndRemoveNode(mutator, bitpos)
									.copyAndInsertValue(mutator, bitpos, subNodeNew.getKey(0),
													subNodeNew.getValue(0));

					return Result.modified(thisNew);
				}
				default: {
					// modify current node (set replacement node)
					final CompactMapNode thisNew = copyAndSetNode(mutator, bitpos, subNodeNew);

					return Result.modified(thisNew);
				}
				}
			}

			return Result.unchanged(this);
		}

		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					if (this.payloadArity() == 2 && this.nodeArity() == 0) {
						/*
						 * Create new node with remaining pair. The new node
						 * will a) either become the new root returned, or b)
						 * unwrapped and inlined during returning.
						 */
						final CompactMapNode thisNew;
						final short newDataMap = (shift == 0) ? (short) (dataMap() ^ bitpos)
										: (short) (1L << (keyHash & BIT_PARTITION_MASK));

						if (dataIndex(bitpos) == 0) {
							thisNew = CompactMapNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(1), getValue(1));
						} else {
							thisNew = CompactMapNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(0), getValue(0));
						}

						return Result.modified(thisNew);
					} else {
						final CompactMapNode thisNew = copyAndRemoveValue(mutator, bitpos);

						return Result.modified(thisNew);
					}
				} else {
					return Result.unchanged(this);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);
				final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> nestedResult = subNode
								.removed(mutator, key, keyHash, shift + BIT_PARTITION_SIZE, cmp);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactMapNode subNodeNew = nestedResult.getNode();

				if (subNodeNew.sizePredicate() == 0) {
					throw new IllegalStateException("Sub-node must have at least one element.");
				}
				assert subNodeNew.sizePredicate() > 0;

				switch (subNodeNew.sizePredicate()) {
				case 1: {
					// inline value (move to front)
					// final CompactMapNode thisNew =
					// copyAndMigrateFromNodeToInline(mutator, bitpos,
					// subNodeNew);
					final CompactMapNode thisNew = copyAndRemoveNode(mutator, bitpos)
									.copyAndInsertValue(mutator, bitpos, subNodeNew.getKey(0),
													subNodeNew.getValue(0));

					return Result.modified(thisNew);
				}
				default: {
					// modify current node (set replacement node)
					final CompactMapNode thisNew = copyAndSetNode(mutator, bitpos, subNodeNew);

					return Result.modified(thisNew);
				}
				}
			}

			return Result.unchanged(this);
		}

		/**
		 * @return 0 <= mask <= 2^BIT_PARTITION_SIZE - 1
		 */
		static byte recoverMask(short map, byte i_th) {
			assert 1 <= i_th && i_th <= 16;

			byte cnt1 = 0;
			byte mask = 0;

			while (mask < 16) {
				if ((map & 0x01) == 0x01) {
					cnt1 += 1;

					if (cnt1 == i_th) {
						return mask;
					}
				}

				map = (short) (map >> 1);
				mask += 1;
			}

			assert cnt1 != i_th;
			throw new RuntimeException("Called with invalid arguments.");
		}

		@Override
		public String toString() {
			final StringBuilder bldr = new StringBuilder();
			bldr.append('[');

			for (byte i = 0; i < payloadArity(); i++) {
				final byte pos = recoverMask(dataMap(), (byte) (i + 1));
				bldr.append(String.format("@%d: %s", pos, getKey(i), getValue(i)));

				if (!((i + 1) == payloadArity())) {
					bldr.append(", ");
				}
			}

			if (payloadArity() > 0 && nodeArity() > 0) {
				bldr.append(", ");
			}

			for (byte i = 0; i < nodeArity(); i++) {
				final byte pos = recoverMask(nodeMap(), (byte) (i + 1));
				bldr.append(String.format("@%d: %s", pos, getNode(i)));

				if (!((i + 1) == nodeArity())) {
					bldr.append(", ");
				}
			}

			bldr.append(']');
			return bldr.toString();
		}

	}

	private static abstract class CompactMixedMapNode extends CompactMapNode {

		private final short nodeMap;
		private final short dataMap;

		CompactMixedMapNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			this.nodeMap = nodeMap;
			this.dataMap = dataMap;
		}

		@Override
		public short nodeMap() {
			return nodeMap;
		}

		@Override
		public short dataMap() {
			return dataMap;
		}

	}

	private static abstract class CompactNodesOnlyMapNode extends CompactMapNode {

		private final short nodeMap;

		CompactNodesOnlyMapNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			this.nodeMap = nodeMap;
		}

		@Override
		public short nodeMap() {
			return nodeMap;
		}

		@Override
		public short dataMap() {
			return 0;
		}

	}

	private static abstract class CompactValuesOnlyMapNode extends CompactMapNode {

		private final short dataMap;

		CompactValuesOnlyMapNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			this.dataMap = dataMap;
		}

		@Override
		public short nodeMap() {
			return 0;
		}

		@Override
		public short dataMap() {
			return dataMap;
		}

	}

	private static abstract class CompactEmptyMapNode extends CompactMapNode {

		CompactEmptyMapNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
		}

		@Override
		public short nodeMap() {
			return 0;
		}

		@Override
		public short dataMap() {
			return 0;
		}

	}

	private static final class HashCollisionMapNode_IntKey_IntValue extends CompactMapNode {
		private final int[] keys;
		private final int[] vals;
		private final int hash;

		HashCollisionMapNode_IntKey_IntValue(final int hash, final int[] keys, final int[] vals) {
			this.keys = keys;
			this.vals = vals;
			this.hash = hash;

			assert payloadArity() >= 2;
		}

		@Override
		SupplierIterator<java.lang.Integer, java.lang.Integer> payloadIterator() {
			// TODO: change representation of keys and values
			assert keys.length == vals.length;

			final Object[] keysAndVals = new Object[keys.length + vals.length];
			for (int i = 0; i < keys.length; i++) {
				keysAndVals[2 * i] = keys[i];
				keysAndVals[2 * i + 1] = vals[i];
			}

			return ArrayKeyValueIterator.of(keysAndVals);
		}

		@Override
		public boolean containsKey(final int key, int keyHash, int shift) {

			if (this.hash == keyHash) {
				for (int k : keys) {
					if (k == key) {
						return true;
					}
				}
			}
			return false;

		}

		@Override
		public boolean containsKey(final int key, int keyHash, int shift, Comparator<Object> cmp) {

			if (this.hash == keyHash) {
				for (int k : keys) {
					if (k == key) {
						return true;
					}
				}
			}
			return false;

		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int hash, int shift) {

			for (int i = 0; i < keys.length; i++) {
				final int _key = keys[i];
				if (key == _key) {
					final int _val = vals[i];
					return Optional.of(_val);
				}
			}
			return Optional.empty();

		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int hash, int shift,
						Comparator<Object> cmp) {

			for (int i = 0; i < keys.length; i++) {
				final int _key = keys[i];
				if (key == _key) {
					final int _val = vals[i];
					return Optional.of(_val);
				}
			}
			return Optional.empty();

		}

		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> updated(
						AtomicReference<Thread> mutator, final int key, final int val, int keyHash,
						int shift) {
			if (this.hash != keyHash) {
				return Result.modified(mergeNodes(this, this.hash, key, val, keyHash, shift));
			}

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {

					final int currentVal = vals[idx];

					if (currentVal == val) {
						return Result.unchanged(this);
					}

					final int[] src = this.vals;

					final int[] dst = new int[src.length];

					// copy 'src' and set 1 element(s) at position 'idx'
					System.arraycopy(src, 0, dst, 0, src.length);
					dst[idx + 0] = val;

					final CompactMapNode thisNew = new HashCollisionMapNode_IntKey_IntValue(
									this.hash, this.keys, dst);

					return Result.updated(thisNew, currentVal);

				}
			}

			final int[] keysNew = new int[this.keys.length + 1];

			// copy 'this.keys' and insert 1 element(s) at position
			// 'keys.length'
			System.arraycopy(this.keys, 0, keysNew, 0, keys.length);
			keysNew[keys.length + 0] = key;
			System.arraycopy(this.keys, keys.length, keysNew, keys.length + 1, this.keys.length
							- keys.length);

			final int[] valsNew = new int[this.vals.length + 1];

			// copy 'this.vals' and insert 1 element(s) at position
			// 'vals.length'
			System.arraycopy(this.vals, 0, valsNew, 0, vals.length);
			valsNew[vals.length + 0] = val;
			System.arraycopy(this.vals, vals.length, valsNew, vals.length + 1, this.vals.length
							- vals.length);

			return Result.modified(new HashCollisionMapNode_IntKey_IntValue(keyHash, keysNew,
							valsNew));
		}

		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> updated(
						AtomicReference<Thread> mutator, final int key, final int val, int keyHash,
						int shift, Comparator<Object> cmp) {
			if (this.hash != keyHash) {
				return Result.modified(mergeNodes(this, this.hash, key, val, keyHash, shift));
			}

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {

					final int currentVal = vals[idx];

					if (currentVal == val) {
						return Result.unchanged(this);
					}

					final int[] src = this.vals;

					final int[] dst = new int[src.length];

					// copy 'src' and set 1 element(s) at position 'idx'
					System.arraycopy(src, 0, dst, 0, src.length);
					dst[idx + 0] = val;

					final CompactMapNode thisNew = new HashCollisionMapNode_IntKey_IntValue(
									this.hash, this.keys, dst);

					return Result.updated(thisNew, currentVal);

				}
			}

			final int[] keysNew = new int[this.keys.length + 1];

			// copy 'this.keys' and insert 1 element(s) at position
			// 'keys.length'
			System.arraycopy(this.keys, 0, keysNew, 0, keys.length);
			keysNew[keys.length + 0] = key;
			System.arraycopy(this.keys, keys.length, keysNew, keys.length + 1, this.keys.length
							- keys.length);

			final int[] valsNew = new int[this.vals.length + 1];

			// copy 'this.vals' and insert 1 element(s) at position
			// 'vals.length'
			System.arraycopy(this.vals, 0, valsNew, 0, vals.length);
			valsNew[vals.length + 0] = val;
			System.arraycopy(this.vals, vals.length, valsNew, vals.length + 1, this.vals.length
							- vals.length);

			return Result.modified(new HashCollisionMapNode_IntKey_IntValue(keyHash, keysNew,
							valsNew));
		}

		@SuppressWarnings("unchecked")
		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift) {

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					if (this.arity() == 1) {
						return Result.modified(CompactMapNode.nodeOf(mutator));
					} else if (this.arity() == 2) {
						/*
						 * Create root node with singleton element. This node
						 * will be a) either be the new root returned, or b)
						 * unwrapped and inlined.
						 */
						final int theOtherKey = (idx == 0) ? keys[1] : keys[0];
						final int theOtherVal = (idx == 0) ? vals[1] : vals[0];
						return CompactMapNode.nodeOf(mutator).updated(mutator, theOtherKey,
										theOtherVal, keyHash, 0);
					} else {

						final int[] keysNew = new int[this.keys.length - 1];

						// copy 'this.keys' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.keys, 0, keysNew, 0, idx);
						System.arraycopy(this.keys, idx + 1, keysNew, idx, this.keys.length - idx
										- 1);

						final int[] valsNew = new int[this.vals.length - 1];

						// copy 'this.vals' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.vals, 0, valsNew, 0, idx);
						System.arraycopy(this.vals, idx + 1, valsNew, idx, this.vals.length - idx
										- 1);

						return Result.modified(new HashCollisionMapNode_IntKey_IntValue(keyHash,
										keysNew, valsNew));
					}
				}
			}
			return Result.unchanged(this);

		}

		@SuppressWarnings("unchecked")
		@Override
		Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp) {

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					if (this.arity() == 1) {
						return Result.modified(CompactMapNode.nodeOf(mutator));
					} else if (this.arity() == 2) {
						/*
						 * Create root node with singleton element. This node
						 * will be a) either be the new root returned, or b)
						 * unwrapped and inlined.
						 */
						final int theOtherKey = (idx == 0) ? keys[1] : keys[0];
						final int theOtherVal = (idx == 0) ? vals[1] : vals[0];
						return CompactMapNode.nodeOf(mutator).updated(mutator, theOtherKey,
										theOtherVal, keyHash, 0, cmp);
					} else {

						final int[] keysNew = new int[this.keys.length - 1];

						// copy 'this.keys' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.keys, 0, keysNew, 0, idx);
						System.arraycopy(this.keys, idx + 1, keysNew, idx, this.keys.length - idx
										- 1);

						final int[] valsNew = new int[this.vals.length - 1];

						// copy 'this.vals' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.vals, 0, valsNew, 0, idx);
						System.arraycopy(this.vals, idx + 1, valsNew, idx, this.vals.length - idx
										- 1);

						return Result.modified(new HashCollisionMapNode_IntKey_IntValue(keyHash,
										keysNew, valsNew));
					}
				}
			}
			return Result.unchanged(this);

		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return keys.length;
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		int arity() {
			return payloadArity();
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		int getKey(int index) {
			return keys[index];
		}

		@Override
		int getValue(int index) {
			return vals[index];
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			return entryOf(keys[index], vals[index]);
		}

		@Override
		public CompactMapNode getNode(int index) {
			throw new IllegalStateException("Is leaf node.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 0;
			result = prime * result + hash;
			result = prime * result + Arrays.hashCode(keys);
			result = prime * result + Arrays.hashCode(vals);
			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}

			HashCollisionMapNode_IntKey_IntValue that = (HashCollisionMapNode_IntKey_IntValue) other;

			if (hash != that.hash) {
				return false;
			}

			if (arity() != that.arity()) {
				return false;
			}

			/*
			 * Linear scan for each key, because of arbitrary element order.
			 */
			outerLoop: for (SupplierIterator<java.lang.Integer, java.lang.Integer> it = that
							.payloadIterator(); it.hasNext();) {
				final int otherKey = it.next();
				@SuppressWarnings("deprecation")
				final int otherVal = it.get();

				for (int i = 0; i < keys.length; i++) {
					final int key = keys[i];
					final int val = vals[i];

					if (key == otherKey && val == otherVal) {
						continue outerLoop;
					}
				}
				return false;
			}

			return true;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new UnsupportedOperationException();
		}
	}

	/**
	 * Iterator skeleton that uses a fixed stack in depth.
	 */
	private static abstract class AbstractMapIterator {

		// TODO: verify maximum deepness
		private static final int MAX_DEPTH = 10;

		protected int currentValueCursor;
		protected int currentValueLength;
		protected AbstractMapNode currentValueNode;

		private int currentStackLevel;
		private final int[] nodeCursorsAndLengths = new int[MAX_DEPTH * 2];

		@SuppressWarnings("unchecked")
		AbstractMapNode[] nodes = new AbstractMapNode[MAX_DEPTH];

		AbstractMapIterator(AbstractMapNode rootNode) {
			currentStackLevel = 0;

			currentValueNode = rootNode;
			currentValueCursor = 0;
			currentValueLength = rootNode.payloadArity();

			nodes[0] = rootNode;
			nodeCursorsAndLengths[0] = 0;
			nodeCursorsAndLengths[1] = rootNode.nodeArity();
		}

		public boolean hasNext() {
			if (currentValueCursor < currentValueLength) {
				return true;
			} else {
				/*
				 * search for next node that contains values
				 */
				while (currentStackLevel >= 0) {
					final int currentCursorIndex = currentStackLevel * 2;
					final int currentLengthIndex = currentCursorIndex + 1;

					final int nodeCursor = nodeCursorsAndLengths[currentCursorIndex];
					final int nodeLength = nodeCursorsAndLengths[currentLengthIndex];

					if (nodeCursor < nodeLength) {
						final AbstractMapNode nextNode = nodes[currentStackLevel]
										.getNode(nodeCursor);
						nodeCursorsAndLengths[currentCursorIndex]++;

						final int nextValueLength = nextNode.payloadArity();
						final int nextNodeLength = nextNode.nodeArity();

						if (nextNodeLength > 0) {
							/*
							 * put node on next stack level for depth-first
							 * traversal
							 */
							final int nextStackLevel = ++currentStackLevel;
							final int nextCursorIndex = nextStackLevel * 2;
							final int nextLengthIndex = nextCursorIndex + 1;

							nodes[nextStackLevel] = nextNode;
							nodeCursorsAndLengths[nextCursorIndex] = 0;
							nodeCursorsAndLengths[nextLengthIndex] = nextNodeLength;
						}

						if (nextValueLength != 0) {
							/*
							 * found for next node that contains values
							 */
							currentValueNode = nextNode;
							currentValueCursor = 0;
							currentValueLength = nextValueLength;
							return true;
						}
					} else {
						currentStackLevel--;
					}
				}
			}

			return false;
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}
	}

	private static final class MapKeyIterator extends AbstractMapIterator implements
					SupplierIterator<java.lang.Integer, java.lang.Integer> {

		MapKeyIterator(AbstractMapNode rootNode) {
			super(rootNode);
		}

		@Override
		public java.lang.Integer next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getKey(currentValueCursor++);
			}
		}

		@Override
		public java.lang.Integer get() {
			throw new UnsupportedOperationException();
		}
	}

	private static final class MapValueIterator extends AbstractMapIterator implements
					SupplierIterator<java.lang.Integer, java.lang.Integer> {

		MapValueIterator(AbstractMapNode rootNode) {
			super(rootNode);
		}

		@Override
		public java.lang.Integer next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getValue(currentValueCursor++);
			}
		}

		@Override
		public java.lang.Integer get() {
			throw new UnsupportedOperationException();
		}
	}

	private static final class MapEntryIterator extends AbstractMapIterator
					implements
					SupplierIterator<Map.Entry<java.lang.Integer, java.lang.Integer>, java.lang.Integer> {

		MapEntryIterator(AbstractMapNode rootNode) {
			super(rootNode);
		}

		@Override
		public Map.Entry<java.lang.Integer, java.lang.Integer> next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getKeyValueEntry(currentValueCursor++);
			}
		}

		@Override
		public java.lang.Integer get() {
			throw new UnsupportedOperationException();
		}
	}

	/**
	 * Iterator that first iterates over inlined-values and then continues depth
	 * first recursively.
	 */
	private static class TrieMap_IntKey_IntValueNodeIterator implements Iterator<AbstractMapNode> {

		final Deque<Iterator<? extends AbstractMapNode>> nodeIteratorStack;

		TrieMap_IntKey_IntValueNodeIterator(AbstractMapNode rootNode) {
			nodeIteratorStack = new ArrayDeque<>();
			nodeIteratorStack.push(Collections.singleton(rootNode).iterator());
		}

		@Override
		public boolean hasNext() {
			while (true) {
				if (nodeIteratorStack.isEmpty()) {
					return false;
				} else {
					if (nodeIteratorStack.peek().hasNext()) {
						return true;
					} else {
						nodeIteratorStack.pop();
						continue;
					}
				}
			}
		}

		@Override
		public AbstractMapNode next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			}

			AbstractMapNode innerNode = nodeIteratorStack.peek().next();

			if (innerNode.hasNodes()) {
				nodeIteratorStack.push(innerNode.nodeIterator());
			}

			return innerNode;
		}

		@Override
		public void remove() {
			throw new UnsupportedOperationException();
		}
	}

	static final class TransientTrieMap_IntKey_IntValue extends
					AbstractMap<java.lang.Integer, java.lang.Integer> implements
					TransientMap<java.lang.Integer, java.lang.Integer> {
		final private AtomicReference<Thread> mutator;
		private AbstractMapNode rootNode;
		private int hashCode;
		private int cachedSize;

		TransientTrieMap_IntKey_IntValue(TrieMap_IntKey_IntValue trieMap_IntKey_IntValue) {
			this.mutator = new AtomicReference<Thread>(Thread.currentThread());
			this.rootNode = trieMap_IntKey_IntValue.rootNode;
			this.hashCode = trieMap_IntKey_IntValue.hashCode;
			this.cachedSize = trieMap_IntKey_IntValue.cachedSize;
			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
		}

		private boolean checkHashCodeAndSize(final int targetHash, final int targetSize) {
			int hash = 0;
			int size = 0;

			for (Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> it = entryIterator(); it
							.hasNext();) {
				final Map.Entry<java.lang.Integer, java.lang.Integer> entry = it.next();
				final int key = entry.getKey();
				final int val = entry.getValue();

				hash += (int) key ^ (int) val;
				size += 1;
			}

			return hash == targetHash && size == targetSize;
		}

		@Override
		public boolean containsKey(Object o) {
			try {
				final int key = (int) o;
				return rootNode.containsKey(key, (int) key, 0);
			} catch (ClassCastException unused) {
				return false;
			}
		}

		@Override
		public boolean containsKeyEquivalent(Object o, Comparator<Object> cmp) {
			try {
				final int key = (int) o;
				return rootNode.containsKey(key, (int) key, 0, cmp);
			} catch (ClassCastException unused) {
				return false;
			}
		}

		@Override
		public java.lang.Integer get(Object o) {
			try {
				final int key = (int) o;
				final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0);

				if (result.isPresent()) {
					return result.get();
				} else {
					return null;
				}
			} catch (ClassCastException unused) {
				return null;
			}
		}

		@Override
		public java.lang.Integer getEquivalent(Object o, Comparator<Object> cmp) {
			try {
				final int key = (int) o;
				final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0,
								cmp);

				if (result.isPresent()) {
					return result.get();
				} else {
					return null;
				}
			} catch (ClassCastException unused) {
				return null;
			}
		}

		@Override
		public java.lang.Integer __put(final java.lang.Integer key, final java.lang.Integer val) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
							.updated(mutator, key, val, keyHash, 0);

			if (result.isModified()) {
				rootNode = result.getNode();

				if (result.hasReplacedValue()) {
					final int old = result.getReplacedValue();

					final int valHashOld = (int) old;
					final int valHashNew = (int) val;

					hashCode += keyHash ^ valHashNew;
					hashCode -= keyHash ^ valHashOld;
					// cachedSize remains same

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return old;
				} else {
					final int valHashNew = (int) val;

					hashCode += keyHash ^ valHashNew;
					cachedSize += 1;

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return null;
				}
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return null;
		}

		@Override
		public java.lang.Integer __putEquivalent(final java.lang.Integer key,
						final java.lang.Integer val, final Comparator<Object> cmp) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
							.updated(mutator, key, val, keyHash, 0, cmp);

			if (result.isModified()) {
				rootNode = result.getNode();

				if (result.hasReplacedValue()) {
					final int old = result.getReplacedValue();

					final int valHashOld = (int) old;
					final int valHashNew = (int) val;

					hashCode += keyHash ^ valHashNew;
					hashCode -= keyHash ^ valHashOld;
					// cachedSize remains same

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return old;
				} else {
					final int valHashNew = (int) val;

					hashCode += keyHash ^ valHashNew;
					cachedSize += 1;

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return null;
				}
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return null;
		}

		@Override
		public boolean __putAll(
						final Map<? extends java.lang.Integer, ? extends java.lang.Integer> map) {
			boolean modified = false;

			for (Entry<? extends java.lang.Integer, ? extends java.lang.Integer> entry : map
							.entrySet()) {
				final boolean isPresent = containsKey(entry.getKey());
				final java.lang.Integer replaced = __put(entry.getKey(), entry.getValue());

				if (!isPresent || replaced != null) {
					modified = true;
				}
			}

			return modified;
		}

		@Override
		public boolean __putAllEquivalent(
						final Map<? extends java.lang.Integer, ? extends java.lang.Integer> map,
						final Comparator<Object> cmp) {
			boolean modified = false;

			for (Entry<? extends java.lang.Integer, ? extends java.lang.Integer> entry : map
							.entrySet()) {
				final boolean isPresent = containsKeyEquivalent(entry.getKey(), cmp);
				final java.lang.Integer replaced = __putEquivalent(entry.getKey(),
								entry.getValue(), cmp);

				if (!isPresent || replaced != null) {
					modified = true;
				}
			}

			return modified;
		}

		@Override
		public boolean __remove(final java.lang.Integer key) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");

			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
							.removed(mutator, key, keyHash, 0);

			if (result.isModified()) {

				// TODO: carry deleted value in result
				// assert result.hasReplacedValue();
				// final int valHash = result.getReplacedValue().hashCode();

				final int valHash = rootNode.findByKey(key, keyHash, 0).get().hashCode();

				rootNode = result.getNode();
				hashCode -= keyHash ^ valHash;
				cachedSize -= 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return true;

			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return false;
		}

		@Override
		public boolean __removeEquivalent(final java.lang.Integer key, Comparator<Object> cmp) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, java.lang.Integer, ? extends CompactMapNode> result = rootNode
							.removed(mutator, key, keyHash, 0, cmp);

			if (result.isModified()) {

				// TODO: carry deleted value in result
				// assert result.hasReplacedValue();
				// final int valHash = result.getReplacedValue().hashCode();

				final int valHash = rootNode.findByKey(key, keyHash, 0, cmp).get().hashCode();

				rootNode = result.getNode();
				hashCode -= keyHash ^ valHash;
				cachedSize -= 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return true;

			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return false;

		}

		@Override
		public Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet() {
			Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet = null;

			if (entrySet == null) {
				entrySet = new AbstractSet<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>>() {
					@Override
					public Iterator<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> iterator() {
						return new Iterator<Entry<java.lang.Integer, java.lang.Integer>>() {
							private final Iterator<Entry<java.lang.Integer, java.lang.Integer>> i = entryIterator();

							@Override
							public boolean hasNext() {
								return i.hasNext();
							}

							@Override
							public Entry<java.lang.Integer, java.lang.Integer> next() {
								return i.next();
							}

							@Override
							public void remove() {
								i.remove();
							}
						};
					}

					@Override
					public int size() {
						return TransientTrieMap_IntKey_IntValue.this.size();
					}

					@Override
					public boolean isEmpty() {
						return TransientTrieMap_IntKey_IntValue.this.isEmpty();
					}

					@Override
					public void clear() {
						TransientTrieMap_IntKey_IntValue.this.clear();
					}

					@Override
					public boolean contains(Object k) {
						return TransientTrieMap_IntKey_IntValue.this.containsKey(k);
					}
				};
			}
			return entrySet;
		}

		@Override
		public int size() {
			return cachedSize;
		}

		@Override
		public SupplierIterator<java.lang.Integer, java.lang.Integer> keyIterator() {
			return new TransientMapKeyIterator(this);
		}

		@Override
		public Iterator<java.lang.Integer> valueIterator() {
			// return new TrieMapValueIterator(keyIterator());
			return new MapValueIterator(rootNode); // TODO: iterator does not
													// support removal
		}

		@Override
		public Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> entryIterator() {
			// return new TrieMapEntryIterator(keyIterator());
			return new MapEntryIterator(rootNode); // TODO: iterator does not
													// support removal
		}

		/**
		 * Iterator that first iterates over inlined-values and then continues
		 * depth first recursively.
		 */
		private static class TransientMapKeyIterator extends AbstractMapIterator implements
						SupplierIterator<java.lang.Integer, java.lang.Integer> {

			final TransientTrieMap_IntKey_IntValue transientTrieMap_IntKey_IntValue;
			java.lang.Integer lastKey;

			TransientMapKeyIterator(
							TransientTrieMap_IntKey_IntValue transientTrieMap_IntKey_IntValue) {
				super(transientTrieMap_IntKey_IntValue.rootNode);
				this.transientTrieMap_IntKey_IntValue = transientTrieMap_IntKey_IntValue;
			}

			@Override
			public java.lang.Integer next() {
				if (!hasNext()) {
					throw new NoSuchElementException();
				} else {
					lastKey = currentValueNode.getKey(currentValueCursor++);
					return lastKey;
				}
			}

			@Override
			public java.lang.Integer get() {
				throw new UnsupportedOperationException();
			}

			/*
			 * TODO: test removal with iteration rigorously
			 */
			@Override
			public void remove() {
				boolean success = transientTrieMap_IntKey_IntValue.__remove(lastKey);

				if (!success) {
					throw new IllegalStateException("Key from iteration couldn't be deleted.");
				}
			}
		}

		@Override
		public boolean equals(Object other) {
			if (other == this) {
				return true;
			}
			if (other == null) {
				return false;
			}

			if (other instanceof TransientTrieMap_IntKey_IntValue) {
				TransientTrieMap_IntKey_IntValue that = (TransientTrieMap_IntKey_IntValue) other;

				if (this.size() != that.size()) {
					return false;
				}

				return rootNode.equals(that.rootNode);
			}

			return super.equals(other);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public ImmutableMap<java.lang.Integer, java.lang.Integer> freeze() {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			mutator.set(null);
			return new TrieMap_IntKey_IntValue(rootNode, hashCode, cachedSize);
		}
	}

	private static final class Map0To0Node_IntKey_IntValue extends CompactEmptyMapNode {

		Map0To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			super(mutator, nodeMap, dataMap);

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_EMPTY;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			int result = 1;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To1Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;

		Map0To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To1Node_IntKey_IntValue that = (Map0To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To2Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map0To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To2Node_IntKey_IntValue that = (Map0To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To3Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map0To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To3Node_IntKey_IntValue that = (Map0To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To4Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map0To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To4Node_IntKey_IntValue that = (Map0To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To5Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map0To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To5Node_IntKey_IntValue that = (Map0To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To6Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map0To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To6Node_IntKey_IntValue that = (Map0To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To7Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map0To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To7Node_IntKey_IntValue that = (Map0To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To8Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map0To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To8Node_IntKey_IntValue that = (Map0To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To9Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map0To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To9Node_IntKey_IntValue that = (Map0To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To10Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map0To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To10Node_IntKey_IntValue that = (Map0To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To11Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		Map0To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To11Node_IntKey_IntValue that = (Map0To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To12Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		Map0To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To12Node_IntKey_IntValue that = (Map0To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To13Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		Map0To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To13Node_IntKey_IntValue that = (Map0To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To14Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;

		Map0To14Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 14;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node13, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node14);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To14Node_IntKey_IntValue that = (Map0To14Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To15Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;
		private final CompactMapNode node15;

		Map0To15Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14, final CompactMapNode node15) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			case 14:
				return node15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 15;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13, node14, node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13, node14, node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13, node14, node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13, node14, node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13, node14, node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13, node14, node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node14, node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12, node13, node14,
								node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12, node13, node14,
								node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12, node13, node14,
								node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12, node13, node14,
								node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node13, node14,
								node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node14,
								node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node,
								node15);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13, node14, node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13, node14, node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13, node14, node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13, node14, node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13, node14, node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node14, node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();
			result = prime * result + node15.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To15Node_IntKey_IntValue that = (Map0To15Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}
			if (!(node15.equals(that.node15))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map0To16Node_IntKey_IntValue extends CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;
		private final CompactMapNode node15;
		private final CompactMapNode node16;

		Map0To16Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13,
						final CompactMapNode node14, final CompactMapNode node15,
						final CompactMapNode node16) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;
			this.node16 = node16;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			case 14:
				return node15;
			case 15:
				return node16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getValue(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 16;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13, node14, node15,
								node16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13, node14, node15,
								node16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13, node14, node15,
								node16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13, node14, node15,
								node16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node14, node15,
								node16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node15,
								node16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node,
								node16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13, node14, node15,
								node16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13, node14, node15, node16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13, node14, node15, node16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13, node14, node15, node16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node14, node15, node16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node15, node16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();
			result = prime * result + node15.hashCode();
			result = prime * result + node16.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map0To16Node_IntKey_IntValue that = (Map0To16Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}
			if (!(node15.equals(that.node15))) {
				return false;
			}
			if (!(node16.equals(that.node16))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;

		Map1To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To0Node_IntKey_IntValue that = (Map1To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;

		Map1To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To1Node_IntKey_IntValue that = (Map1To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map1To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To2Node_IntKey_IntValue that = (Map1To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map1To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To3Node_IntKey_IntValue that = (Map1To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map1To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To4Node_IntKey_IntValue that = (Map1To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map1To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To5Node_IntKey_IntValue that = (Map1To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map1To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To6Node_IntKey_IntValue that = (Map1To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map1To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To7Node_IntKey_IntValue that = (Map1To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map1To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To8Node_IntKey_IntValue that = (Map1To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map1To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To9Node_IntKey_IntValue that = (Map1To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To10Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map1To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To10Node_IntKey_IntValue that = (Map1To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To11Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		Map1To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To11Node_IntKey_IntValue that = (Map1To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To12Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		Map1To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To12Node_IntKey_IntValue that = (Map1To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To13Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		Map1To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11, node12,
								node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11, node12,
								node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11, node12,
								node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11, node12,
								node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11, node12,
								node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node12,
								node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node,
								node13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To13Node_IntKey_IntValue that = (Map1To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To14Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;

		Map1To14Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13, final CompactMapNode node14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 14;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12, node13,
								node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12, node13,
								node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12, node13,
								node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12, node13,
								node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12, node13,
								node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node13,
								node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node,
								node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11, node12,
								node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11, node12,
								node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11, node12,
								node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11, node12,
								node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node12,
								node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node,
								node13, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node, node14);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To14Node_IntKey_IntValue that = (Map1To14Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map1To15Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;
		private final CompactMapNode node15;

		Map1To15Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13, final CompactMapNode node14,
						final CompactMapNode node15) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			case 14:
				return node15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 15;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12, node13,
								node14, node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12, node13,
								node14, node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12, node13,
								node14, node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12, node13,
								node14, node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12, node13,
								node14, node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node13,
								node14, node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node,
								node14, node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node, node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12, node13, node14,
								node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12, node13, node14,
								node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12, node13, node14,
								node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12, node13, node14,
								node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node13, node14,
								node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node14,
								node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();
			result = prime * result + node15.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map1To15Node_IntKey_IntValue that = (Map1To15Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}
			if (!(node15.equals(that.node15))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;

		Map2To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To0Node_IntKey_IntValue that = (Map2To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;

		Map2To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To1Node_IntKey_IntValue that = (Map2To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map2To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To2Node_IntKey_IntValue that = (Map2To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map2To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To3Node_IntKey_IntValue that = (Map2To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map2To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To4Node_IntKey_IntValue that = (Map2To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map2To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To5Node_IntKey_IntValue that = (Map2To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map2To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To6Node_IntKey_IntValue that = (Map2To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map2To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To7Node_IntKey_IntValue that = (Map2To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map2To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To8Node_IntKey_IntValue that = (Map2To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map2To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To9Node_IntKey_IntValue that = (Map2To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To10Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map2To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To10Node_IntKey_IntValue that = (Map2To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To11Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		Map2To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9, node10,
								node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9, node10,
								node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9, node10,
								node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9, node10,
								node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9, node10,
								node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node10,
								node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To11Node_IntKey_IntValue that = (Map2To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To12Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		Map2To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10, node11,
								node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10, node11,
								node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10, node11,
								node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10, node11,
								node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10, node11,
								node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node11,
								node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9, node10,
								node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9, node10,
								node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9, node10,
								node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9, node10,
								node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node10,
								node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To12Node_IntKey_IntValue that = (Map2To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To13Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		Map2To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10, node11,
								node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10, node11,
								node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10, node11,
								node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10, node11,
								node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node11,
								node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9, node10,
								node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9, node10,
								node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9, node10,
								node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node10,
								node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node11, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node, node12, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node, node13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8, node9, node10, node11, node12,
								node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8, node9, node10, node11, node12,
								node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node9, node10, node11, node12,
								node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node10, node11, node12,
								node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node11, node12,
								node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node12,
								node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To13Node_IntKey_IntValue that = (Map2To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map2To14Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;

		Map2To14Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12,
						final CompactMapNode node13, final CompactMapNode node14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 14;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10, node11,
								node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10, node11,
								node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10, node11,
								node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10, node11,
								node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node11,
								node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node5, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node6, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node7, node8, node9, node10, node11, node12,
								node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node8, node9, node10, node11, node12,
								node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node9, node10, node11, node12,
								node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node10, node11, node12,
								node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node11, node12,
								node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node12,
								node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map2To14Node_IntKey_IntValue that = (Map2To14Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;

		Map3To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To0Node_IntKey_IntValue that = (Map3To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;

		Map3To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To1Node_IntKey_IntValue that = (Map3To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map3To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To2Node_IntKey_IntValue that = (Map3To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map3To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To3Node_IntKey_IntValue that = (Map3To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map3To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To4Node_IntKey_IntValue that = (Map3To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map3To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To5Node_IntKey_IntValue that = (Map3To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map3To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To6Node_IntKey_IntValue that = (Map3To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map3To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To7Node_IntKey_IntValue that = (Map3To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map3To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To8Node_IntKey_IntValue that = (Map3To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map3To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To9Node_IntKey_IntValue that = (Map3To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To10Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map3To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9,
								node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9,
								node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9,
								node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9,
								node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9,
								node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9,
								node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To10Node_IntKey_IntValue that = (Map3To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To11Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		Map3To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10,
								node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10,
								node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10,
								node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10,
								node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10,
								node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10,
								node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9,
								node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9,
								node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9,
								node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9,
								node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9,
								node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To11Node_IntKey_IntValue that = (Map3To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To12Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		Map3To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10,
								node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10,
								node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10,
								node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10,
								node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10,
								node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9,
								node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9,
								node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9,
								node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9,
								node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node10, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node, node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7, node8, node9, node10, node11,
								node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7, node8, node9, node10, node11,
								node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node8, node9, node10, node11,
								node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node9, node10, node11,
								node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node10, node11,
								node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node11,
								node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To12Node_IntKey_IntValue that = (Map3To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map3To13Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		Map3To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11,
						final CompactMapNode node12, final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10,
								node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10,
								node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10,
								node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10,
								node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10,
								node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node4, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node5, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node6, node7, node8, node9, node10, node11,
								node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node7, node8, node9, node10, node11,
								node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node8, node9, node10, node11,
								node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node9, node10, node11,
								node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node10, node11,
								node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node11,
								node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map3To13Node_IntKey_IntValue that = (Map3To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;

		Map4To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To0Node_IntKey_IntValue that = (Map4To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;

		Map4To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To1Node_IntKey_IntValue that = (Map4To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map4To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To2Node_IntKey_IntValue that = (Map4To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map4To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To3Node_IntKey_IntValue that = (Map4To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map4To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To4Node_IntKey_IntValue that = (Map4To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map4To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To5Node_IntKey_IntValue that = (Map4To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map4To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To6Node_IntKey_IntValue that = (Map4To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map4To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To7Node_IntKey_IntValue that = (Map4To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map4To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5, node6, node7,
								node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To8Node_IntKey_IntValue that = (Map4To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map4To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
								node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
								node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
								node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
								node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
								node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
								node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
								node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
								node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
								node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To9Node_IntKey_IntValue that = (Map4To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To10Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map4To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6, node7, node8, node9,
								node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6, node7, node8, node9,
								node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6, node7, node8, node9,
								node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node7, node8, node9,
								node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node8, node9,
								node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node9,
								node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
								node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
								node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
								node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
								node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
								node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
								node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
								node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6, node7, node8, node9,
								node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6, node7, node8, node9,
								node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6, node7, node8, node9,
								node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node7, node8, node9,
								node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node8, node9,
								node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node9,
								node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To10Node_IntKey_IntValue that = (Map4To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To11Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		Map4To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6, node7, node8, node9,
								node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6, node7, node8, node9,
								node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node7, node8, node9,
								node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node8, node9,
								node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node9,
								node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
								node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
								node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
								node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
								node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
								node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
								node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6, node7, node8, node9,
								node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6, node7, node8, node9,
								node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6, node7, node8, node9,
								node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node7, node8, node9,
								node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node8, node9,
								node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node9,
								node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To11Node_IntKey_IntValue that = (Map4To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map4To12Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		Map4To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10,
						final CompactMapNode node11, final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node, node6, node7, node8, node9,
								node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node, node7, node8, node9,
								node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node, node8, node9,
								node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node, node9,
								node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
								node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node2, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node3, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node4, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node5, node6, node7, node8, node9,
								node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node6, node7, node8, node9,
								node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node7, node8, node9,
								node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node8, node9,
								node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node9,
								node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map4To12Node_IntKey_IntValue that = (Map4To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;

		Map5To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To0Node_IntKey_IntValue that = (Map5To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;

		Map5To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To1Node_IntKey_IntValue that = (Map5To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map5To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To2Node_IntKey_IntValue that = (Map5To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map5To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To3Node_IntKey_IntValue that = (Map5To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map5To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To4Node_IntKey_IntValue that = (Map5To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map5To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To5Node_IntKey_IntValue that = (Map5To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map5To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4, node5,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To6Node_IntKey_IntValue that = (Map5To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map5To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4, node5,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
								node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
								node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
								node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
								node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
								node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
								node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To7Node_IntKey_IntValue that = (Map5To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map5To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
								node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
								node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
								node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
								node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
								node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
								node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
								node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
								node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
								node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
								node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
								node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
								node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
								node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To8Node_IntKey_IntValue that = (Map5To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map5To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
								node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
								node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
								node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
								node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
								node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
								node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
								node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
								node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
								node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
								node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
								node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5, node6, node7, node8,
								node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5, node6, node7, node8,
								node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5, node6, node7, node8,
								node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5, node6, node7, node8,
								node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node6, node7, node8,
								node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node7, node8,
								node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node8,
								node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To9Node_IntKey_IntValue that = (Map5To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To10Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map5To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
								node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
								node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
								node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
								node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
								node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
								node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
								node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5, node6, node7, node8,
								node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5, node6, node7, node8,
								node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5, node6, node7, node8,
								node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node6, node7, node8,
								node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node7, node8,
								node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node8,
								node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To10Node_IntKey_IntValue that = (Map5To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map5To11Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		Map5To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9,
						final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, node1, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
								node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
								node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
								node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
								node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node2, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node3, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node4, node5, node6, node7, node8,
								node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node5, node6, node7, node8,
								node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node6, node7, node8,
								node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node7, node8,
								node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node8,
								node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map5To11Node_IntKey_IntValue that = (Map5To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;

		Map6To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To0Node_IntKey_IntValue that = (Map6To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;

		Map6To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To1Node_IntKey_IntValue that = (Map6To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map6To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To2Node_IntKey_IntValue that = (Map6To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map6To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To3Node_IntKey_IntValue that = (Map6To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map6To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To4Node_IntKey_IntValue that = (Map6To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map6To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
								node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
								node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
								node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
								node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To5Node_IntKey_IntValue that = (Map6To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map6To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
								node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
								node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
								node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
								node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To6Node_IntKey_IntValue that = (Map6To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map6To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
								node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
								node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
								node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
								node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4, node5, node6,
								node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4, node5, node6,
								node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4, node5, node6,
								node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node5, node6,
								node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node6,
								node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To7Node_IntKey_IntValue that = (Map6To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map6To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
								node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
								node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4, node5, node6,
								node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4, node5, node6,
								node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4, node5, node6,
								node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node5, node6,
								node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node6,
								node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To8Node_IntKey_IntValue that = (Map6To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map6To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4, node5, node6,
								node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4, node5, node6,
								node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4, node5, node6,
								node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node5, node6,
								node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node6,
								node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To9Node_IntKey_IntValue that = (Map6To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map6To10Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		Map6To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8,
						final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node4, node5, node6,
								node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node5, node6,
								node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node6,
								node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map6To10Node_IntKey_IntValue that = (Map6To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;

		Map7To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To0Node_IntKey_IntValue that = (Map7To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;

		Map7To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To1Node_IntKey_IntValue that = (Map7To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map7To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To2Node_IntKey_IntValue that = (Map7To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map7To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
								node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
								node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
								node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To3Node_IntKey_IntValue that = (Map7To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map7To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
								node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
								node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To4Node_IntKey_IntValue that = (Map7To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map7To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3,
								node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
								node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
								node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node4,
								node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To5Node_IntKey_IntValue that = (Map7To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map7To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3,
								node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
								node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
								node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node4,
								node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To6Node_IntKey_IntValue that = (Map7To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map7To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
								node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
								node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node4,
								node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To7Node_IntKey_IntValue that = (Map7To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map7To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node4,
								node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To8Node_IntKey_IntValue that = (Map7To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map7To9Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		Map7To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7,
						final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node4,
								node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map7To9Node_IntKey_IntValue that = (Map7To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;

		Map8To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To0Node_IntKey_IntValue that = (Map8To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;

		Map8To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To1Node_IntKey_IntValue that = (Map8To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map8To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To2Node_IntKey_IntValue that = (Map8To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map8To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
								node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
								node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To3Node_IntKey_IntValue that = (Map8To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map8To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
								node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
								node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
								node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
								node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To4Node_IntKey_IntValue that = (Map8To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map8To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
								node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
								node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
								node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To5Node_IntKey_IntValue that = (Map8To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map8To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
								node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
								node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To6Node_IntKey_IntValue that = (Map8To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map8To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
								node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To7Node_IntKey_IntValue that = (Map8To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map8To8Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		Map8To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6,
						final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map8To8Node_IntKey_IntValue that = (Map8To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;

		Map9To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To0Node_IntKey_IntValue that = (Map9To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;

		Map9To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To1Node_IntKey_IntValue that = (Map9To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map9To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1,
						final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To2Node_IntKey_IntValue that = (Map9To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map9To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
								node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
								node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
								node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To3Node_IntKey_IntValue that = (Map9To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map9To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
								node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
								node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To4Node_IntKey_IntValue that = (Map9To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map9To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
								node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
								node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To5Node_IntKey_IntValue that = (Map9To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map9To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
								node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To6Node_IntKey_IntValue that = (Map9To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map9To7Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		Map9To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final CompactMapNode node1,
						final CompactMapNode node2, final CompactMapNode node3,
						final CompactMapNode node4, final CompactMapNode node5,
						final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
								node3, node4, node5, node6, node7);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map9To7Node_IntKey_IntValue that = (Map9To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;

		Map10To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To0Node_IntKey_IntValue that = (Map10To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;

		Map10To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To1Node_IntKey_IntValue that = (Map10To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map10To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To2Node_IntKey_IntValue that = (Map10To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map10To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To3Node_IntKey_IntValue that = (Map10To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map10To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To4Node_IntKey_IntValue that = (Map10To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map10To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To5Node_IntKey_IntValue that = (Map10To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map10To6Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		Map10To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map10To6Node_IntKey_IntValue that = (Map10To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map11To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;

		Map11To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map11To0Node_IntKey_IntValue that = (Map11To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map11To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;

		Map11To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11,
						final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map11To1Node_IntKey_IntValue that = (Map11To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map11To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map11To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map11To2Node_IntKey_IntValue that = (Map11To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map11To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map11To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map11To3Node_IntKey_IntValue that = (Map11To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map11To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map11To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, node1, node2, node3, node4);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map11To4Node_IntKey_IntValue that = (Map11To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map11To5Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		Map11To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4,
						final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map11To5Node_IntKey_IntValue that = (Map11To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map12To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;

		Map12To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map12To0Node_IntKey_IntValue that = (Map12To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map12To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;

		Map12To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map12To1Node_IntKey_IntValue that = (Map12To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map12To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map12To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map12To2Node_IntKey_IntValue that = (Map12To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map12To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map12To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, node1, node2,
								node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, node1, node2,
								node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, node1, node2,
								node3);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map12To3Node_IntKey_IntValue that = (Map12To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map12To4Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		Map12To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, node1, node2, node3,
								node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, node1, node2, node3, node4);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, node1, node2, node3, node4);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map12To4Node_IntKey_IntValue that = (Map12To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map13To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;

		Map13To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, key13, val13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, key13, val13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, key13, val13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, key13, val13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map13To0Node_IntKey_IntValue that = (Map13To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map13To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final CompactMapNode node1;

		Map13To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13,
						final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, key13, val13,
								node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, key13, val13,
								node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, key13, val13,
								node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, key13, val13,
								node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key, val,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map13To1Node_IntKey_IntValue that = (Map13To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map13To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map13To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13,
						final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, key13, val13,
								node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, key13, val13,
								node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, key13, val13,
								node1, node2);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key, val,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map13To2Node_IntKey_IntValue that = (Map13To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map13To3Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		Map13To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13,
						final CompactMapNode node1, final CompactMapNode node2,
						final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, node1, node2,
								node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, node1, node2,
								node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, node1, node2,
								node3);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, node1, node2, node3);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map13To3Node_IntKey_IntValue that = (Map13To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map14To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;

		Map14To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13, final int key14,
						final int val14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
								val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 14;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, key14, val14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, key14, val14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, key14, val14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, key14, val14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, key13, val13,
								key14, val14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, key13, val13,
								key14, val14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, key13, val13,
								key14, val14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key, val,
								key14, val14);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, key14, val14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, key14, val14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, key14, val14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key14, val14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;
			result = prime * result + (int) key14;
			result = prime * result + (int) val14;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map14To0Node_IntKey_IntValue that = (Map14To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(val14 == that.val14)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map14To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final CompactMapNode node1;

		Map14To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13, final int key14,
						final int val14, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
								val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 14;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, key14, val14,
								node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, key14, val14,
								node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, key14, val14,
								node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, key14, val14,
								node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14, val,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, key13, val13,
								key14, val14, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, key13, val13,
								key14, val14, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, key13, val13,
								key14, val14, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key, val,
								key14, val14, node1);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, key14, val14, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, key14, val14, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key14, val14, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;
			result = prime * result + (int) key14;
			result = prime * result + (int) val14;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map14To1Node_IntKey_IntValue that = (Map14To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(val14 == that.val14)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map14To2Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		Map14To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13, final int key14,
						final int val14, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
								val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 14;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, key14, val14,
								node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, key14, val14,
								node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, key14, val14,
								node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, key14, val14,
								node1, node2);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14, val,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, key14, val14, node1,
								node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, key14, val14, node1,
								node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key14, val14, node1,
								node2);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;
			result = prime * result + (int) key14;
			result = prime * result + (int) val14;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map14To2Node_IntKey_IntValue that = (Map14To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(val14 == that.val14)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map15To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final int key15;
		private final int val15;

		Map15To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13, final int key14,
						final int val14, final int key15, final int val15) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.key15 = key15;
			this.val15 = val15;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			case 14:
				return val15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
								val14);
			case 14:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key15,
								val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 15;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, key14, val14,
								key15, val15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, key14, val14,
								key15, val15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, key14, val14,
								key15, val15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, key14, val14,
								key15, val15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14, val,
								key15, val15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
								val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key,
								val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
								key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key, val, key10, val10, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key, val, key11, val11, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key, val, key12, val12, key13, val13,
								key14, val14, key15, val15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key, val, key13, val13,
								key14, val14, key15, val15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key, val,
								key14, val14, key15, val15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key, val, key15, val15);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, key14, val14, key15,
								val15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, key14, val14, key15,
								val15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key14, val14, key15,
								val15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key15,
								val15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;
			result = prime * result + (int) key14;
			result = prime * result + (int) val14;
			result = prime * result + (int) key15;
			result = prime * result + (int) val15;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map15To0Node_IntKey_IntValue that = (Map15To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(val14 == that.val14)) {
				return false;
			}
			if (!(key15 == that.key15)) {
				return false;
			}
			if (!(val15 == that.val15)) {
				return false;
			}

			return true;
		}

	}

	private static final class Map15To1Node_IntKey_IntValue extends CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final int key15;
		private final int val15;
		private final CompactMapNode node1;

		Map15To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13, final int key14,
						final int val14, final int key15, final int val15,
						final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.key15 = key15;
			this.val15 = val15;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			case 14:
				return val15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
								val14);
			case 14:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key15,
								val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 15;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, key14, val14,
								key15, val15, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, key14, val14,
								key15, val15, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, key14, val14,
								key15, val15, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, key14, val14,
								key15, val15, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14, val,
								key15, val15, node1);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, key14, val14, key15,
								val15, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, key14, val14, key15,
								val15, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key14, val14, key15,
								val15, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key15,
								val15, node1);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;
			result = prime * result + (int) key14;
			result = prime * result + (int) val14;
			result = prime * result + (int) key15;
			result = prime * result + (int) val15;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map15To1Node_IntKey_IntValue that = (Map15To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(val14 == that.val14)) {
				return false;
			}
			if (!(key15 == that.key15)) {
				return false;
			}
			if (!(val15 == that.val15)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Map16To0Node_IntKey_IntValue extends CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final int key15;
		private final int val15;
		private final int key16;
		private final int val16;

		Map16To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int val1, final int key2,
						final int val2, final int key3, final int val3, final int key4,
						final int val4, final int key5, final int val5, final int key6,
						final int val6, final int key7, final int val7, final int key8,
						final int val8, final int key9, final int val9, final int key10,
						final int val10, final int key11, final int val11, final int key12,
						final int val12, final int key13, final int val13, final int key14,
						final int val14, final int key15, final int val15, final int key16,
						final int val16) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.key15 = key15;
			this.val15 = val15;
			this.key16 = key16;
			this.val16 = val16;

			assert nodeInvariant();
		}

		@Override
		CompactMapNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			case 15:
				return key16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getValue(int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			case 14:
				return val15;
			case 15:
				return val16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
								val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
								val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
								val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
								val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
								val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
								val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
								val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
								val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
								val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
								val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
								val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
								val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
								val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
								val14);
			case 14:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key15,
								val15);
			case 15:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key16,
								val16);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 16;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(AtomicReference<Thread> mutator, final short bitpos,
						final int val) {
			final int idx = dataIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val, key11, val11, key12, val12, key13, val13, key14, val14,
								key15, val15, key16, val16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val, key12, val12, key13, val13, key14, val14,
								key15, val15, key16, val16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val, key13, val13, key14, val14,
								key15, val15, key16, val16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val, key14, val14,
								key15, val15, key16, val16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14, val,
								key15, val15, key16, val16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val, key16, val16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15, key16, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key, final int val) {
			throw new IllegalStateException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key5,
								val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key11, val11, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key12, val12, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key13, val13, key14, val14, key15,
								val15, key16, val16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key14, val14, key15,
								val15, key16, val16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key15,
								val15, key16, val16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key16, val16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3, key4,
								val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
								key10, val10, key11, val11, key12, val12, key13, val13, key14,
								val14, key15, val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactMapNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactMapNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) val1;
			result = prime * result + (int) key2;
			result = prime * result + (int) val2;
			result = prime * result + (int) key3;
			result = prime * result + (int) val3;
			result = prime * result + (int) key4;
			result = prime * result + (int) val4;
			result = prime * result + (int) key5;
			result = prime * result + (int) val5;
			result = prime * result + (int) key6;
			result = prime * result + (int) val6;
			result = prime * result + (int) key7;
			result = prime * result + (int) val7;
			result = prime * result + (int) key8;
			result = prime * result + (int) val8;
			result = prime * result + (int) key9;
			result = prime * result + (int) val9;
			result = prime * result + (int) key10;
			result = prime * result + (int) val10;
			result = prime * result + (int) key11;
			result = prime * result + (int) val11;
			result = prime * result + (int) key12;
			result = prime * result + (int) val12;
			result = prime * result + (int) key13;
			result = prime * result + (int) val13;
			result = prime * result + (int) key14;
			result = prime * result + (int) val14;
			result = prime * result + (int) key15;
			result = prime * result + (int) val15;
			result = prime * result + (int) key16;
			result = prime * result + (int) val16;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Map16To0Node_IntKey_IntValue that = (Map16To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(val1 == that.val1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(val2 == that.val2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(val3 == that.val3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(val4 == that.val4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(val5 == that.val5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(val6 == that.val6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(val7 == that.val7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(val8 == that.val8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(val9 == that.val9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(val10 == that.val10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(val11 == that.val11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(val12 == that.val12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(val13 == that.val13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(val14 == that.val14)) {
				return false;
			}
			if (!(key15 == that.key15)) {
				return false;
			}
			if (!(val15 == that.val15)) {
				return false;
			}
			if (!(key16 == that.key16)) {
				return false;
			}
			if (!(val16 == that.val16)) {
				return false;
			}

			return true;
		}

	}

}