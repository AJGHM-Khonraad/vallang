/*******************************************************************************
 * Copyright (c) 2013-2014 CWI
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *
 *   * Michael Steindorfer - Michael.Steindorfer@cwi.nl - CWI  
 *******************************************************************************/
package org.eclipse.imp.pdb.facts.util;

import java.text.DecimalFormat;
import java.util.AbstractSet;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicReference;

@SuppressWarnings("rawtypes")
public class TrieSet_IntKey_IntValue extends AbstractImmutableSet<java.lang.Integer> {

	@SuppressWarnings("unchecked")
	private static final TrieSet_IntKey_IntValue EMPTY_SET = new TrieSet_IntKey_IntValue(
					CompactSetNode.EMPTY_NODE, 0, 0);

	private static final boolean DEBUG = false;

	private final AbstractSetNode rootNode;
	private final int hashCode;
	private final int cachedSize;

	TrieSet_IntKey_IntValue(AbstractSetNode rootNode, int hashCode, int cachedSize) {
		this.rootNode = rootNode;
		this.hashCode = hashCode;
		this.cachedSize = cachedSize;
		if (DEBUG) {
			assert checkHashCodeAndSize(hashCode, cachedSize);
		}
	}

	@SuppressWarnings("unchecked")
	public static final ImmutableSet<java.lang.Integer> of() {
		return TrieSet_IntKey_IntValue.EMPTY_SET;
	}

	@SuppressWarnings("unchecked")
	public static final ImmutableSet<java.lang.Integer> of(int... keys) {
		ImmutableSet<java.lang.Integer> result = TrieSet_IntKey_IntValue.EMPTY_SET;

		for (final int key : keys) {
			result = result.__insert(key);
		}

		return result;
	}

	@SuppressWarnings("unchecked")
	public static final TransientSet<java.lang.Integer> transientOf() {
		return TrieSet_IntKey_IntValue.EMPTY_SET.asTransient();
	}

	@SuppressWarnings("unchecked")
	public static final TransientSet<java.lang.Integer> transientOf(int... keys) {
		final TransientSet<java.lang.Integer> result = TrieSet_IntKey_IntValue.EMPTY_SET
						.asTransient();

		for (final int key : keys) {
			result.__insert(key);
		}

		return result;
	}

	private boolean checkHashCodeAndSize(final int targetHash, final int targetSize) {
		int hash = 0;
		int size = 0;

		for (Iterator<java.lang.Integer> it = keyIterator(); it.hasNext();) {
			final int key = it.next();

			hash += (int) key;
			size += 1;
		}

		return hash == targetHash && size == targetSize;
	}

	@Override
	public TrieSet_IntKey_IntValue __insert(final java.lang.Integer key) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode.updated(
						null, key, keyHash, 0);

		if (result.isModified()) {

			return new TrieSet_IntKey_IntValue(result.getNode(), hashCode + keyHash, cachedSize + 1);

		}

		return this;
	}

	@Override
	public TrieSet_IntKey_IntValue __insertEquivalent(final java.lang.Integer key,
					Comparator<Object> cmp) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode.updated(
						null, key, keyHash, 0, cmp);

		if (result.isModified()) {

			return new TrieSet_IntKey_IntValue(result.getNode(), hashCode + keyHash, cachedSize + 1);

		}

		return this;
	}

	@Override
	public ImmutableSet<java.lang.Integer> __insertAll(ImmutableSet<? extends java.lang.Integer> set) {
		TransientSet<java.lang.Integer> tmp = asTransient();
		tmp.__insertAll(set);
		return tmp.freeze();
	}

	@Override
	public ImmutableSet<java.lang.Integer> __insertAllEquivalent(
					ImmutableSet<? extends java.lang.Integer> set, Comparator<Object> cmp) {
		TransientSet<java.lang.Integer> tmp = asTransient();
		tmp.__insertAllEquivalent(set, cmp);
		return tmp.freeze();
	}

	@Override
	public ImmutableSet<java.lang.Integer> __retainAll(ImmutableSet<? extends java.lang.Integer> set) {
		TransientSet<java.lang.Integer> tmp = asTransient();
		tmp.__retainAll(set);
		return tmp.freeze();
	}

	@Override
	public ImmutableSet<java.lang.Integer> __retainAllEquivalent(
					ImmutableSet<? extends java.lang.Integer> set, Comparator<Object> cmp) {
		TransientSet<java.lang.Integer> tmp = asTransient();
		tmp.__retainAllEquivalent(set, cmp);
		return tmp.freeze();
	}

	@Override
	public ImmutableSet<java.lang.Integer> __removeAll(ImmutableSet<? extends java.lang.Integer> set) {
		TransientSet<java.lang.Integer> tmp = asTransient();
		tmp.__removeAll(set);
		return tmp.freeze();
	}

	@Override
	public ImmutableSet<java.lang.Integer> __removeAllEquivalent(
					ImmutableSet<? extends java.lang.Integer> set, Comparator<Object> cmp) {
		TransientSet<java.lang.Integer> tmp = asTransient();
		tmp.__removeAllEquivalent(set, cmp);
		return tmp.freeze();
	}

	@Override
	public TrieSet_IntKey_IntValue __remove(final java.lang.Integer key) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode.removed(
						null, key, keyHash, 0);

		if (result.isModified()) {

			return new TrieSet_IntKey_IntValue(result.getNode(), hashCode - keyHash, cachedSize - 1);

		}

		return this;
	}

	@Override
	public TrieSet_IntKey_IntValue __removeEquivalent(final java.lang.Integer key,
					Comparator<Object> cmp) {
		final int keyHash = key.hashCode();
		final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode.removed(
						null, key, keyHash, 0, cmp);

		if (result.isModified()) {

			return new TrieSet_IntKey_IntValue(result.getNode(), hashCode - keyHash, cachedSize - 1);

		}

		return this;
	}

	@Override
	public boolean contains(Object o) {
		try {
			final int key = (int) o;
			return rootNode.containsKey(key, (int) key, 0);
		} catch (ClassCastException unused) {
			return false;
		}
	}

	@Override
	public boolean containsEquivalent(Object o, Comparator<Object> cmp) {
		try {
			final int key = (int) o;
			return rootNode.containsKey(key, (int) key, 0, cmp);
		} catch (ClassCastException unused) {
			return false;
		}
	}

	@Override
	public java.lang.Integer get(Object o) {
		try {
			final int key = (int) o;
			final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0);

			if (result.isPresent()) {
				return result.get();
			} else {
				return null;
			}
		} catch (ClassCastException unused) {
			return null;
		}
	}

	@Override
	public java.lang.Integer getEquivalent(Object o, Comparator<Object> cmp) {
		try {
			final int key = (int) o;
			final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0, cmp);

			if (result.isPresent()) {
				return result.get();
			} else {
				return null;
			}
		} catch (ClassCastException unused) {
			return null;
		}
	}

	@Override
	public int size() {
		return cachedSize;
	}

	@Override
	public Iterator<java.lang.Integer> iterator() {
		return keyIterator();
	}

	@Override
	public SupplierIterator<java.lang.Integer, java.lang.Integer> keyIterator() {
		return new SetKeyIterator(rootNode);
	}

	@Override
	public boolean isTransientSupported() {
		return true;
	}

	@Override
	public TransientSet<java.lang.Integer> asTransient() {
		return new TransientTrieSet_IntKey_IntValue(this);
	}

	@Override
	public int hashCode() {
		return hashCode;
	}

	@Override
	public boolean equals(Object other) {
		if (other == this) {
			return true;
		}
		if (other == null) {
			return false;
		}

		if (other instanceof TrieSet_IntKey_IntValue) {
			TrieSet_IntKey_IntValue that = (TrieSet_IntKey_IntValue) other;

			if (this.size() != that.size()) {
				return false;
			}

			return rootNode.equals(that.rootNode);
		}

		return super.equals(other);
	}

	/*
	 * For analysis purposes only.
	 */
	protected AbstractSetNode getRootNode() {
		return rootNode;
	}

	/*
	 * For analysis purposes only.
	 */
	protected Iterator<AbstractSetNode> nodeIterator() {
		return new TrieSet_IntKey_IntValueNodeIterator(rootNode);
	}

	/*
	 * For analysis purposes only.
	 */
	protected int getNodeCount() {
		final Iterator<AbstractSetNode> it = nodeIterator();
		int sumNodes = 0;

		for (; it.hasNext(); it.next()) {
			sumNodes += 1;
		}

		return sumNodes;
	}

	/*
	 * For analysis purposes only. Payload X Node
	 */
	protected int[][] arityCombinationsHistogram() {
		final Iterator<AbstractSetNode> it = nodeIterator();
		final int[][] sumArityCombinations = new int[17][17];

		while (it.hasNext()) {
			final AbstractSetNode node = it.next();
			sumArityCombinations[node.payloadArity()][node.nodeArity()] += 1;
		}

		return sumArityCombinations;
	}

	/*
	 * For analysis purposes only.
	 */
	protected int[] arityHistogram() {
		final int[][] sumArityCombinations = arityCombinationsHistogram();
		final int[] sumArity = new int[17];

		final int maxArity = 16; // TODO: factor out constant

		for (int j = 0; j <= maxArity; j++) {
			for (int maxRestArity = maxArity - j, k = 0; k <= maxRestArity - j; k++) {
				sumArity[j + k] += sumArityCombinations[j][k];
			}
		}

		return sumArity;
	}

	/*
	 * For analysis purposes only.
	 */
	public void printStatistics() {
		final int[][] sumArityCombinations = arityCombinationsHistogram();
		final int[] sumArity = arityHistogram();
		final int sumNodes = getNodeCount();

		final int[] cumsumArity = new int[17];
		for (int cumsum = 0, i = 0; i < 17; i++) {
			cumsum += sumArity[i];
			cumsumArity[i] = cumsum;
		}

		final float threshhold = 0.01f; // for printing results
		for (int i = 0; i < 17; i++) {
			float arityPercentage = (float) (sumArity[i]) / sumNodes;
			float cumsumArityPercentage = (float) (cumsumArity[i]) / sumNodes;

			if (arityPercentage != 0 && arityPercentage >= threshhold) {
				// details per level
				StringBuilder bldr = new StringBuilder();
				int max = i;
				for (int j = 0; j <= max; j++) {
					for (int k = max - j; k <= max - j; k++) {
						float arityCombinationsPercentage = (float) (sumArityCombinations[j][k])
										/ sumNodes;

						if (arityCombinationsPercentage != 0
										&& arityCombinationsPercentage >= threshhold) {
							bldr.append(String.format("%d/%d: %s, ", j, k, new DecimalFormat(
											"0.00%").format(arityCombinationsPercentage)));
						}
					}
				}
				final String detailPercentages = bldr.toString();

				// overview
				System.out.println(String.format("%2d: %s\t[cumsum = %s]\t%s", i,
								new DecimalFormat("0.00%").format(arityPercentage),
								new DecimalFormat("0.00%").format(cumsumArityPercentage),
								detailPercentages));
			}
		}
	}

	abstract static class Optional<T> {
		private static final Optional EMPTY = new Optional() {
			@Override
			boolean isPresent() {
				return false;
			}

			@Override
			Object get() {
				return null;
			}
		};

		@SuppressWarnings("unchecked")
		static <T> Optional<T> empty() {
			return EMPTY;
		}

		static <T> Optional<T> of(T value) {
			return new Value<T>(value);
		}

		abstract boolean isPresent();

		abstract T get();

		private static final class Value<T> extends Optional<T> {
			private final T value;

			private Value(T value) {
				this.value = value;
			}

			@Override
			boolean isPresent() {
				return true;
			}

			@Override
			T get() {
				return value;
			}
		}
	}

	static final class Result<T1, T2, N extends AbstractNode<T1, T2>> {
		private final N result;
		private final T2 replacedValue;
		private final boolean isModified;

		// update: inserted/removed single element, element count changed
		public static <T1, T2, N extends AbstractNode<T1, T2>> Result<T1, T2, N> modified(N node) {
			return new Result<>(node, null, true);
		}

		// update: replaced single mapping, but element count unchanged
		public static <T1, T2, N extends AbstractNode<T1, T2>> Result<T1, T2, N> updated(N node,
						T2 replacedValue) {
			return new Result<>(node, replacedValue, true);
		}

		// update: neither element, nor element count changed
		public static <T1, T2, N extends AbstractNode<T1, T2>> Result<T1, T2, N> unchanged(N node) {
			return new Result<>(node, null, false);
		}

		private Result(N node, T2 replacedValue, boolean isMutated) {
			this.result = node;
			this.replacedValue = replacedValue;
			this.isModified = isMutated;
		}

		public N getNode() {
			return result;
		}

		public boolean isModified() {
			return isModified;
		}

		public boolean hasReplacedValue() {
			return replacedValue != null;
		}

		public T2 getReplacedValue() {
			return replacedValue;
		}
	}

	protected static abstract class AbstractNode<K, V> {
	}

	protected static abstract class AbstractSetNode extends
					AbstractNode<java.lang.Integer, java.lang.Void> {

		static final int TUPLE_LENGTH = 1;

		abstract boolean containsKey(final int key, int keyHash, int shift);

		abstract boolean containsKey(final int key, int keyHash, int shift, Comparator<Object> cmp);

		abstract Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift);

		abstract Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift,
						Comparator<Object> cmp);

		abstract Result<java.lang.Integer, Void, ? extends CompactSetNode> updated(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift);

		abstract Result<java.lang.Integer, Void, ? extends CompactSetNode> updated(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp);

		abstract Result<java.lang.Integer, Void, ? extends CompactSetNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift);

		abstract Result<java.lang.Integer, Void, ? extends CompactSetNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp);

		static final boolean isAllowedToEdit(AtomicReference<Thread> x, AtomicReference<Thread> y) {
			return x != null && y != null && (x == y || x.get() == y.get());
		}

		abstract int getKey(int index);

		abstract AbstractSetNode getNode(int index);

		abstract boolean hasNodes();

		@Deprecated
		Iterator<? extends AbstractSetNode> nodeIterator() {
			return new Iterator<AbstractSetNode>() {

				int nextIndex = 0;

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}

				@Override
				public AbstractSetNode next() {
					if (!hasNext())
						throw new NoSuchElementException();
					return AbstractSetNode.this.getNode(nextIndex++);
				}

				@Override
				public boolean hasNext() {
					return nextIndex < AbstractSetNode.this.nodeArity();
				}
			};
		}

		abstract int nodeArity();

		abstract boolean hasPayload();

		@Deprecated
		SupplierIterator<java.lang.Integer, java.lang.Integer> payloadIterator() {
			return new SupplierIterator<java.lang.Integer, java.lang.Integer>() {

				int nextIndex = 0;

				@Override
				public java.lang.Integer get() {
					if (nextIndex == 0 || nextIndex > AbstractSetNode.this.payloadArity()) {
						throw new NoSuchElementException();
					}

					return AbstractSetNode.this.getKey(nextIndex - 1);
				}

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}

				@Override
				public java.lang.Integer next() {
					if (!hasNext())
						throw new NoSuchElementException();
					return AbstractSetNode.this.getKey(nextIndex++);
				}

				@Override
				public boolean hasNext() {
					return nextIndex < AbstractSetNode.this.payloadArity();
				}
			};
		}

		abstract int payloadArity();

		/**
		 * The arity of this trie node (i.e. number of values and nodes stored
		 * on this level).
		 * 
		 * @return sum of nodes and values stored within
		 */
		int arity() {
			return payloadArity() + nodeArity();
		}

		int size() {
			final SupplierIterator<java.lang.Integer, java.lang.Integer> it = new SetKeyIterator(
							this);

			int size = 0;
			while (it.hasNext()) {
				size += 1;
				it.next();
			}

			return size;
		}
	}

	private static abstract class CompactSetNode extends AbstractSetNode {

		protected static final int BIT_PARTITION_SIZE = 4;
		protected static final int BIT_PARTITION_MASK = 0b1111;

		short nodeMap() {
			throw new UnsupportedOperationException();
		}

		short dataMap() {
			throw new UnsupportedOperationException();
		}

		static final byte SIZE_EMPTY = 0b00;
		static final byte SIZE_ONE = 0b01;
		static final byte SIZE_MORE_THAN_ONE = 0b10;

		/**
		 * Abstract predicate over a node's size. Value can be either
		 * {@value #SIZE_EMPTY}, {@value #SIZE_ONE}, or
		 * {@value #SIZE_MORE_THAN_ONE}.
		 * 
		 * @return size predicate
		 */
		abstract byte sizePredicate();

		/**
		 * Returns the first key stored within this node.
		 * 
		 * @return first key
		 */
		@Deprecated
		int headKey() {
			return getKey(0);
		}

		@Override
		abstract CompactSetNode getNode(int index);

		@Deprecated
		@Override
		Iterator<? extends CompactSetNode> nodeIterator() {
			throw new UnsupportedOperationException();
		}

		boolean nodeInvariant() {
			boolean inv1 = (size() - payloadArity() >= 2 * (arity() - payloadArity()));
			boolean inv2 = (this.arity() == 0) ? sizePredicate() == SIZE_EMPTY : true;
			boolean inv3 = (this.arity() == 1 && payloadArity() == 1) ? sizePredicate() == SIZE_ONE
							: true;
			boolean inv4 = (this.arity() >= 2) ? sizePredicate() == SIZE_MORE_THAN_ONE : true;

			boolean inv5 = (this.nodeArity() >= 0) && (this.payloadArity() >= 0)
							&& ((this.payloadArity() + this.nodeArity()) == this.arity());

			return inv1 && inv2 && inv3 && inv4 && inv5;
		}

		abstract CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator,
						final short bitpos, final int key);

		abstract CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator,
						final short bitpos);

		abstract CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node);

		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new UnsupportedOperationException();
		}

		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new UnsupportedOperationException();
		}

		CompactSetNode copyAndMigrateFromInlineToNode(AtomicReference<Thread> mutator,
						final short bitpos, CompactSetNode node) {
			throw new UnsupportedOperationException();
		}

		CompactSetNode copyAndMigrateFromNodeToInline(AtomicReference<Thread> mutator,
						final short bitpos, CompactSetNode node) {
			throw new UnsupportedOperationException();
		}

		@SuppressWarnings("unchecked")
		static final CompactSetNode mergeNodes(final int key0, int keyHash0, final int key1,
						int keyHash1, int shift) {
			assert !(key0 == key1);

			if (keyHash0 == keyHash1) {
				return new HashCollisionSetNode_IntKey_IntValue(keyHash0, (int[]) new int[] { key0,
								key1 });
			}

			final int mask0 = (keyHash0 >>> shift) & BIT_PARTITION_MASK;
			final int mask1 = (keyHash1 >>> shift) & BIT_PARTITION_MASK;

			if (mask0 != mask1) {
				// both nodes fit on same level
				final short dataMap = (short) (1L << mask0 | 1L << mask1);

				if (mask0 < mask1) {
					return nodeOf(null, (short) 0, dataMap, key0, key1);
				} else {
					return nodeOf(null, (short) 0, dataMap, key1, key0);
				}
			} else {
				// values fit on next level
				final CompactSetNode node = mergeNodes(key0, keyHash0, key1, keyHash1, shift
								+ BIT_PARTITION_SIZE);

				final short nodeMap = (short) (1L << mask0);
				return nodeOf(null, nodeMap, (short) 0, node);
			}
		}

		static final CompactSetNode mergeNodes(CompactSetNode node0, int keyHash0, final int key1,
						int keyHash1, int shift) {
			final int mask0 = (keyHash0 >>> shift) & BIT_PARTITION_MASK;
			final int mask1 = (keyHash1 >>> shift) & BIT_PARTITION_MASK;

			if (mask0 != mask1) {
				// both nodes fit on same level
				final short nodeMap = (short) (1L << mask0);
				final short dataMap = (short) (1L << mask1);

				// store values before node
				return nodeOf(null, nodeMap, dataMap, key1, node0);
			} else {
				// values fit on next level
				final CompactSetNode node = mergeNodes(node0, keyHash0, key1, keyHash1, shift
								+ BIT_PARTITION_SIZE);

				final short nodeMap = (short) (1L << mask0);
				return nodeOf(null, nodeMap, (short) 0, node);
			}
		}

		static final CompactSetNode EMPTY_NODE;

		static {
			EMPTY_NODE = new Set0To0Node_IntKey_IntValue(null, (short) 0, (short) 0);
		};

		// TODO: consolidate and remove
		static final CompactSetNode nodeOf(AtomicReference<Thread> mutator) {
			return nodeOf(mutator, (short) 0, (short) 0);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap) {
			return EMPTY_NODE;
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1) {
			return new Set0To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2) {
			return new Set0To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			return new Set0To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			return new Set0To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			return new Set0To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			return new Set0To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			return new Set0To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			return new Set0To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			return new Set0To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			return new Set0To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11) {
			return new Set0To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12) {
			return new Set0To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13) {
			return new Set0To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14) {
			return new Set0To14Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14, final CompactSetNode node15) {
			return new Set0To15Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node15);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14, final CompactSetNode node15,
						final CompactSetNode node16) {
			return new Set0To16Node_IntKey_IntValue(mutator, nodeMap, dataMap, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node15, node16);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1) {
			return new Set1To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1) {
			return new Set1To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2) {
			return new Set1To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set1To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set1To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set1To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			return new Set1To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			return new Set1To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			return new Set1To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			return new Set1To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			return new Set1To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11) {
			return new Set1To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12) {
			return new Set1To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13) {
			return new Set1To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13, final CompactSetNode node14) {
			return new Set1To14Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13, final CompactSetNode node14,
						final CompactSetNode node15) {
			return new Set1To15Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2) {
			return new Set2To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1) {
			return new Set2To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2) {
			return new Set2To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set2To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set2To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set2To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			return new Set2To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			return new Set2To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			return new Set2To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			return new Set2To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			return new Set2To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11) {
			return new Set2To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12) {
			return new Set2To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13) {
			return new Set2To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13, final CompactSetNode node14) {
			return new Set2To14Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3) {
			return new Set3To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1) {
			return new Set3To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2) {
			return new Set3To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set3To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set3To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set3To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			return new Set3To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			return new Set3To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			return new Set3To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			return new Set3To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			return new Set3To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11) {
			return new Set3To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12) {
			return new Set3To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13) {
			return new Set3To13Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4) {
			return new Set4To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1) {
			return new Set4To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2) {
			return new Set4To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			return new Set4To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			return new Set4To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			return new Set4To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			return new Set4To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			return new Set4To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			return new Set4To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			return new Set4To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			return new Set4To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11) {
			return new Set4To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12) {
			return new Set4To12Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5) {
			return new Set5To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1) {
			return new Set5To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2) {
			return new Set5To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			return new Set5To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			return new Set5To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			return new Set5To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			return new Set5To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			return new Set5To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			return new Set5To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			return new Set5To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			return new Set5To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11) {
			return new Set5To11Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6) {
			return new Set6To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1) {
			return new Set6To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2) {
			return new Set6To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set6To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set6To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set6To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			return new Set6To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			return new Set6To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			return new Set6To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4, node5, node6, node7,
							node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			return new Set6To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4, node5, node6, node7,
							node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			return new Set6To10Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7) {
			return new Set7To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1) {
			return new Set7To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2) {
			return new Set7To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set7To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set7To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set7To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			return new Set7To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			return new Set7To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			return new Set7To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3, node4, node5, node6,
							node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			return new Set7To9Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8) {
			return new Set8To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1) {
			return new Set8To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2) {
			return new Set8To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			return new Set8To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			return new Set8To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			return new Set8To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			return new Set8To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2, node3, node4, node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			return new Set8To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2, node3, node4, node5, node6,
							node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			return new Set8To8Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, node1, node2, node3, node4, node5, node6,
							node7, node8);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9) {
			return new Set9To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1) {
			return new Set9To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2) {
			return new Set9To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			return new Set9To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			return new Set9To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			return new Set9To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1, node2, node3, node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			return new Set9To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1, node2, node3, node4, node5,
							node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			return new Set9To7Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, node1, node2, node3, node4, node5,
							node6, node7);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10) {
			return new Set10To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final CompactSetNode node1) {
			return new Set10To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2) {
			return new Set10To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set10To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set10To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, node1, node2, node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set10To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, node1, node2, node3, node4,
							node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			return new Set10To6Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, node1, node2, node3, node4,
							node5, node6);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11) {
			return new Set11To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final CompactSetNode node1) {
			return new Set11To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final CompactSetNode node1, final CompactSetNode node2) {
			return new Set11To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set11To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, node1, node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			return new Set11To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, node1, node2, node3,
							node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			return new Set11To5Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, node1, node2, node3,
							node4, node5);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12) {
			return new Set12To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final CompactSetNode node1) {
			return new Set12To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final CompactSetNode node1,
						final CompactSetNode node2) {
			return new Set12To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			return new Set12To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, node1, node2,
							node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			return new Set12To4Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, node1, node2,
							node3, node4);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13) {
			return new Set13To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13,
						final CompactSetNode node1) {
			return new Set13To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13,
						final CompactSetNode node1, final CompactSetNode node2) {
			return new Set13To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, node1,
							node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			return new Set13To3Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, node1,
							node2, node3);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13, final int key14) {
			return new Set14To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13, final int key14,
						final CompactSetNode node1) {
			return new Set14To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14,
							node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13, final int key14,
						final CompactSetNode node1, final CompactSetNode node2) {
			return new Set14To2Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14,
							node1, node2);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13, final int key14,
						final int key15) {
			return new Set15To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14,
							key15);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13, final int key14,
						final int key15, final CompactSetNode node1) {
			return new Set15To1Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14,
							key15, node1);
		}

		static final CompactSetNode nodeOf(final AtomicReference<Thread> mutator,
						final short nodeMap, final short dataMap, final int key1, final int key2,
						final int key3, final int key4, final int key5, final int key6,
						final int key7, final int key8, final int key9, final int key10,
						final int key11, final int key12, final int key13, final int key14,
						final int key15, final int key16) {
			return new Set16To0Node_IntKey_IntValue(mutator, nodeMap, dataMap, key1, key2, key3,
							key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14,
							key15, key16);
		}

		final int dataIndex(final short bitpos) {
			return java.lang.Integer.bitCount((int) (dataMap() & 0xFFFF) & (bitpos - 1));
		}

		final int nodeIndex(final short bitpos) {
			return java.lang.Integer.bitCount((int) (nodeMap() & 0xFFFF) & (bitpos - 1));
		}

		int keyAt(final short bitpos) {
			return getKey(dataIndex(bitpos));
		}

		CompactSetNode nodeAt(final short bitpos) {
			return getNode(nodeIndex(bitpos));
		}

		@Override
		boolean containsKey(final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) {
				return keyAt(bitpos) == key;
			}

			if ((nodeMap() & bitpos) != 0) {
				return nodeAt(bitpos).containsKey(key, keyHash, shift + BIT_PARTITION_SIZE);
			}

			return false;
		}

		@Override
		boolean containsKey(final int key, int keyHash, int shift, Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) {
				return keyAt(bitpos) == key;
			}

			if ((nodeMap() & bitpos) != 0) {
				return nodeAt(bitpos).containsKey(key, keyHash, shift + BIT_PARTITION_SIZE, cmp);
			}

			return false;
		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					final int _key = keyAt(bitpos);

					return Optional.of(_key);
				}

				return Optional.empty();
			}

			if ((nodeMap() & bitpos) != 0) { // node (not value)
				final AbstractSetNode subNode = nodeAt(bitpos);

				return subNode.findByKey(key, keyHash, shift + BIT_PARTITION_SIZE);
			}

			return Optional.empty();
		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int keyHash, int shift,
						Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					final int _key = keyAt(bitpos);

					return Optional.of(_key);
				}

				return Optional.empty();
			}

			if ((nodeMap() & bitpos) != 0) { // node (not value)
				final AbstractSetNode subNode = nodeAt(bitpos);

				return subNode.findByKey(key, keyHash, shift + BIT_PARTITION_SIZE, cmp);
			}

			return Optional.empty();
		}

		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> updated(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int currentKey = keyAt(bitpos);

				if (currentKey == key) {
					return Result.unchanged(this);
				} else {
					final CompactSetNode nodeNew = mergeNodes(keyAt(bitpos), (int) keyAt(bitpos),
									key, keyHash, shift + BIT_PARTITION_SIZE);

					final CompactSetNode thisNew = copyAndRemoveValue(mutator, bitpos)
									.copyAndInsertNode(mutator, bitpos, nodeNew);

					return Result.modified(thisNew);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactSetNode subNode = nodeAt(bitpos);

				final Result<java.lang.Integer, Void, ? extends CompactSetNode> nestedResult = subNode
								.updated(mutator, key, keyHash, shift + BIT_PARTITION_SIZE);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactSetNode thisNew = copyAndSetNode(mutator, bitpos,
								nestedResult.getNode());

				return Result.modified(thisNew);
			} else {
				// no value
				final CompactSetNode thisNew = copyAndInsertValue(mutator, bitpos, key);

				return Result.modified(thisNew);
			}
		}

		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> updated(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int currentKey = keyAt(bitpos);

				if (currentKey == key) {
					return Result.unchanged(this);
				} else {
					final CompactSetNode nodeNew = mergeNodes(keyAt(bitpos), (int) keyAt(bitpos),
									key, keyHash, shift + BIT_PARTITION_SIZE);

					final CompactSetNode thisNew = copyAndRemoveValue(mutator, bitpos)
									.copyAndInsertNode(mutator, bitpos, nodeNew);

					return Result.modified(thisNew);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactSetNode subNode = nodeAt(bitpos);

				final Result<java.lang.Integer, Void, ? extends CompactSetNode> nestedResult = subNode
								.updated(mutator, key, keyHash, shift + BIT_PARTITION_SIZE, cmp);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactSetNode thisNew = copyAndSetNode(mutator, bitpos,
								nestedResult.getNode());

				return Result.modified(thisNew);
			} else {
				// no value
				final CompactSetNode thisNew = copyAndInsertValue(mutator, bitpos, key);

				return Result.modified(thisNew);
			}
		}

		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					if (this.payloadArity() == 2 && this.nodeArity() == 0) {
						/*
						 * Create new node with remaining pair. The new node
						 * will a) either become the new root returned, or b)
						 * unwrapped and inlined during returning.
						 */
						final CompactSetNode thisNew;
						final short newDataMap = (shift == 0) ? (short) (dataMap() ^ bitpos)
										: (short) (1L << (keyHash & BIT_PARTITION_MASK));

						if (dataIndex(bitpos) == 0) {
							thisNew = CompactSetNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(1));
						} else {
							thisNew = CompactSetNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(0));
						}

						return Result.modified(thisNew);
					} else {
						final CompactSetNode thisNew = copyAndRemoveValue(mutator, bitpos);

						return Result.modified(thisNew);
					}
				} else {
					return Result.unchanged(this);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactSetNode subNode = nodeAt(bitpos);
				final Result<java.lang.Integer, Void, ? extends CompactSetNode> nestedResult = subNode
								.removed(mutator, key, keyHash, shift + BIT_PARTITION_SIZE);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactSetNode subNodeNew = nestedResult.getNode();

				if (subNodeNew.sizePredicate() == 0) {
					throw new IllegalStateException("Sub-node must have at least one element.");
				}
				assert subNodeNew.sizePredicate() > 0;

				switch (subNodeNew.sizePredicate()) {
				case 1: {
					// inline value (move to front)
					// final CompactSetNode thisNew =
					// copyAndMigrateFromNodeToInline(mutator, bitpos,
					// subNodeNew);
					final CompactSetNode thisNew = copyAndRemoveNode(mutator, bitpos)
									.copyAndInsertValue(mutator, bitpos, subNodeNew.getKey(0));

					return Result.modified(thisNew);
				}
				default: {
					// modify current node (set replacement node)
					final CompactSetNode thisNew = copyAndSetNode(mutator, bitpos, subNodeNew);

					return Result.modified(thisNew);
				}
				}
			}

			return Result.unchanged(this);
		}

		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp) {
			final int mask = (keyHash >>> shift) & BIT_PARTITION_MASK;
			final short bitpos = (short) (1L << mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				if (keyAt(bitpos) == key) {
					if (this.payloadArity() == 2 && this.nodeArity() == 0) {
						/*
						 * Create new node with remaining pair. The new node
						 * will a) either become the new root returned, or b)
						 * unwrapped and inlined during returning.
						 */
						final CompactSetNode thisNew;
						final short newDataMap = (shift == 0) ? (short) (dataMap() ^ bitpos)
										: (short) (1L << (keyHash & BIT_PARTITION_MASK));

						if (dataIndex(bitpos) == 0) {
							thisNew = CompactSetNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(1));
						} else {
							thisNew = CompactSetNode.nodeOf(mutator, (short) 0, newDataMap,
											getKey(0));
						}

						return Result.modified(thisNew);
					} else {
						final CompactSetNode thisNew = copyAndRemoveValue(mutator, bitpos);

						return Result.modified(thisNew);
					}
				} else {
					return Result.unchanged(this);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactSetNode subNode = nodeAt(bitpos);
				final Result<java.lang.Integer, Void, ? extends CompactSetNode> nestedResult = subNode
								.removed(mutator, key, keyHash, shift + BIT_PARTITION_SIZE, cmp);

				if (!nestedResult.isModified()) {
					return Result.unchanged(this);
				}

				final CompactSetNode subNodeNew = nestedResult.getNode();

				if (subNodeNew.sizePredicate() == 0) {
					throw new IllegalStateException("Sub-node must have at least one element.");
				}
				assert subNodeNew.sizePredicate() > 0;

				switch (subNodeNew.sizePredicate()) {
				case 1: {
					// inline value (move to front)
					// final CompactSetNode thisNew =
					// copyAndMigrateFromNodeToInline(mutator, bitpos,
					// subNodeNew);
					final CompactSetNode thisNew = copyAndRemoveNode(mutator, bitpos)
									.copyAndInsertValue(mutator, bitpos, subNodeNew.getKey(0));

					return Result.modified(thisNew);
				}
				default: {
					// modify current node (set replacement node)
					final CompactSetNode thisNew = copyAndSetNode(mutator, bitpos, subNodeNew);

					return Result.modified(thisNew);
				}
				}
			}

			return Result.unchanged(this);
		}

		/**
		 * @return 0 <= mask <= 2^BIT_PARTITION_SIZE - 1
		 */
		static byte recoverMask(short map, byte i_th) {
			assert 1 <= i_th && i_th <= 16;

			byte cnt1 = 0;
			byte mask = 0;

			while (mask < 16) {
				if ((map & 0x01) == 0x01) {
					cnt1 += 1;

					if (cnt1 == i_th) {
						return mask;
					}
				}

				map = (short) (map >> 1);
				mask += 1;
			}

			assert cnt1 != i_th;
			throw new RuntimeException("Called with invalid arguments.");
		}

		@Override
		public String toString() {
			final StringBuilder bldr = new StringBuilder();
			bldr.append('[');

			for (byte i = 0; i < payloadArity(); i++) {
				final byte pos = recoverMask(dataMap(), (byte) (i + 1));
				bldr.append(String.format("@%d: ", pos, getKey(i)));

				if (!((i + 1) == payloadArity())) {
					bldr.append(", ");
				}
			}

			if (payloadArity() > 0 && nodeArity() > 0) {
				bldr.append(", ");
			}

			for (byte i = 0; i < nodeArity(); i++) {
				final byte pos = recoverMask(nodeMap(), (byte) (i + 1));
				bldr.append(String.format("@%d: %s", pos, getNode(i)));

				if (!((i + 1) == nodeArity())) {
					bldr.append(", ");
				}
			}

			bldr.append(']');
			return bldr.toString();
		}

	}

	private static abstract class CompactMixedSetNode extends CompactSetNode {

		private final short nodeMap;
		private final short dataMap;

		CompactMixedSetNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			this.nodeMap = nodeMap;
			this.dataMap = dataMap;
		}

		@Override
		public short nodeMap() {
			return nodeMap;
		}

		@Override
		public short dataMap() {
			return dataMap;
		}

	}

	private static abstract class CompactNodesOnlySetNode extends CompactSetNode {

		private final short nodeMap;

		CompactNodesOnlySetNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			this.nodeMap = nodeMap;
		}

		@Override
		public short nodeMap() {
			return nodeMap;
		}

		@Override
		public short dataMap() {
			return 0;
		}

	}

	private static abstract class CompactValuesOnlySetNode extends CompactSetNode {

		private final short dataMap;

		CompactValuesOnlySetNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			this.dataMap = dataMap;
		}

		@Override
		public short nodeMap() {
			return 0;
		}

		@Override
		public short dataMap() {
			return dataMap;
		}

	}

	private static abstract class CompactEmptySetNode extends CompactSetNode {

		CompactEmptySetNode(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
		}

		@Override
		public short nodeMap() {
			return 0;
		}

		@Override
		public short dataMap() {
			return 0;
		}

	}

	private static final class HashCollisionSetNode_IntKey_IntValue extends CompactSetNode {
		private final int[] keys;

		private final int hash;

		HashCollisionSetNode_IntKey_IntValue(final int hash, final int[] keys) {
			this.keys = keys;

			this.hash = hash;

			assert payloadArity() >= 2;
		}

		@Override
		SupplierIterator<java.lang.Integer, java.lang.Integer> payloadIterator() {
			final Object[] keysAndVals = new Object[2 * keys.length];
			for (int i = 0; i < keys.length; i++) {
				keysAndVals[2 * i] = keys[i];
				keysAndVals[2 * i + 1] = keys[i];
			}

			return ArrayKeyValueSupplierIterator.of(keysAndVals);
		}

		@Override
		public boolean containsKey(final int key, int keyHash, int shift) {

			if (this.hash == keyHash) {
				for (int k : keys) {
					if (k == key) {
						return true;
					}
				}
			}
			return false;

		}

		@Override
		public boolean containsKey(final int key, int keyHash, int shift, Comparator<Object> cmp) {

			if (this.hash == keyHash) {
				for (int k : keys) {
					if (k == key) {
						return true;
					}
				}
			}
			return false;

		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int hash, int shift) {

			for (int i = 0; i < keys.length; i++) {
				final int _key = keys[i];
				if (key == _key) {
					return Optional.of(_key);
				}
			}
			return Optional.empty();

		}

		@Override
		Optional<java.lang.Integer> findByKey(final int key, int hash, int shift,
						Comparator<Object> cmp) {

			for (int i = 0; i < keys.length; i++) {
				final int _key = keys[i];
				if (key == _key) {
					return Optional.of(_key);
				}
			}
			return Optional.empty();

		}

		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> updated(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift) {
			if (this.hash != keyHash) {
				return Result.modified(mergeNodes(this, this.hash, key, keyHash, shift));
			}

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {

					return Result.unchanged(this);

				}
			}

			final int[] keysNew = new int[this.keys.length + 1];

			// copy 'this.keys' and insert 1 element(s) at position
			// 'keys.length'
			System.arraycopy(this.keys, 0, keysNew, 0, keys.length);
			keysNew[keys.length + 0] = key;
			System.arraycopy(this.keys, keys.length, keysNew, keys.length + 1, this.keys.length
							- keys.length);

			return Result.modified(new HashCollisionSetNode_IntKey_IntValue(keyHash, keysNew));
		}

		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> updated(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp) {
			if (this.hash != keyHash) {
				return Result.modified(mergeNodes(this, this.hash, key, keyHash, shift));
			}

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {

					return Result.unchanged(this);

				}
			}

			final int[] keysNew = new int[this.keys.length + 1];

			// copy 'this.keys' and insert 1 element(s) at position
			// 'keys.length'
			System.arraycopy(this.keys, 0, keysNew, 0, keys.length);
			keysNew[keys.length + 0] = key;
			System.arraycopy(this.keys, keys.length, keysNew, keys.length + 1, this.keys.length
							- keys.length);

			return Result.modified(new HashCollisionSetNode_IntKey_IntValue(keyHash, keysNew));
		}

		@SuppressWarnings("unchecked")
		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift) {

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					if (this.arity() == 1) {
						return Result.modified(CompactSetNode.nodeOf(mutator));
					} else if (this.arity() == 2) {
						/*
						 * Create root node with singleton element. This node
						 * will be a) either be the new root returned, or b)
						 * unwrapped and inlined.
						 */
						final int theOtherKey = (idx == 0) ? keys[1] : keys[0];

						return CompactSetNode.nodeOf(mutator).updated(mutator, theOtherKey,
										keyHash, 0);
					} else {

						final int[] keysNew = new int[this.keys.length - 1];

						// copy 'this.keys' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.keys, 0, keysNew, 0, idx);
						System.arraycopy(this.keys, idx + 1, keysNew, idx, this.keys.length - idx
										- 1);

						return Result.modified(new HashCollisionSetNode_IntKey_IntValue(keyHash,
										keysNew));
					}
				}
			}
			return Result.unchanged(this);

		}

		@SuppressWarnings("unchecked")
		@Override
		Result<java.lang.Integer, Void, ? extends CompactSetNode> removed(
						AtomicReference<Thread> mutator, final int key, int keyHash, int shift,
						Comparator<Object> cmp) {

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					if (this.arity() == 1) {
						return Result.modified(CompactSetNode.nodeOf(mutator));
					} else if (this.arity() == 2) {
						/*
						 * Create root node with singleton element. This node
						 * will be a) either be the new root returned, or b)
						 * unwrapped and inlined.
						 */
						final int theOtherKey = (idx == 0) ? keys[1] : keys[0];

						return CompactSetNode.nodeOf(mutator).updated(mutator, theOtherKey,
										keyHash, 0, cmp);
					} else {

						final int[] keysNew = new int[this.keys.length - 1];

						// copy 'this.keys' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.keys, 0, keysNew, 0, idx);
						System.arraycopy(this.keys, idx + 1, keysNew, idx, this.keys.length - idx
										- 1);

						return Result.modified(new HashCollisionSetNode_IntKey_IntValue(keyHash,
										keysNew));
					}
				}
			}
			return Result.unchanged(this);

		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return keys.length;
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		int arity() {
			return payloadArity();
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		int getKey(int index) {
			return keys[index];
		}

		@Override
		public CompactSetNode getNode(int index) {
			throw new IllegalStateException("Is leaf node.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 0;
			result = prime * result + hash;
			result = prime * result + Arrays.hashCode(keys);
			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}

			HashCollisionSetNode_IntKey_IntValue that = (HashCollisionSetNode_IntKey_IntValue) other;

			if (hash != that.hash) {
				return false;
			}

			if (arity() != that.arity()) {
				return false;
			}

			/*
			 * Linear scan for each key, because of arbitrary element order.
			 */
			outerLoop: for (SupplierIterator<java.lang.Integer, java.lang.Integer> it = that
							.payloadIterator(); it.hasNext();) {
				final int otherKey = it.next();

				for (int i = 0; i < keys.length; i++) {
					final int key = keys[i];

					if (key == otherKey) {
						continue outerLoop;
					}
				}
				return false;

			}

			return true;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new UnsupportedOperationException();
		}
	}

	/**
	 * Iterator skeleton that uses a fixed stack in depth.
	 */
	private static abstract class AbstractSetIterator {

		// TODO: verify maximum deepness
		private static final int MAX_DEPTH = 10;

		protected int currentValueCursor;
		protected int currentValueLength;
		protected AbstractSetNode currentValueNode;

		private int currentStackLevel;
		private final int[] nodeCursorsAndLengths = new int[MAX_DEPTH * 2];

		@SuppressWarnings("unchecked")
		AbstractSetNode[] nodes = new AbstractSetNode[MAX_DEPTH];

		AbstractSetIterator(AbstractSetNode rootNode) {
			currentStackLevel = 0;

			currentValueNode = rootNode;
			currentValueCursor = 0;
			currentValueLength = rootNode.payloadArity();

			nodes[0] = rootNode;
			nodeCursorsAndLengths[0] = 0;
			nodeCursorsAndLengths[1] = rootNode.nodeArity();
		}

		public boolean hasNext() {
			if (currentValueCursor < currentValueLength) {
				return true;
			} else {
				/*
				 * search for next node that contains values
				 */
				while (currentStackLevel >= 0) {
					final int currentCursorIndex = currentStackLevel * 2;
					final int currentLengthIndex = currentCursorIndex + 1;

					final int nodeCursor = nodeCursorsAndLengths[currentCursorIndex];
					final int nodeLength = nodeCursorsAndLengths[currentLengthIndex];

					if (nodeCursor < nodeLength) {
						final AbstractSetNode nextNode = nodes[currentStackLevel]
										.getNode(nodeCursor);
						nodeCursorsAndLengths[currentCursorIndex]++;

						final int nextValueLength = nextNode.payloadArity();
						final int nextNodeLength = nextNode.nodeArity();

						if (nextNodeLength > 0) {
							/*
							 * put node on next stack level for depth-first
							 * traversal
							 */
							final int nextStackLevel = ++currentStackLevel;
							final int nextCursorIndex = nextStackLevel * 2;
							final int nextLengthIndex = nextCursorIndex + 1;

							nodes[nextStackLevel] = nextNode;
							nodeCursorsAndLengths[nextCursorIndex] = 0;
							nodeCursorsAndLengths[nextLengthIndex] = nextNodeLength;
						}

						if (nextValueLength != 0) {
							/*
							 * found for next node that contains values
							 */
							currentValueNode = nextNode;
							currentValueCursor = 0;
							currentValueLength = nextValueLength;
							return true;
						}
					} else {
						currentStackLevel--;
					}
				}
			}

			return false;
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}
	}

	private static final class SetKeyIterator extends AbstractSetIterator implements
					SupplierIterator<java.lang.Integer, java.lang.Integer> {

		SetKeyIterator(AbstractSetNode rootNode) {
			super(rootNode);
		}

		@Override
		public java.lang.Integer next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getKey(currentValueCursor++);
			}
		}

		@Override
		public java.lang.Integer get() {
			throw new UnsupportedOperationException();
		}
	}

	/**
	 * Iterator that first iterates over inlined-values and then continues depth
	 * first recursively.
	 */
	private static class TrieSet_IntKey_IntValueNodeIterator implements Iterator<AbstractSetNode> {

		final Deque<Iterator<? extends AbstractSetNode>> nodeIteratorStack;

		TrieSet_IntKey_IntValueNodeIterator(AbstractSetNode rootNode) {
			nodeIteratorStack = new ArrayDeque<>();
			nodeIteratorStack.push(Collections.singleton(rootNode).iterator());
		}

		@Override
		public boolean hasNext() {
			while (true) {
				if (nodeIteratorStack.isEmpty()) {
					return false;
				} else {
					if (nodeIteratorStack.peek().hasNext()) {
						return true;
					} else {
						nodeIteratorStack.pop();
						continue;
					}
				}
			}
		}

		@Override
		public AbstractSetNode next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			}

			AbstractSetNode innerNode = nodeIteratorStack.peek().next();

			if (innerNode.hasNodes()) {
				nodeIteratorStack.push(innerNode.nodeIterator());
			}

			return innerNode;
		}

		@Override
		public void remove() {
			throw new UnsupportedOperationException();
		}
	}

	static final class TransientTrieSet_IntKey_IntValue extends AbstractSet<java.lang.Integer>
					implements TransientSet<java.lang.Integer> {
		final private AtomicReference<Thread> mutator;
		private AbstractSetNode rootNode;
		private int hashCode;
		private int cachedSize;

		TransientTrieSet_IntKey_IntValue(TrieSet_IntKey_IntValue trieSet_IntKey_IntValue) {
			this.mutator = new AtomicReference<Thread>(Thread.currentThread());
			this.rootNode = trieSet_IntKey_IntValue.rootNode;
			this.hashCode = trieSet_IntKey_IntValue.hashCode;
			this.cachedSize = trieSet_IntKey_IntValue.cachedSize;
			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
		}

		private boolean checkHashCodeAndSize(final int targetHash, final int targetSize) {
			int hash = 0;
			int size = 0;

			for (Iterator<java.lang.Integer> it = keyIterator(); it.hasNext();) {
				final int key = it.next();

				hash += (int) key;
				size += 1;
			}

			return hash == targetHash && size == targetSize;
		}

		@Override
		public boolean contains(Object o) {
			try {
				final int key = (int) o;
				return rootNode.containsKey(key, (int) key, 0);
			} catch (ClassCastException unused) {
				return false;
			}
		}

		@Override
		public boolean containsEquivalent(Object o, Comparator<Object> cmp) {
			try {
				final int key = (int) o;
				return rootNode.containsKey(key, (int) key, 0, cmp);
			} catch (ClassCastException unused) {
				return false;
			}
		}

		@Override
		public java.lang.Integer get(Object o) {
			try {
				final int key = (int) o;
				final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0);

				if (result.isPresent()) {
					return result.get();
				} else {
					return null;
				}
			} catch (ClassCastException unused) {
				return null;
			}
		}

		@Override
		public java.lang.Integer getEquivalent(Object o, Comparator<Object> cmp) {
			try {
				final int key = (int) o;
				final Optional<java.lang.Integer> result = rootNode.findByKey(key, (int) key, 0,
								cmp);

				if (result.isPresent()) {
					return result.get();
				} else {
					return null;
				}
			} catch (ClassCastException unused) {
				return null;
			}
		}

		@Override
		public boolean __insert(final java.lang.Integer key) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode
							.updated(mutator, key, keyHash, 0);

			if (result.isModified()) {
				rootNode = result.getNode();

				hashCode += keyHash;
				cachedSize += 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return true;
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return false;
		}

		@Override
		public boolean __insertEquivalent(final java.lang.Integer key, final Comparator<Object> cmp) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode
							.updated(mutator, key, keyHash, 0, cmp);

			if (result.isModified()) {
				rootNode = result.getNode();

				hashCode += keyHash;
				cachedSize += 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return true;
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return false;
		}

		@Override
		public boolean __insertAll(final ImmutableSet<? extends java.lang.Integer> set) {
			boolean modified = false;

			for (final int key : set) {
				modified |= __insert(key);
			}

			return modified;
		}

		@Override
		public boolean __insertAllEquivalent(final ImmutableSet<? extends java.lang.Integer> set,
						final Comparator<Object> cmp) {
			boolean modified = false;

			for (final int key : set) {
				modified |= __insertEquivalent(key, cmp);
			}

			return modified;
		}

		@Override
		public boolean __removeAll(final ImmutableSet<? extends java.lang.Integer> set) {
			boolean modified = false;

			for (final int key : set) {
				modified |= __remove(key);
			}

			return modified;
		}

		@Override
		public boolean __removeAllEquivalent(final ImmutableSet<? extends java.lang.Integer> set,
						final Comparator<Object> cmp) {
			boolean modified = false;

			for (final int key : set) {
				modified |= __removeEquivalent(key, cmp);
			}

			return modified;
		}

		@Override
		public boolean __remove(final java.lang.Integer key) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");

			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode
							.removed(mutator, key, keyHash, 0);

			if (result.isModified()) {

				rootNode = result.getNode();
				hashCode -= keyHash;
				cachedSize -= 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return true;

			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return false;
		}

		@Override
		public boolean __removeEquivalent(final java.lang.Integer key, Comparator<Object> cmp) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final Result<java.lang.Integer, Void, ? extends CompactSetNode> result = rootNode
							.removed(mutator, key, keyHash, 0, cmp);

			if (result.isModified()) {

				rootNode = result.getNode();
				hashCode -= keyHash;
				cachedSize -= 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return true;

			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return false;

		}

		@Override
		public boolean containsAll(Collection<?> c) {
			for (Object item : c) {
				if (!contains(item)) {
					return false;
				}
			}
			return true;
		}

		@Override
		public boolean containsAllEquivalent(Collection<?> c, Comparator<Object> cmp) {
			for (Object item : c) {
				if (!containsEquivalent(item, cmp)) {
					return false;
				}
			}
			return true;
		}

		@Override
		public boolean __retainAll(ImmutableSet<? extends java.lang.Integer> set) {
			boolean modified = false;

			Iterator<java.lang.Integer> thisIterator = iterator();
			while (thisIterator.hasNext()) {
				if (!set.contains(thisIterator.next())) {
					thisIterator.remove();
					modified = true;
				}
			}

			return modified;
		}

		@Override
		public boolean __retainAllEquivalent(ImmutableSet<? extends java.lang.Integer> set,
						Comparator<Object> cmp) {
			boolean modified = false;

			Iterator<java.lang.Integer> thisIterator = iterator();
			while (thisIterator.hasNext()) {
				if (!set.containsEquivalent(thisIterator.next(), cmp)) {
					thisIterator.remove();
					modified = true;
				}
			}

			return modified;
		}

		@Override
		public int size() {
			return cachedSize;
		}

		@Override
		public Iterator<java.lang.Integer> iterator() {
			return keyIterator();
		}

		@Override
		public SupplierIterator<java.lang.Integer, java.lang.Integer> keyIterator() {
			return new TransientSetKeyIterator(this);
		}

		/**
		 * Iterator that first iterates over inlined-values and then continues
		 * depth first recursively.
		 */
		private static class TransientSetKeyIterator extends AbstractSetIterator implements
						SupplierIterator<java.lang.Integer, java.lang.Integer> {

			final TransientTrieSet_IntKey_IntValue transientTrieSet_IntKey_IntValue;
			java.lang.Integer lastKey;

			TransientSetKeyIterator(
							TransientTrieSet_IntKey_IntValue transientTrieSet_IntKey_IntValue) {
				super(transientTrieSet_IntKey_IntValue.rootNode);
				this.transientTrieSet_IntKey_IntValue = transientTrieSet_IntKey_IntValue;
			}

			@Override
			public java.lang.Integer next() {
				if (!hasNext()) {
					throw new NoSuchElementException();
				} else {
					lastKey = currentValueNode.getKey(currentValueCursor++);
					return lastKey;
				}
			}

			@Override
			public java.lang.Integer get() {
				throw new UnsupportedOperationException();
			}

			/*
			 * TODO: test removal with iteration rigorously
			 */
			@Override
			public void remove() {
				boolean success = transientTrieSet_IntKey_IntValue.__remove(lastKey);

				if (!success) {
					throw new IllegalStateException("Key from iteration couldn't be deleted.");
				}
			}
		}

		@Override
		public boolean equals(Object other) {
			if (other == this) {
				return true;
			}
			if (other == null) {
				return false;
			}

			if (other instanceof TransientTrieSet_IntKey_IntValue) {
				TransientTrieSet_IntKey_IntValue that = (TransientTrieSet_IntKey_IntValue) other;

				if (this.size() != that.size()) {
					return false;
				}

				return rootNode.equals(that.rootNode);
			}

			return super.equals(other);
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public ImmutableSet<java.lang.Integer> freeze() {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			mutator.set(null);
			return new TrieSet_IntKey_IntValue(rootNode, hashCode, cachedSize);
		}
	}

	private static final class Set0To0Node_IntKey_IntValue extends CompactEmptySetNode {

		Set0To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap) {
			super(mutator, nodeMap, dataMap);

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_EMPTY;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			int result = 1;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To1Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;

		Set0To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To1Node_IntKey_IntValue that = (Set0To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To2Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set0To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To2Node_IntKey_IntValue that = (Set0To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To3Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set0To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To3Node_IntKey_IntValue that = (Set0To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To4Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set0To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To4Node_IntKey_IntValue that = (Set0To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To5Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set0To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To5Node_IntKey_IntValue that = (Set0To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To6Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set0To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To6Node_IntKey_IntValue that = (Set0To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To7Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set0To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To7Node_IntKey_IntValue that = (Set0To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To8Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set0To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To8Node_IntKey_IntValue that = (Set0To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To9Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set0To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To9Node_IntKey_IntValue that = (Set0To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To10Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set0To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To10Node_IntKey_IntValue that = (Set0To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To11Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;

		Set0To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To11Node_IntKey_IntValue that = (Set0To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To12Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;

		Set0To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To12Node_IntKey_IntValue that = (Set0To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To13Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;

		Set0To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To13Node_IntKey_IntValue that = (Set0To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To14Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;
		private final CompactSetNode node14;

		Set0To14Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 14;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node13, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node14);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To14Node_IntKey_IntValue that = (Set0To14Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To15Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;
		private final CompactSetNode node14;
		private final CompactSetNode node15;

		Set0To15Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14, final CompactSetNode node15) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			case 14:
				return node15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 15;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13, node14, node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13, node14, node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13, node14, node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13, node14, node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13, node14, node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13, node14, node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node14, node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node9, node10, node11, node12, node13, node14,
								node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node10, node11, node12, node13, node14,
								node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node11, node12, node13, node14,
								node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node12, node13, node14,
								node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node13, node14,
								node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node14,
								node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node,
								node15);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13, node14, node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13, node14, node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13, node14, node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13, node14, node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13, node14, node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13, node14, node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node14, node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();
			result = prime * result + node15.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To15Node_IntKey_IntValue that = (Set0To15Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}
			if (!(node15.equals(that.node15))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set0To16Node_IntKey_IntValue extends CompactNodesOnlySetNode {

		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;
		private final CompactSetNode node14;
		private final CompactSetNode node15;
		private final CompactSetNode node16;

		Set0To16Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14, final CompactSetNode node15,
						final CompactSetNode node16) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;
			this.node16 = node16;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			case 14:
				return node15;
			case 15:
				return node16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 16;
		}

		@Override
		boolean hasPayload() {
			return false;
		}

		@Override
		int payloadArity() {
			return 0;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node, node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node, node10, node11, node12, node13, node14, node15,
								node16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node, node11, node12, node13, node14, node15,
								node16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node, node12, node13, node14, node15,
								node16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node, node13, node14, node15,
								node16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node, node14, node15,
								node16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node, node15,
								node16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node,
								node16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14,
								node15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node2, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, node1, node3, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node4, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node5, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node6, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node7,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node8, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node9, node10, node11, node12, node13, node14, node15,
								node16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node10, node11, node12, node13, node14, node15,
								node16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node11, node12, node13, node14, node15, node16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node12, node13, node14, node15, node16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node13, node14, node15, node16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node14, node15, node16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node15, node16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();
			result = prime * result + node15.hashCode();
			result = prime * result + node16.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set0To16Node_IntKey_IntValue that = (Set0To16Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}
			if (!(node15.equals(that.node15))) {
				return false;
			}
			if (!(node16.equals(that.node16))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;

		Set1To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To0Node_IntKey_IntValue that = (Set1To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;

		Set1To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To1Node_IntKey_IntValue that = (Set1To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set1To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To2Node_IntKey_IntValue that = (Set1To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set1To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To3Node_IntKey_IntValue that = (Set1To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set1To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To4Node_IntKey_IntValue that = (Set1To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set1To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To5Node_IntKey_IntValue that = (Set1To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set1To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To6Node_IntKey_IntValue that = (Set1To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set1To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To7Node_IntKey_IntValue that = (Set1To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set1To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To8Node_IntKey_IntValue that = (Set1To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set1To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To9Node_IntKey_IntValue that = (Set1To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To10Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set1To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To10Node_IntKey_IntValue that = (Set1To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To11Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;

		Set1To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To11Node_IntKey_IntValue that = (Set1To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To12Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;

		Set1To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node10, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To12Node_IntKey_IntValue that = (Set1To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To13Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;

		Set1To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node10, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node11, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node, node12, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node, node13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To13Node_IntKey_IntValue that = (Set1To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To14Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;
		private final CompactSetNode node14;

		Set1To14Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 14;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node8, node9, node10, node11, node12, node13,
								node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node9, node10, node11, node12, node13,
								node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node10, node11, node12, node13,
								node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node11, node12, node13,
								node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node, node12, node13,
								node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node, node13,
								node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node,
								node14);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To14Node_IntKey_IntValue that = (Set1To14Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set1To15Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;
		private final CompactSetNode node14;
		private final CompactSetNode node15;

		Set1To15Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11,
						final CompactSetNode node12, final CompactSetNode node13,
						final CompactSetNode node14, final CompactSetNode node15) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			case 14:
				return node15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 15;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 1;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node, node7, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node, node8, node9, node10, node11, node12, node13, node14,
								node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node, node9, node10, node11, node12, node13, node14,
								node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node, node10, node11, node12, node13, node14,
								node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node, node11, node12, node13, node14,
								node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node, node12, node13, node14,
								node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node, node13, node14,
								node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node, node14,
								node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node,
								node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, node2, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node3, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node4, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node5, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node6,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node8, node9, node10, node11, node12, node13, node14, node15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node9, node10, node11, node12, node13, node14, node15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node10, node11, node12, node13, node14, node15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node11, node12, node13, node14, node15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node12, node13, node14, node15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node13, node14, node15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node14, node15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();
			result = prime * result + node15.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set1To15Node_IntKey_IntValue that = (Set1To15Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}
			if (!(node15.equals(that.node15))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;

		Set2To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To0Node_IntKey_IntValue that = (Set2To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;

		Set2To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To1Node_IntKey_IntValue that = (Set2To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set2To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To2Node_IntKey_IntValue that = (Set2To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set2To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To3Node_IntKey_IntValue that = (Set2To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set2To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To4Node_IntKey_IntValue that = (Set2To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set2To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To5Node_IntKey_IntValue that = (Set2To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set2To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To6Node_IntKey_IntValue that = (Set2To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set2To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To7Node_IntKey_IntValue that = (Set2To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set2To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To8Node_IntKey_IntValue that = (Set2To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set2To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To9Node_IntKey_IntValue that = (Set2To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To10Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set2To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To10Node_IntKey_IntValue that = (Set2To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To11Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;

		Set2To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To11Node_IntKey_IntValue that = (Set2To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To12Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;

		Set2To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To12Node_IntKey_IntValue that = (Set2To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To13Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;

		Set2To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node7, node8, node9, node10, node11, node12,
								node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node8, node9, node10, node11, node12,
								node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node9, node10, node11, node12,
								node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node10, node11, node12,
								node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node11, node12,
								node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node12,
								node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node,
								node13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To13Node_IntKey_IntValue that = (Set2To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set2To14Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;
		private final CompactSetNode node14;

		Set2To14Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13, final CompactSetNode node14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			case 13:
				return node14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 14;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 2;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, node1, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node, node6, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node, node7, node8, node9, node10, node11, node12, node13,
								node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node, node8, node9, node10, node11, node12, node13,
								node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node, node9, node10, node11, node12, node13,
								node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node, node10, node11, node12, node13,
								node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node, node11, node12, node13,
								node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node, node12, node13,
								node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node, node13,
								node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node,
								node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node2, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node3, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node4, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node5,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node11, node12, node13, node14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node12, node13, node14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node13, node14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();
			result = prime * result + node14.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set2To14Node_IntKey_IntValue that = (Set2To14Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}
			if (!(node14.equals(that.node14))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;

		Set3To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To0Node_IntKey_IntValue that = (Set3To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;

		Set3To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To1Node_IntKey_IntValue that = (Set3To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set3To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To2Node_IntKey_IntValue that = (Set3To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set3To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To3Node_IntKey_IntValue that = (Set3To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set3To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To4Node_IntKey_IntValue that = (Set3To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set3To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To5Node_IntKey_IntValue that = (Set3To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set3To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To6Node_IntKey_IntValue that = (Set3To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set3To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To7Node_IntKey_IntValue that = (Set3To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set3To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To8Node_IntKey_IntValue that = (Set3To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set3To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To9Node_IntKey_IntValue that = (Set3To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To10Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set3To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To10Node_IntKey_IntValue that = (Set3To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To11Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;

		Set3To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node7, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node8, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node9, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node, node10, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node, node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To11Node_IntKey_IntValue that = (Set3To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To12Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;

		Set3To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node6, node7, node8, node9, node10, node11,
								node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node7, node8, node9, node10, node11,
								node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node8, node9, node10, node11,
								node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node9, node10, node11,
								node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node, node10, node11,
								node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node, node11,
								node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node,
								node12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To12Node_IntKey_IntValue that = (Set3To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set3To13Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;
		private final CompactSetNode node13;

		Set3To13Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12,
						final CompactSetNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			case 12:
				return node13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 13;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 3;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, node1, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node, node5, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node, node6, node7, node8, node9, node10, node11, node12,
								node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node, node7, node8, node9, node10, node11, node12,
								node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node, node8, node9, node10, node11, node12,
								node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node, node9, node10, node11, node12,
								node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node, node10, node11, node12,
								node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node, node11, node12,
								node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node, node12,
								node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node,
								node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node2, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node3, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node4,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node10, node11, node12, node13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node11, node12, node13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node12, node13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();
			result = prime * result + node13.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set3To13Node_IntKey_IntValue that = (Set3To13Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}
			if (!(node13.equals(that.node13))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;

		Set4To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To0Node_IntKey_IntValue that = (Set4To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;

		Set4To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To1Node_IntKey_IntValue that = (Set4To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set4To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To2Node_IntKey_IntValue that = (Set4To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set4To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To3Node_IntKey_IntValue that = (Set4To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set4To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To4Node_IntKey_IntValue that = (Set4To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set4To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To5Node_IntKey_IntValue that = (Set4To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set4To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To6Node_IntKey_IntValue that = (Set4To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set4To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To7Node_IntKey_IntValue that = (Set4To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set4To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To8Node_IntKey_IntValue that = (Set4To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set4To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To9Node_IntKey_IntValue that = (Set4To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To10Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set4To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To10Node_IntKey_IntValue that = (Set4To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To11Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;

		Set4To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node3, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node5, node6, node7, node8, node9, node10,
								node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node6, node7, node8, node9, node10,
								node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node7, node8, node9, node10,
								node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node8, node9, node10,
								node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node9, node10,
								node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node10,
								node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To11Node_IntKey_IntValue that = (Set4To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set4To12Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;
		private final CompactSetNode node12;

		Set4To12Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9, final CompactSetNode node10,
						final CompactSetNode node11, final CompactSetNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			case 11:
				return node12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 12;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 4;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, node1, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node, node4, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node, node5, node6, node7, node8, node9, node10, node11,
								node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node, node6, node7, node8, node9, node10, node11,
								node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node, node7, node8, node9, node10, node11,
								node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node, node8, node9, node10, node11,
								node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node, node9, node10, node11,
								node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node, node10, node11,
								node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node, node11,
								node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node,
								node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node2, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node3,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node9, node10, node11, node12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node10, node11, node12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node11, node12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();
			result = prime * result + node12.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set4To12Node_IntKey_IntValue that = (Set4To12Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}
			if (!(node12.equals(that.node12))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;

		Set5To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To0Node_IntKey_IntValue that = (Set5To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;

		Set5To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To1Node_IntKey_IntValue that = (Set5To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set5To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To2Node_IntKey_IntValue that = (Set5To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set5To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To3Node_IntKey_IntValue that = (Set5To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set5To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To4Node_IntKey_IntValue that = (Set5To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set5To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To5Node_IntKey_IntValue that = (Set5To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set5To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To6Node_IntKey_IntValue that = (Set5To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set5To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To7Node_IntKey_IntValue that = (Set5To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set5To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To8Node_IntKey_IntValue that = (Set5To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set5To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To9Node_IntKey_IntValue that = (Set5To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To10Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set5To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9,
								node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9,
								node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9,
								node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9,
								node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9,
								node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9,
								node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9,
								node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To10Node_IntKey_IntValue that = (Set5To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set5To11Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;
		private final CompactSetNode node11;

		Set5To11Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10, final CompactSetNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			case 10:
				return node11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 11;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 5;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, node1, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10,
								node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10,
								node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10,
								node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10,
								node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10,
								node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10,
								node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10,
								node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node,
								node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node2,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node8, node9, node10, node11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node9, node10, node11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node10, node11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();
			result = prime * result + node11.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set5To11Node_IntKey_IntValue that = (Set5To11Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}
			if (!(node11.equals(that.node11))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;

		Set6To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To0Node_IntKey_IntValue that = (Set6To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;

		Set6To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To1Node_IntKey_IntValue that = (Set6To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set6To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To2Node_IntKey_IntValue that = (Set6To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set6To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To3Node_IntKey_IntValue that = (Set6To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set6To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To4Node_IntKey_IntValue that = (Set6To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set6To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To5Node_IntKey_IntValue that = (Set6To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set6To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To6Node_IntKey_IntValue that = (Set6To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set6To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To7Node_IntKey_IntValue that = (Set6To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set6To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To8Node_IntKey_IntValue that = (Set6To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set6To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node, node7, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node, node8, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To9Node_IntKey_IntValue that = (Set6To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set6To10Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;
		private final CompactSetNode node10;

		Set6To10Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7,
						final CompactSetNode node8, final CompactSetNode node9,
						final CompactSetNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			case 9:
				return node10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 10;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 6;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node,
								node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node2,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node7, node8, node9, node10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node8, node9, node10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node9, node10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();
			result = prime * result + node10.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set6To10Node_IntKey_IntValue that = (Set6To10Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}
			if (!(node10.equals(that.node10))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;

		Set7To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To0Node_IntKey_IntValue that = (Set7To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;

		Set7To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To1Node_IntKey_IntValue that = (Set7To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set7To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To2Node_IntKey_IntValue that = (Set7To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set7To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To3Node_IntKey_IntValue that = (Set7To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set7To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To4Node_IntKey_IntValue that = (Set7To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set7To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To5Node_IntKey_IntValue that = (Set7To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set7To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To6Node_IntKey_IntValue that = (Set7To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set7To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To7Node_IntKey_IntValue that = (Set7To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set7To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, node1, node2, node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node, node8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To8Node_IntKey_IntValue that = (Set7To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set7To9Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;
		private final CompactSetNode node9;

		Set7To9Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8,
						final CompactSetNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			case 8:
				return node9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 9;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 7;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, node1,
								node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node6, node7, node8, node9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node7, node8, node9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node8, node9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();
			result = prime * result + node9.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set7To9Node_IntKey_IntValue that = (Set7To9Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}
			if (!(node9.equals(that.node9))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;

		Set8To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To0Node_IntKey_IntValue that = (Set8To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;

		Set8To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To1Node_IntKey_IntValue that = (Set8To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set8To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To2Node_IntKey_IntValue that = (Set8To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set8To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To3Node_IntKey_IntValue that = (Set8To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set8To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To4Node_IntKey_IntValue that = (Set8To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set8To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To5Node_IntKey_IntValue that = (Set8To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set8To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To6Node_IntKey_IntValue that = (Set8To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set8To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To7Node_IntKey_IntValue that = (Set8To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set8To8Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;
		private final CompactSetNode node8;

		Set8To8Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6,
						final CompactSetNode node7, final CompactSetNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			case 7:
				return node8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 8;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 8;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								node1, node2, node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node5, node6, node7, node8);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node6, node7, node8);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node7, node8);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node8);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();
			result = prime * result + node8.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set8To8Node_IntKey_IntValue that = (Set8To8Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}
			if (!(node8.equals(that.node8))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;

		Set9To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To0Node_IntKey_IntValue that = (Set9To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;

		Set9To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To1Node_IntKey_IntValue that = (Set9To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set9To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To2Node_IntKey_IntValue that = (Set9To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set9To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To3Node_IntKey_IntValue that = (Set9To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set9To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To4Node_IntKey_IntValue that = (Set9To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set9To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To5Node_IntKey_IntValue that = (Set9To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set9To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To6Node_IntKey_IntValue that = (Set9To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set9To7Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;
		private final CompactSetNode node7;

		Set9To7Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3,
						final CompactSetNode node4, final CompactSetNode node5,
						final CompactSetNode node6, final CompactSetNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			case 6:
				return node7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 7;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 9;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node4, node5, node6, node7);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node5, node6, node7);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node6, node7);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node7);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();
			result = prime * result + node7.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set9To7Node_IntKey_IntValue that = (Set9To7Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}
			if (!(node7.equals(that.node7))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;

		Set10To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To0Node_IntKey_IntValue that = (Set10To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final CompactSetNode node1;

		Set10To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To1Node_IntKey_IntValue that = (Set10To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set10To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To2Node_IntKey_IntValue that = (Set10To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set10To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To3Node_IntKey_IntValue that = (Set10To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set10To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To4Node_IntKey_IntValue that = (Set10To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set10To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To5Node_IntKey_IntValue that = (Set10To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set10To6Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;
		private final CompactSetNode node6;

		Set10To6Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5, final CompactSetNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			case 5:
				return node6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 6;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 10;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node3, node4, node5, node6);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node4, node5, node6);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node5, node6);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node6);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();
			result = prime * result + node6.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set10To6Node_IntKey_IntValue that = (Set10To6Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}
			if (!(node6.equals(that.node6))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set11To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;

		Set11To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set11To0Node_IntKey_IntValue that = (Set11To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set11To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final CompactSetNode node1;

		Set11To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set11To1Node_IntKey_IntValue that = (Set11To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set11To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set11To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set11To2Node_IntKey_IntValue that = (Set11To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set11To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set11To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set11To3Node_IntKey_IntValue that = (Set11To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set11To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set11To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, node1, node2, node3, node4);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set11To4Node_IntKey_IntValue that = (Set11To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set11To5Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;
		private final CompactSetNode node5;

		Set11To5Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4,
						final CompactSetNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			case 4:
				return node5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 5;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 11;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node2, node3, node4, node5);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node3, node4, node5);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node4, node5);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node5);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();
			result = prime * result + node5.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set11To5Node_IntKey_IntValue that = (Set11To5Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}
			if (!(node5.equals(that.node5))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set12To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;

		Set12To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set12To0Node_IntKey_IntValue that = (Set12To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set12To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final CompactSetNode node1;

		Set12To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set12To1Node_IntKey_IntValue that = (Set12To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set12To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set12To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set12To2Node_IntKey_IntValue that = (Set12To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set12To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set12To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, node1, node2, node3);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set12To3Node_IntKey_IntValue that = (Set12To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set12To4Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;
		private final CompactSetNode node4;

		Set12To4Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final CompactSetNode node1, final CompactSetNode node2,
						final CompactSetNode node3, final CompactSetNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			case 3:
				return node4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 4;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 12;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, node1, node2, node3, node4);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, node1, node2, node3, node4);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, node1, node2, node3, node4);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, node1, node2, node3, node4);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node2, node3, node4);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node3, node4);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node4);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();
			result = prime * result + node4.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set12To4Node_IntKey_IntValue that = (Set12To4Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}
			if (!(node4.equals(that.node4))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set13To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;

		Set13To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, key13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, key13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, key13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, key13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, key13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, key13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, key13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, key13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, key13);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set13To0Node_IntKey_IntValue that = (Set13To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set13To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final CompactSetNode node1;

		Set13To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, key13, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, key13, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, key13, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, key13, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, key13, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, key13, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, key13, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set13To1Node_IntKey_IntValue that = (Set13To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set13To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set13To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final CompactSetNode node1,
						final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, key13, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, key13, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, key13, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, key13, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, key13, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, key13, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, key13, node1, node2);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set13To2Node_IntKey_IntValue that = (Set13To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set13To3Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final CompactSetNode node1;
		private final CompactSetNode node2;
		private final CompactSetNode node3;

		Set13To3Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final CompactSetNode node1,
						final CompactSetNode node2, final CompactSetNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			case 2:
				return node3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 3;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 13;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, node1, node2, node3);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, node1, node2, node3);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, node1, node2, node3);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, node1, node2, node3);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, node1, node2, node3);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node2, node3);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node3);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();
			result = prime * result + node3.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set13To3Node_IntKey_IntValue that = (Set13To3Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}
			if (!(node3.equals(that.node3))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set14To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final int key14;

		Set14To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final int key14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.key14 = key14;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 14;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, key13, key14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, key13, key14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, key13, key14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, key13, key14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, key13, key14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, key13, key14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, key13, key14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key, key14);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, key14);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, key14);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, key14);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, key14);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, key14);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, key14);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, key14);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, key14);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key14);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;
			result = prime * result + (int) key14;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set14To0Node_IntKey_IntValue that = (Set14To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set14To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final int key14;
		private final CompactSetNode node1;

		Set14To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final int key14,
						final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.key14 = key14;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 14;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, key13, key14, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, key13, key14, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, key13, key14, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, key13, key14, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, key13, key14, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, key13, key14, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, key13, key14, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key, key14, node1);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, key14, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, key14, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, key14, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, key14, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, key14, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, key14, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key14, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;
			result = prime * result + (int) key14;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set14To1Node_IntKey_IntValue that = (Set14To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set14To2Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final int key14;
		private final CompactSetNode node1;
		private final CompactSetNode node2;

		Set14To2Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final int key14,
						final CompactSetNode node1, final CompactSetNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.key14 = key14;
			this.node1 = node1;
			this.node2 = node2;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			case 1:
				return node2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 2;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 14;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, key14, node1, node2);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, key14, node1, node2);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, key14, node1, node2);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, key14, node1, node2);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, key14, node1, node2);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key14, node1, node2);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node2);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;
			result = prime * result + (int) key14;

			result = prime * result + node1.hashCode();
			result = prime * result + node2.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set14To2Node_IntKey_IntValue that = (Set14To2Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}
			if (!(node2.equals(that.node2))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set15To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final int key14;
		private final int key15;

		Set15To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final int key14, final int key15) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.key14 = key14;
			this.key15 = key15;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 15;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() | bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key, key1, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key, key2, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key, key3, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key, key4, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key, key5, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key, key6,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key,
								key7, key8, key9, key10, key11, key12, key13, key14, key15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key, key8, key9, key10, key11, key12, key13, key14, key15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key, key9, key10, key11, key12, key13, key14, key15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key, key10, key11, key12, key13, key14, key15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key, key11, key12, key13, key14, key15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key, key12, key13, key14, key15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key, key13, key14, key15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key, key14, key15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key, key15);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key15, key);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, key14, key15);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, key14, key15);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, key14, key15);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, key14, key15);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, key14, key15);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, key14, key15);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key14, key15);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key15);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() | bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;
			result = prime * result + (int) key14;
			result = prime * result + (int) key15;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set15To0Node_IntKey_IntValue that = (Set15To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(key15 == that.key15)) {
				return false;
			}

			return true;
		}

	}

	private static final class Set15To1Node_IntKey_IntValue extends CompactMixedSetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final int key14;
		private final int key15;
		private final CompactSetNode node1;

		Set15To1Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final int key14, final int key15,
						final CompactSetNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.key14 = key14;
			this.key15 = key15;
			this.node1 = node1;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return true;
		}

		@Override
		int nodeArity() {
			return 1;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 15;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, key14, key15, node1);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, key14, key15, node1);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, key14, key15, node1);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, key14, key15, node1);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, key14, key15, node1);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key14, key15, node1);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key15, node1);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			final int index = nodeIndex(bitpos);

			final short nodeMap = this.nodeMap();
			final short dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			final int idx = nodeIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap() ^ bitpos);
			final short dataMap = (short) (this.dataMap());

			switch (idx) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;
			result = prime * result + (int) key14;
			result = prime * result + (int) key15;

			result = prime * result + node1.hashCode();

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set15To1Node_IntKey_IntValue that = (Set15To1Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(key15 == that.key15)) {
				return false;
			}
			if (!(node1.equals(that.node1))) {
				return false;
			}

			return true;
		}

	}

	private static final class Set16To0Node_IntKey_IntValue extends CompactValuesOnlySetNode {

		private final int key1;
		private final int key2;
		private final int key3;
		private final int key4;
		private final int key5;
		private final int key6;
		private final int key7;
		private final int key8;
		private final int key9;
		private final int key10;
		private final int key11;
		private final int key12;
		private final int key13;
		private final int key14;
		private final int key15;
		private final int key16;

		Set16To0Node_IntKey_IntValue(final AtomicReference<Thread> mutator, final short nodeMap,
						final short dataMap, final int key1, final int key2, final int key3,
						final int key4, final int key5, final int key6, final int key7,
						final int key8, final int key9, final int key10, final int key11,
						final int key12, final int key13, final int key14, final int key15,
						final int key16) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.key2 = key2;
			this.key3 = key3;
			this.key4 = key4;
			this.key5 = key5;
			this.key6 = key6;
			this.key7 = key7;
			this.key8 = key8;
			this.key9 = key9;
			this.key10 = key10;
			this.key11 = key11;
			this.key12 = key12;
			this.key13 = key13;
			this.key14 = key14;
			this.key15 = key15;
			this.key16 = key16;

			assert nodeInvariant();
		}

		@Override
		CompactSetNode getNode(int index) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		int getKey(int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			case 15:
				return key16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return 16;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactSetNode copyAndInsertValue(AtomicReference<Thread> mutator, final short bitpos,
						final int key) {
			throw new IllegalStateException();
		}

		@Override
		CompactSetNode copyAndRemoveValue(AtomicReference<Thread> mutator, final short bitpos) {
			final int valIndex = dataIndex(bitpos);

			final short nodeMap = (short) (this.nodeMap());
			final short dataMap = (short) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf(mutator, nodeMap, dataMap, key2, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 1:
				return nodeOf(mutator, nodeMap, dataMap, key1, key3, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 2:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key4, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 3:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key5, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 4:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key6, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 5:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key7, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 6:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key8,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 7:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key9, key10, key11, key12, key13, key14, key15, key16);
			case 8:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key10, key11, key12, key13, key14, key15, key16);
			case 9:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key11, key12, key13, key14, key15, key16);
			case 10:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key12, key13, key14, key15, key16);
			case 11:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key13, key14, key15, key16);
			case 12:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key14, key15, key16);
			case 13:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key15, key16);
			case 14:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key16);
			case 15:
				return nodeOf(mutator, nodeMap, dataMap, key1, key2, key3, key4, key5, key6, key7,
								key8, key9, key10, key11, key12, key13, key14, key15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		@Override
		CompactSetNode copyAndSetNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndInsertNode(AtomicReference<Thread> mutator, final short bitpos,
						CompactSetNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		CompactSetNode copyAndRemoveNode(AtomicReference<Thread> mutator, final short bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;

			result = prime * result + ((int) nodeMap());
			result = prime * result + ((int) dataMap());

			result = prime * result + (int) key1;
			result = prime * result + (int) key2;
			result = prime * result + (int) key3;
			result = prime * result + (int) key4;
			result = prime * result + (int) key5;
			result = prime * result + (int) key6;
			result = prime * result + (int) key7;
			result = prime * result + (int) key8;
			result = prime * result + (int) key9;
			result = prime * result + (int) key10;
			result = prime * result + (int) key11;
			result = prime * result + (int) key12;
			result = prime * result + (int) key13;
			result = prime * result + (int) key14;
			result = prime * result + (int) key15;
			result = prime * result + (int) key16;

			return result;
		}

		@Override
		public boolean equals(Object other) {
			if (null == other) {
				return false;
			}
			if (this == other) {
				return true;
			}
			if (getClass() != other.getClass()) {
				return false;
			}
			Set16To0Node_IntKey_IntValue that = (Set16To0Node_IntKey_IntValue) other;

			if (nodeMap() != that.nodeMap()) {
				return false;
			}
			if (dataMap() != that.dataMap()) {
				return false;
			}

			if (!(key1 == that.key1)) {
				return false;
			}
			if (!(key2 == that.key2)) {
				return false;
			}
			if (!(key3 == that.key3)) {
				return false;
			}
			if (!(key4 == that.key4)) {
				return false;
			}
			if (!(key5 == that.key5)) {
				return false;
			}
			if (!(key6 == that.key6)) {
				return false;
			}
			if (!(key7 == that.key7)) {
				return false;
			}
			if (!(key8 == that.key8)) {
				return false;
			}
			if (!(key9 == that.key9)) {
				return false;
			}
			if (!(key10 == that.key10)) {
				return false;
			}
			if (!(key11 == that.key11)) {
				return false;
			}
			if (!(key12 == that.key12)) {
				return false;
			}
			if (!(key13 == that.key13)) {
				return false;
			}
			if (!(key14 == that.key14)) {
				return false;
			}
			if (!(key15 == that.key15)) {
				return false;
			}
			if (!(key16 == that.key16)) {
				return false;
			}

			return true;
		}

	}

}