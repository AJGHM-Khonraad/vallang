/*******************************************************************************
 * Copyright (c) 2013-2015 CWI
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *
 *   * Michael Steindorfer - Michael.Steindorfer@cwi.nl - CWI  
 *******************************************************************************/
package org.eclipse.imp.pdb.facts.util;

import static org.eclipse.imp.pdb.facts.util.AbstractSpecialisedImmutableMap.entryOf;

import java.text.DecimalFormat;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

@SuppressWarnings("rawtypes")
public class TrieMap_5Bits_Spec0To16_IntKey_IntValue implements
		ImmutableMap<java.lang.Integer, java.lang.Integer> {

	@SuppressWarnings("unchecked")
	private static final TrieMap_5Bits_Spec0To16_IntKey_IntValue EMPTY_MAP = new TrieMap_5Bits_Spec0To16_IntKey_IntValue(
			CompactMapNode.emptyTrieNodeConstant(), 0, 0);

	private static final boolean DEBUG = false;

	private final AbstractMapNode rootNode;
	private final int hashCode;
	private final int cachedSize;

	TrieMap_5Bits_Spec0To16_IntKey_IntValue(AbstractMapNode rootNode, int hashCode, int cachedSize) {
		this.rootNode = rootNode;
		this.hashCode = hashCode;
		this.cachedSize = cachedSize;
		if (DEBUG) {
			assert checkHashCodeAndSize(hashCode, cachedSize);
		}
	}

	@SuppressWarnings("unchecked")
	public static final ImmutableMap<java.lang.Integer, java.lang.Integer> of() {
		return TrieMap_5Bits_Spec0To16_IntKey_IntValue.EMPTY_MAP;
	}

	@SuppressWarnings("unchecked")
	public static final ImmutableMap<java.lang.Integer, java.lang.Integer> of(
			Object... keyValuePairs) {
		if (keyValuePairs.length % 2 != 0) {
			throw new IllegalArgumentException(
					"Length of argument list is uneven: no key/value pairs.");
		}

		ImmutableMap<java.lang.Integer, java.lang.Integer> result = TrieMap_5Bits_Spec0To16_IntKey_IntValue.EMPTY_MAP;

		for (int i = 0; i < keyValuePairs.length; i += 2) {
			final int key = (int) keyValuePairs[i];
			final int val = (int) keyValuePairs[i + 1];

			result = result.__put(key, val);
		}

		return result;
	}

	@SuppressWarnings("unchecked")
	public static final TransientMap<java.lang.Integer, java.lang.Integer> transientOf() {
		return TrieMap_5Bits_Spec0To16_IntKey_IntValue.EMPTY_MAP.asTransient();
	}

	@SuppressWarnings("unchecked")
	public static final TransientMap<java.lang.Integer, java.lang.Integer> transientOf(
			Object... keyValuePairs) {
		if (keyValuePairs.length % 2 != 0) {
			throw new IllegalArgumentException(
					"Length of argument list is uneven: no key/value pairs.");
		}

		final TransientMap<java.lang.Integer, java.lang.Integer> result = TrieMap_5Bits_Spec0To16_IntKey_IntValue.EMPTY_MAP
				.asTransient();

		for (int i = 0; i < keyValuePairs.length; i += 2) {
			final int key = (int) keyValuePairs[i];
			final int val = (int) keyValuePairs[i + 1];

			result.__put(key, val);
		}

		return result;
	}

	private boolean checkHashCodeAndSize(final int targetHash, final int targetSize) {
		int hash = 0;
		int size = 0;

		for (Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> it = entryIterator(); it
				.hasNext();) {
			final Map.Entry<java.lang.Integer, java.lang.Integer> entry = it.next();
			final int key = entry.getKey();
			final int val = entry.getValue();

			hash += (int) key ^ (int) val;
			size += 1;
		}

		return hash == targetHash && size == targetSize;
	}

	public static final int transformHashCode(final int hash) {
		return hash;
	}

	public boolean containsKey(final Object o) {
		try {
			@SuppressWarnings("unchecked")
			final int key = (int) o;
			return rootNode.containsKey(key, transformHashCode(key), 0);
		} catch (ClassCastException unused) {
			return false;
		}
	}

	public boolean containsKeyEquivalent(final Object o, final Comparator<Object> cmp) {
		try {
			@SuppressWarnings("unchecked")
			final int key = (int) o;
			return rootNode.containsKey(key, transformHashCode(key), 0, cmp);
		} catch (ClassCastException unused) {
			return false;
		}
	}

	public boolean containsValue(final Object o) {
		for (Iterator<java.lang.Integer> iterator = valueIterator(); iterator.hasNext();) {
			if (iterator.next().equals(o)) {
				return true;
			}
		}
		return false;
	}

	public boolean containsValueEquivalent(final Object o, final Comparator<Object> cmp) {
		for (Iterator<java.lang.Integer> iterator = valueIterator(); iterator.hasNext();) {
			if (cmp.compare(iterator.next(), o) == 0) {
				return true;
			}
		}
		return false;
	}

	public java.lang.Integer get(final Object o) {
		try {
			@SuppressWarnings("unchecked")
			final int key = (int) o;
			final Optional<java.lang.Integer> result = rootNode.findByKey(key,
					transformHashCode(key), 0);

			if (result.isPresent()) {
				return result.get();
			} else {
				return null;
			}
		} catch (ClassCastException unused) {
			return null;
		}
	}

	public java.lang.Integer getEquivalent(final Object o, final Comparator<Object> cmp) {
		try {
			@SuppressWarnings("unchecked")
			final int key = (int) o;
			final Optional<java.lang.Integer> result = rootNode.findByKey(key,
					transformHashCode(key), 0, cmp);

			if (result.isPresent()) {
				return result.get();
			} else {
				return null;
			}
		} catch (ClassCastException unused) {
			return null;
		}
	}

	public ImmutableMap<java.lang.Integer, java.lang.Integer> __put(final java.lang.Integer key,
			final java.lang.Integer val) {
		final int keyHash = key.hashCode();
		final MapResult details = MapResult.unchanged();

		final CompactMapNode newRootNode = rootNode.updated(null, key, val,
				transformHashCode(keyHash), 0, details);

		if (details.isModified()) {
			if (details.hasReplacedValue()) {
				final int valHashOld = (int) details.getReplacedValue();
				final int valHashNew = (int) val;

				return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(newRootNode, hashCode
						+ ((keyHash ^ valHashNew)) - ((keyHash ^ valHashOld)), cachedSize);
			}

			final int valHash = (int) val;
			return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(newRootNode, hashCode
					+ ((keyHash ^ valHash)), cachedSize + 1);
		}

		return this;
	}

	public ImmutableMap<java.lang.Integer, java.lang.Integer> __putEquivalent(
			final java.lang.Integer key, final java.lang.Integer val, final Comparator<Object> cmp) {
		final int keyHash = key.hashCode();
		final MapResult details = MapResult.unchanged();

		final CompactMapNode newRootNode = rootNode.updated(null, key, val,
				transformHashCode(keyHash), 0, details, cmp);

		if (details.isModified()) {
			if (details.hasReplacedValue()) {
				final int valHashOld = (int) details.getReplacedValue();
				final int valHashNew = (int) val;

				return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(newRootNode, hashCode
						+ ((keyHash ^ valHashNew)) - ((keyHash ^ valHashOld)), cachedSize);
			}

			final int valHash = (int) val;
			return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(newRootNode, hashCode
					+ ((keyHash ^ valHash)), cachedSize + 1);
		}

		return this;
	}

	public ImmutableMap<java.lang.Integer, java.lang.Integer> __putAll(
			final Map<? extends java.lang.Integer, ? extends java.lang.Integer> map) {
		final TransientMap<java.lang.Integer, java.lang.Integer> tmpTransient = this.asTransient();
		tmpTransient.__putAll(map);
		return tmpTransient.freeze();
	}

	public ImmutableMap<java.lang.Integer, java.lang.Integer> __putAllEquivalent(
			final Map<? extends java.lang.Integer, ? extends java.lang.Integer> map,
			final Comparator<Object> cmp) {
		final TransientMap<java.lang.Integer, java.lang.Integer> tmpTransient = this.asTransient();
		tmpTransient.__putAllEquivalent(map, cmp);
		return tmpTransient.freeze();
	}

	public ImmutableMap<java.lang.Integer, java.lang.Integer> __remove(final java.lang.Integer key) {
		final int keyHash = key.hashCode();
		final MapResult details = MapResult.unchanged();

		final CompactMapNode newRootNode = rootNode.removed(null, key, transformHashCode(keyHash),
				0, details);

		if (details.isModified()) {
			assert details.hasReplacedValue();
			final int valHash = (int) details.getReplacedValue();
			return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(newRootNode, hashCode
					- ((keyHash ^ valHash)), cachedSize - 1);
		}

		return this;
	}

	public ImmutableMap<java.lang.Integer, java.lang.Integer> __removeEquivalent(
			final java.lang.Integer key, final Comparator<Object> cmp) {
		final int keyHash = key.hashCode();
		final MapResult details = MapResult.unchanged();

		final CompactMapNode newRootNode = rootNode.removed(null, key, transformHashCode(keyHash),
				0, details, cmp);

		if (details.isModified()) {
			assert details.hasReplacedValue();
			final int valHash = (int) details.getReplacedValue();
			return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(newRootNode, hashCode
					- ((keyHash ^ valHash)), cachedSize - 1);
		}

		return this;
	}

	public java.lang.Integer put(final java.lang.Integer key, final java.lang.Integer val) {
		throw new UnsupportedOperationException();
	}

	public void putAll(final Map<? extends java.lang.Integer, ? extends java.lang.Integer> m) {
		throw new UnsupportedOperationException();
	}

	public void clear() {
		throw new UnsupportedOperationException();
	}

	public java.lang.Integer remove(final Object key) {
		throw new UnsupportedOperationException();
	}

	public int size() {
		return cachedSize;
	}

	public boolean isEmpty() {
		return cachedSize == 0;
	}

	public Iterator<java.lang.Integer> keyIterator() {
		return new MapKeyIterator(rootNode);
	}

	public Iterator<java.lang.Integer> valueIterator() {
		return new MapValueIterator(rootNode);
	}

	public Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> entryIterator() {
		return new MapEntryIterator(rootNode);
	}

	@Override
	public Set<java.lang.Integer> keySet() {
		Set<java.lang.Integer> keySet = null;

		if (keySet == null) {
			keySet = new AbstractSet<java.lang.Integer>() {
				@Override
				public Iterator<java.lang.Integer> iterator() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.keyIterator();
				}

				@Override
				public int size() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.size();
				}

				@Override
				public boolean isEmpty() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.isEmpty();
				}

				@Override
				public void clear() {
					TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.clear();
				}

				@Override
				public boolean contains(Object k) {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.containsKey(k);
				}
			};
		}

		return keySet;
	}

	@Override
	public Collection<java.lang.Integer> values() {
		Collection<java.lang.Integer> values = null;

		if (values == null) {
			values = new AbstractCollection<java.lang.Integer>() {
				@Override
				public Iterator<java.lang.Integer> iterator() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.valueIterator();
				}

				@Override
				public int size() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.size();
				}

				@Override
				public boolean isEmpty() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.isEmpty();
				}

				@Override
				public void clear() {
					TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.clear();
				}

				@Override
				public boolean contains(Object v) {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.containsValue(v);
				}
			};
		}

		return values;
	}

	@Override
	public Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet() {
		Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet = null;

		if (entrySet == null) {
			entrySet = new AbstractSet<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>>() {
				@Override
				public Iterator<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> iterator() {
					return new Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>>() {
						private final Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> i = entryIterator();

						@Override
						public boolean hasNext() {
							return i.hasNext();
						}

						@Override
						public Map.Entry<java.lang.Integer, java.lang.Integer> next() {
							return i.next();
						}

						@Override
						public void remove() {
							i.remove();
						}
					};
				}

				@Override
				public int size() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.size();
				}

				@Override
				public boolean isEmpty() {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.isEmpty();
				}

				@Override
				public void clear() {
					TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.clear();
				}

				@Override
				public boolean contains(Object k) {
					return TrieMap_5Bits_Spec0To16_IntKey_IntValue.this.containsKey(k);
				}
			};
		}

		return entrySet;
	}

	@Override
	public boolean equals(final Object other) {
		if (other == this) {
			return true;
		}
		if (other == null) {
			return false;
		}

		if (other instanceof Map) {
			Map that = (Map) other;

			if (this.size() != that.size())
				return false;

			for (@SuppressWarnings("unchecked")
			Iterator<Map.Entry> it = that.entrySet().iterator(); it.hasNext();) {
				Map.Entry entry = it.next();

				try {
					@SuppressWarnings("unchecked")
					final int key = (java.lang.Integer) entry.getKey();
					final Optional<java.lang.Integer> result = rootNode.findByKey(key,
							transformHashCode(key), 0);

					if (!result.isPresent()) {
						return false;
					} else {
						@SuppressWarnings("unchecked")
						final int val = (java.lang.Integer) entry.getValue();

						if (!result.get().equals(val)) {
							return false;
						}
					}
				} catch (ClassCastException unused) {
					return false;
				}
			}

			return true;
		}

		return false;
	}

	@Override
	public int hashCode() {
		return hashCode;
	}

	@Override
	public boolean isTransientSupported() {
		return true;
	}

	@Override
	public TransientMap<java.lang.Integer, java.lang.Integer> asTransient() {
		return new TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue(this);
	}

	/*
	 * For analysis purposes only.
	 */
	protected AbstractMapNode getRootNode() {
		return rootNode;
	}

	/*
	 * For analysis purposes only.
	 */
	protected Iterator<AbstractMapNode> nodeIterator() {
		return new TrieMap_5Bits_Spec0To16_IntKey_IntValueNodeIterator(rootNode);
	}

	/*
	 * For analysis purposes only.
	 */
	protected int getNodeCount() {
		final Iterator<AbstractMapNode> it = nodeIterator();
		int sumNodes = 0;

		for (; it.hasNext(); it.next()) {
			sumNodes += 1;
		}

		return sumNodes;
	}

	/*
	 * For analysis purposes only. Payload X Node
	 */
	protected int[][] arityCombinationsHistogram() {
		final Iterator<AbstractMapNode> it = nodeIterator();
		final int[][] sumArityCombinations = new int[33][33];

		while (it.hasNext()) {
			final AbstractMapNode node = it.next();
			sumArityCombinations[node.payloadArity()][node.nodeArity()] += 1;
		}

		return sumArityCombinations;
	}

	/*
	 * For analysis purposes only.
	 */
	protected int[] arityHistogram() {
		final int[][] sumArityCombinations = arityCombinationsHistogram();
		final int[] sumArity = new int[33];

		final int maxArity = 32; // TODO: factor out constant

		for (int j = 0; j <= maxArity; j++) {
			for (int maxRestArity = maxArity - j, k = 0; k <= maxRestArity - j; k++) {
				sumArity[j + k] += sumArityCombinations[j][k];
			}
		}

		return sumArity;
	}

	/*
	 * For analysis purposes only.
	 */
	public void printStatistics() {
		final int[][] sumArityCombinations = arityCombinationsHistogram();
		final int[] sumArity = arityHistogram();
		final int sumNodes = getNodeCount();

		final int[] cumsumArity = new int[33];
		for (int cumsum = 0, i = 0; i < 33; i++) {
			cumsum += sumArity[i];
			cumsumArity[i] = cumsum;
		}

		final float threshhold = 0.01f; // for printing results
		for (int i = 0; i < 33; i++) {
			float arityPercentage = (float) (sumArity[i]) / sumNodes;
			float cumsumArityPercentage = (float) (cumsumArity[i]) / sumNodes;

			if (arityPercentage != 0 && arityPercentage >= threshhold) {
				// details per level
				StringBuilder bldr = new StringBuilder();
				int max = i;
				for (int j = 0; j <= max; j++) {
					for (int k = max - j; k <= max - j; k++) {
						float arityCombinationsPercentage = (float) (sumArityCombinations[j][k])
								/ sumNodes;

						if (arityCombinationsPercentage != 0
								&& arityCombinationsPercentage >= threshhold) {
							bldr.append(String.format("%d/%d: %s, ", j, k, new DecimalFormat(
									"0.00%").format(arityCombinationsPercentage)));
						}
					}
				}
				final String detailPercentages = bldr.toString();

				// overview
				System.out.println(String.format("%2d: %s\t[cumsum = %s]\t%s", i,
						new DecimalFormat("0.00%").format(arityPercentage), new DecimalFormat(
								"0.00%").format(cumsumArityPercentage), detailPercentages));
			}
		}
	}

	abstract static class Optional<T> {
		private static final Optional EMPTY = new Optional() {
			@Override
			boolean isPresent() {
				return false;
			}

			@Override
			Object get() {
				return null;
			}
		};

		@SuppressWarnings("unchecked")
		static <T> Optional<T> empty() {
			return EMPTY;
		}

		static <T> Optional<T> of(T value) {
			return new Value<T>(value);
		}

		abstract boolean isPresent();

		abstract T get();

		private static final class Value<T> extends Optional<T> {
			private final T value;

			private Value(T value) {
				this.value = value;
			}

			@Override
			boolean isPresent() {
				return true;
			}

			@Override
			T get() {
				return value;
			}
		}
	}

	static final class MapResult {
		private int replacedValue;
		private boolean isModified;
		private boolean isReplaced;

		// update: inserted/removed single element, element count changed
		public void modified() {
			this.isModified = true;
		}

		public void updated(int replacedValue) {
			this.replacedValue = replacedValue;
			this.isModified = true;
			this.isReplaced = true;
		}

		// update: neither element, nor element count changed
		public static MapResult unchanged() {
			return new MapResult();
		}

		private MapResult() {
		}

		public boolean isModified() {
			return isModified;
		}

		public boolean hasReplacedValue() {
			return isReplaced;
		}

		public int getReplacedValue() {
			return replacedValue;
		}
	}

	protected static interface INode<K, V> {
	}

	protected static abstract class AbstractMapNode implements
			INode<java.lang.Integer, java.lang.Integer> {

		static final int TUPLE_LENGTH = 2;

		abstract boolean containsKey(final int key, final int keyHash, final int shift);

		abstract boolean containsKey(final int key, final int keyHash, final int shift,
				final Comparator<Object> cmp);

		abstract Optional<java.lang.Integer> findByKey(final int key, final int keyHash,
				final int shift);

		abstract Optional<java.lang.Integer> findByKey(final int key, final int keyHash,
				final int shift, final Comparator<Object> cmp);

		abstract CompactMapNode updated(final AtomicReference<Thread> mutator, final int key,
				final int val, final int keyHash, final int shift, final MapResult details);

		abstract CompactMapNode updated(final AtomicReference<Thread> mutator, final int key,
				final int val, final int keyHash, final int shift, final MapResult details,
				final Comparator<Object> cmp);

		abstract CompactMapNode removed(final AtomicReference<Thread> mutator, final int key,
				final int keyHash, final int shift, final MapResult details);

		abstract CompactMapNode removed(final AtomicReference<Thread> mutator, final int key,
				final int keyHash, final int shift, final MapResult details,
				final Comparator<Object> cmp);

		static final boolean isAllowedToEdit(AtomicReference<Thread> x, AtomicReference<Thread> y) {
			return x != null && y != null && (x == y || x.get() == y.get());
		}

		abstract boolean hasNodes();

		abstract int nodeArity();

		abstract AbstractMapNode getNode(final int index);

		@Deprecated
		Iterator<? extends AbstractMapNode> nodeIterator() {
			return new Iterator<AbstractMapNode>() {

				int nextIndex = 0;
				final int nodeArity = AbstractMapNode.this.nodeArity();

				@Override
				public void remove() {
					throw new UnsupportedOperationException();
				}

				@Override
				public AbstractMapNode next() {
					if (!hasNext())
						throw new NoSuchElementException();
					return AbstractMapNode.this.getNode(nextIndex++);
				}

				@Override
				public boolean hasNext() {
					return nextIndex < nodeArity;
				}
			};
		}

		abstract boolean hasPayload();

		abstract int payloadArity();

		abstract int getKey(final int index);

		abstract int getValue(final int index);

		abstract Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index);

		@Deprecated
		abstract boolean hasSlots();

		abstract int slotArity();

		abstract Object getSlot(final int index);

		/**
		 * The arity of this trie node (i.e. number of values and nodes stored
		 * on this level).
		 * 
		 * @return sum of nodes and values stored within
		 */

		int arity() {
			return payloadArity() + nodeArity();
		}

		int size() {
			final Iterator<java.lang.Integer> it = new MapKeyIterator(this);

			int size = 0;
			while (it.hasNext()) {
				size += 1;
				it.next();
			}

			return size;
		}
	}

	protected static abstract class CompactMapNode extends AbstractMapNode {

		static final int hashCodeLength() {
			return 32;
		}

		static final int bitPartitionSize() {
			return 5;
		}

		static final int bitPartitionMask() {
			return 0b11111;
		}

		static final int mask(final int keyHash, final int shift) {
			return (keyHash >>> shift) & bitPartitionMask();
		}

		static final int bitpos(final int mask) {
			return (int) (1 << mask);
		}

		abstract int nodeMap();

		abstract int dataMap();

		enum ContentType {
			KEY, VAL, RARE_KEY, RARE_VAL, NODE, SLOT
		}

		int logicalToPhysicalIndex(final ContentType type, final int index) {
			final int physicalIndex;

			switch (type) {
			case KEY:
				physicalIndex = TUPLE_LENGTH * index;
				break;
			case VAL:
				physicalIndex = TUPLE_LENGTH * index + 1;
				break;
			case RARE_KEY:
				physicalIndex = TUPLE_LENGTH * index + TUPLE_LENGTH
						* java.lang.Integer.bitCount(dataMap());
				break;
			case RARE_VAL:
				physicalIndex = TUPLE_LENGTH * index + TUPLE_LENGTH
						* java.lang.Integer.bitCount(dataMap()) + 1;
				break;
			case NODE:
				physicalIndex = slotArity() - 1 - index;
				break;
			case SLOT:
				physicalIndex = index;
				break;
			default:
				throw new IllegalStateException("Cases not exhausted?");
			}

			return physicalIndex;
		}

		static final byte SIZE_EMPTY = 0b00;
		static final byte SIZE_ONE = 0b01;
		static final byte SIZE_MORE_THAN_ONE = 0b10;

		/**
		 * Abstract predicate over a node's size. Value can be either
		 * {@value #SIZE_EMPTY}, {@value #SIZE_ONE}, or
		 * {@value #SIZE_MORE_THAN_ONE}.
		 * 
		 * @return size predicate
		 */
		abstract byte sizePredicate();

		boolean nodeInvariant() {
			boolean inv1 = (size() - payloadArity() >= 2 * (arity() - payloadArity()));
			boolean inv2 = (this.arity() == 0) ? sizePredicate() == SIZE_EMPTY : true;
			boolean inv3 = (this.arity() == 1 && payloadArity() == 1) ? sizePredicate() == SIZE_ONE
					: true;
			boolean inv4 = (this.arity() >= 2) ? sizePredicate() == SIZE_MORE_THAN_ONE : true;

			boolean inv5 = (this.nodeArity() >= 0) && (this.payloadArity() >= 0)
					&& ((this.payloadArity() + this.nodeArity()) == this.arity());

			return inv1 && inv2 && inv3 && inv4 && inv5;
		}

		@Override
		abstract CompactMapNode getNode(final int index);

		abstract CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator,
				final int bitpos, final int val);

		abstract CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator,
				final int bitpos, final int key, final int val);

		abstract CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator,
				final int bitpos);

		abstract CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node);

		abstract CompactMapNode copyAndMigrateFromInlineToNode(
				final AtomicReference<Thread> mutator, final int bitpos, final CompactMapNode node);

		abstract CompactMapNode copyAndMigrateFromNodeToInline(
				final AtomicReference<Thread> mutator, final int bitpos, final CompactMapNode node);

		CompactMapNode removeInplaceValueAndConvertToSpecializedNode(
				final AtomicReference<Thread> mutator, final int bitpos) {
			throw new UnsupportedOperationException();
		}

		static final CompactMapNode mergeTwoKeyValPairs(final int key0, final int val0,
				final int keyHash0, final int key1, final int val1, final int keyHash1,
				final int shift) {
			assert !(key0 == key1);

			if (shift >= hashCodeLength()) {
				// throw new
				// IllegalStateException("Hash collision not yet fixed.");
				return new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(keyHash0,
						(int[]) new int[] { key0, key1 }, (int[]) new int[] { val0, val1 });
			}

			final int mask0 = mask(keyHash0, shift);
			final int mask1 = mask(keyHash1, shift);

			if (mask0 != mask1) {
				// both nodes fit on same level
				final int dataMap = (int) (bitpos(mask0) | bitpos(mask1));

				if (mask0 < mask1) {
					return nodeOf(null, (int) 0, dataMap, key0, val0, key1, val1);
				} else {
					return nodeOf(null, (int) 0, dataMap, key1, val1, key0, val0);
				}
			} else {
				final CompactMapNode node = mergeTwoKeyValPairs(key0, val0, keyHash0, key1, val1,
						keyHash1, shift + bitPartitionSize());
				// values fit on next level

				final int nodeMap = bitpos(mask0);
				return nodeOf(null, nodeMap, (int) 0, node);
			}
		}

		static final CompactMapNode emptyTrieNodeConstant() {
			return EMPTY_NODE;
		}

		static final CompactMapNode EMPTY_NODE;

		static {

			EMPTY_NODE = new Map0To0Node_5Bits_Spec0To16_IntKey_IntValue(null, (int) 0, (int) 0);

		};

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final Object[] nodes) {
			return new BitmapIndexedMapNode(mutator, nodeMap, dataMap, nodes);
		}

		@SuppressWarnings("unchecked")
		static final CompactMapNode nodeOf(AtomicReference<Thread> mutator) {
			return EMPTY_NODE;
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap) {
			return EMPTY_NODE;
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1) {
			return new Map0To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map0To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map0To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map0To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map0To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map0To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map0To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map0To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map0To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return new Map0To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map0To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map0To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map0To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return new Map0To14Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13, node14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return new Map0To15Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13, node14, node15);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16) {
			return new Map0To16Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13, node14, node15, node16);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16, final CompactMapNode node17) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
					node15, node16, node17 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1) {
			return new Map1To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1) {
			return new Map1To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map1To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map1To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map1To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map1To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map1To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map1To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map1To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return new Map1To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return new Map1To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map1To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map1To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map1To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return new Map1To14Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return new Map1To15Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14, node15);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
					node13, node14, node15, node16 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2) {
			return new Map2To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1) {
			return new Map2To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map2To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map2To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map2To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map2To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map2To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map2To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map2To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map2To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return new Map2To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map2To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map2To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map2To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return new Map2To14Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13, node14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, node1,
					node2, node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
					node13, node14, node15 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3) {
			return new Map3To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1) {
			return new Map3To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map3To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map3To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map3To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map3To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map3To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map3To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map3To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
					node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return new Map3To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
					node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return new Map3To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map3To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map3To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map3To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
					node11, node12, node13, node14 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4) {
			return new Map4To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1) {
			return new Map4To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2) {
			return new Map4To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3) {
			return new Map4To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4) {
			return new Map4To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5) {
			return new Map4To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6) {
			return new Map4To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7) {
			return new Map4To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8) {
			return new Map4To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9) {
			return new Map4To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10) {
			return new Map4To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10, final CompactMapNode node11) {
			return new Map4To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10,
				final CompactMapNode node11, final CompactMapNode node12) {
			return new Map4To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10,
				final CompactMapNode node11, final CompactMapNode node12,
				final CompactMapNode node13) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5) {
			return new Map5To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1) {
			return new Map5To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map5To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map5To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map5To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map5To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map5To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map5To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map5To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map5To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return new Map5To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map5To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
					node8, node9, node10, node11, node12 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6) {
			return new Map6To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1) {
			return new Map6To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map6To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map6To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map6To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map6To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map6To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map6To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map6To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return new Map6To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return new Map6To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1,
					node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
					node6, node7, node8, node9, node10, node11 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7) {
			return new Map7To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1) {
			return new Map7To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map7To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map7To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map7To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map7To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map7To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map7To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map7To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map7To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
					node4, node5, node6, node7, node8, node9, node10 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8) {
			return new Map8To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1) {
			return new Map8To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map8To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map8To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map8To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map8To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map8To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map8To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map8To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
					node3, node4, node5, node6, node7, node8, node9 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9) {
			return new Map9To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1) {
			return new Map9To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2) {
			return new Map9To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3) {
			return new Map9To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4) {
			return new Map9To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5) {
			return new Map9To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6) {
			return new Map9To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7) {
			return new Map9To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					node1, node2, node3, node4, node5, node6, node7, node8 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10) {
			return new Map10To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1) {
			return new Map10To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map10To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map10To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map10To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map10To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map10To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3, node4, node5,
					node6);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, node1, node2, node3, node4, node5, node6, node7 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11) {
			return new Map11To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1) {
			return new Map11To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map11To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map11To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map11To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
					node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map11To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
					node4, node5);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, node1, node2, node3, node4, node5, node6 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12) {
			return new Map12To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1) {
			return new Map12To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map12To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
					node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map12To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
					node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map12To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
					node2, node3, node4);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, node1, node2, node3, node4, node5 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13) {
			return new Map13To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1) {
			return new Map13To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map13To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map13To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, node1, node2, node3);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3,
					node4 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14) {
			return new Map14To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1) {
			return new Map14To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map14To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, node1, node2);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1,
					node2, node3 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15) {
			return new Map15To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, key15, val15);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final CompactMapNode node1) {
			return new Map15To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, key15, val15, node1);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final CompactMapNode node1, final CompactMapNode node2) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, node1, node2 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16) {
			return new Map16To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, key15, val15, key16, val16);
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final CompactMapNode node1) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, node1 });
		}

		static final CompactMapNode nodeOf(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final int key17, final int val17) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, key17, val17 });
		}

		static final CompactMapNode nodeOf0x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap) {
			return EMPTY_NODE;
		}

		static final CompactMapNode nodeOf1x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1) {
			return new Map0To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, node1);
		}

		static final CompactMapNode nodeOf2x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map0To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2);
		}

		static final CompactMapNode nodeOf3x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map0To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map0To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map0To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map0To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map0To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map0To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map0To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return new Map0To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf11x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map0To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf12x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map0To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12);
		}

		static final CompactMapNode nodeOf13x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map0To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13);
		}

		static final CompactMapNode nodeOf14x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return new Map0To14Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13, node14);
		}

		static final CompactMapNode nodeOf15x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return new Map0To15Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13, node14, node15);
		}

		static final CompactMapNode nodeOf16x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16) {
			return new Map0To16Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
					node12, node13, node14, node15, node16);
		}

		static final CompactMapNode nodeOf17x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16, final CompactMapNode node17) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
					node15, node16, node17 });
		}

		static final CompactMapNode nodeOf18x0(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16, final CompactMapNode node17,
				final CompactMapNode node18) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
					node15, node16, node17, node18 });
		}

		static final CompactMapNode nodeOf0x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1) {
			return new Map1To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1);
		}

		static final CompactMapNode nodeOf1x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1) {
			return new Map1To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1);
		}

		static final CompactMapNode nodeOf2x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map1To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2);
		}

		static final CompactMapNode nodeOf3x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map1To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map1To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map1To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map1To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map1To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map1To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return new Map1To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return new Map1To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		static final CompactMapNode nodeOf11x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map1To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		static final CompactMapNode nodeOf12x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map1To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		static final CompactMapNode nodeOf13x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map1To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf14x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return new Map1To14Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14);
		}

		static final CompactMapNode nodeOf15x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return new Map1To15Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14, node15);
		}

		static final CompactMapNode nodeOf16x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
					node13, node14, node15, node16 });
		}

		static final CompactMapNode nodeOf17x1(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16, final CompactMapNode node17) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
					node13, node14, node15, node16, node17 });
		}

		static final CompactMapNode nodeOf0x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2) {
			return new Map2To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2);
		}

		static final CompactMapNode nodeOf1x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1) {
			return new Map2To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1);
		}

		static final CompactMapNode nodeOf2x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map2To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2);
		}

		static final CompactMapNode nodeOf3x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map2To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map2To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map2To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map2To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map2To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map2To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map2To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return new Map2To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10);
		}

		static final CompactMapNode nodeOf11x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map2To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11);
		}

		static final CompactMapNode nodeOf12x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map2To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf13x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map2To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf14x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return new Map2To14Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13, node14);
		}

		static final CompactMapNode nodeOf15x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, node1,
					node2, node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
					node13, node14, node15 });
		}

		static final CompactMapNode nodeOf16x2(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, node1,
					node2, node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
					node13, node14, node15, node16 });
		}

		static final CompactMapNode nodeOf0x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3) {
			return new Map3To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3);
		}

		static final CompactMapNode nodeOf1x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1) {
			return new Map3To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1);
		}

		static final CompactMapNode nodeOf2x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map3To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2);
		}

		static final CompactMapNode nodeOf3x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map3To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map3To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map3To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map3To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map3To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map3To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
					node8);
		}

		static final CompactMapNode nodeOf9x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return new Map3To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6, node7,
					node8, node9);
		}

		static final CompactMapNode nodeOf10x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return new Map3To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf11x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map3To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf12x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return new Map3To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf13x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return new Map3To13Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, node1, node2, node3, node4, node5, node6,
					node7, node8, node9, node10, node11, node12, node13);
		}

		static final CompactMapNode nodeOf14x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
					node11, node12, node13, node14 });
		}

		static final CompactMapNode nodeOf15x3(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
					node11, node12, node13, node14, node15 });
		}

		static final CompactMapNode nodeOf0x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4) {
			return new Map4To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4);
		}

		static final CompactMapNode nodeOf1x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1) {
			return new Map4To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1);
		}

		static final CompactMapNode nodeOf2x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2) {
			return new Map4To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2);
		}

		static final CompactMapNode nodeOf3x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3) {
			return new Map4To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4) {
			return new Map4To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5) {
			return new Map4To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6) {
			return new Map4To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6);
		}

		static final CompactMapNode nodeOf7x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7) {
			return new Map4To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6, node7);
		}

		static final CompactMapNode nodeOf8x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8) {
			return new Map4To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9) {
			return new Map4To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4, node5,
					node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10) {
			return new Map4To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf11x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10, final CompactMapNode node11) {
			return new Map4To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf12x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10,
				final CompactMapNode node11, final CompactMapNode node12) {
			return new Map4To12Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, node1, node2, node3, node4,
					node5, node6, node7, node8, node9, node10, node11, node12);
		}

		static final CompactMapNode nodeOf13x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10,
				final CompactMapNode node11, final CompactMapNode node12,
				final CompactMapNode node13) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13 });
		}

		static final CompactMapNode nodeOf14x4(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10,
				final CompactMapNode node11, final CompactMapNode node12,
				final CompactMapNode node13, final CompactMapNode node14) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
					node9, node10, node11, node12, node13, node14 });
		}

		static final CompactMapNode nodeOf0x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5) {
			return new Map5To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5);
		}

		static final CompactMapNode nodeOf1x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1) {
			return new Map5To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1);
		}

		static final CompactMapNode nodeOf2x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map5To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2);
		}

		static final CompactMapNode nodeOf3x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map5To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map5To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4);
		}

		static final CompactMapNode nodeOf5x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map5To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5);
		}

		static final CompactMapNode nodeOf6x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map5To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map5To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map5To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map5To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2, node3,
					node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return new Map5To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf11x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return new Map5To11Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10, node11);
		}

		static final CompactMapNode nodeOf12x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
					node8, node9, node10, node11, node12 });
		}

		static final CompactMapNode nodeOf13x5(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
					node8, node9, node10, node11, node12, node13 });
		}

		static final CompactMapNode nodeOf0x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6) {
			return new Map6To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6);
		}

		static final CompactMapNode nodeOf1x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1) {
			return new Map6To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1);
		}

		static final CompactMapNode nodeOf2x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map6To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2);
		}

		static final CompactMapNode nodeOf3x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map6To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3);
		}

		static final CompactMapNode nodeOf4x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map6To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4);
		}

		static final CompactMapNode nodeOf5x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map6To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map6To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map6To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map6To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return new Map6To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1, node2,
					node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return new Map6To10Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, node1,
					node2, node3, node4, node5, node6, node7, node8, node9, node10);
		}

		static final CompactMapNode nodeOf11x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
					node6, node7, node8, node9, node10, node11 });
		}

		static final CompactMapNode nodeOf12x6(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
					node6, node7, node8, node9, node10, node11, node12 });
		}

		static final CompactMapNode nodeOf0x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7) {
			return new Map7To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7);
		}

		static final CompactMapNode nodeOf1x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1) {
			return new Map7To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1);
		}

		static final CompactMapNode nodeOf2x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map7To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2);
		}

		static final CompactMapNode nodeOf3x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map7To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map7To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map7To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map7To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return new Map7To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return new Map7To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			return new Map7To9Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		static final CompactMapNode nodeOf10x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
					node4, node5, node6, node7, node8, node9, node10 });
		}

		static final CompactMapNode nodeOf11x7(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
					node4, node5, node6, node7, node8, node9, node10, node11 });
		}

		static final CompactMapNode nodeOf0x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8) {
			return new Map8To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8);
		}

		static final CompactMapNode nodeOf1x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1) {
			return new Map8To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1);
		}

		static final CompactMapNode nodeOf2x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map8To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2);
		}

		static final CompactMapNode nodeOf3x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map8To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map8To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map8To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return new Map8To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return new Map8To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			return new Map8To8Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, node1, node2, node3, node4, node5, node6, node7, node8);
		}

		static final CompactMapNode nodeOf9x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
					node3, node4, node5, node6, node7, node8, node9 });
		}

		static final CompactMapNode nodeOf10x8(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
					node3, node4, node5, node6, node7, node8, node9, node10 });
		}

		static final CompactMapNode nodeOf0x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9) {
			return new Map9To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9);
		}

		static final CompactMapNode nodeOf1x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1) {
			return new Map9To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1);
		}

		static final CompactMapNode nodeOf2x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2) {
			return new Map9To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2);
		}

		static final CompactMapNode nodeOf3x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3) {
			return new Map9To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4) {
			return new Map9To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5) {
			return new Map9To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6) {
			return new Map9To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4, node5, node6);
		}

		static final CompactMapNode nodeOf7x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7) {
			return new Map9To7Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap, key1,
					val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7, val7,
					key8, val8, key9, val9, node1, node2, node3, node4, node5, node6, node7);
		}

		static final CompactMapNode nodeOf8x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					node1, node2, node3, node4, node5, node6, node7, node8 });
		}

		static final CompactMapNode nodeOf9x9(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					node1, node2, node3, node4, node5, node6, node7, node8, node9 });
		}

		static final CompactMapNode nodeOf0x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10) {
			return new Map10To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10);
		}

		static final CompactMapNode nodeOf1x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1) {
			return new Map10To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1);
		}

		static final CompactMapNode nodeOf2x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map10To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2);
		}

		static final CompactMapNode nodeOf3x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map10To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map10To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return new Map10To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
		}

		static final CompactMapNode nodeOf6x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return new Map10To6Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, node1, node2, node3, node4, node5,
					node6);
		}

		static final CompactMapNode nodeOf7x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, node1, node2, node3, node4, node5, node6, node7 });
		}

		static final CompactMapNode nodeOf8x10(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, node1, node2, node3, node4, node5, node6, node7, node8 });
		}

		static final CompactMapNode nodeOf0x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11) {
			return new Map11To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11);
		}

		static final CompactMapNode nodeOf1x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1) {
			return new Map11To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1);
		}

		static final CompactMapNode nodeOf2x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map11To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2);
		}

		static final CompactMapNode nodeOf3x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map11To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return new Map11To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
					node4);
		}

		static final CompactMapNode nodeOf5x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return new Map11To5Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
					node4, node5);
		}

		static final CompactMapNode nodeOf6x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, node1, node2, node3, node4, node5, node6 });
		}

		static final CompactMapNode nodeOf7x11(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, node1, node2, node3, node4, node5, node6, node7 });
		}

		static final CompactMapNode nodeOf0x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12) {
			return new Map12To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12);
		}

		static final CompactMapNode nodeOf1x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1) {
			return new Map12To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
		}

		static final CompactMapNode nodeOf2x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map12To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
					node2);
		}

		static final CompactMapNode nodeOf3x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return new Map12To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
					node2, node3);
		}

		static final CompactMapNode nodeOf4x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return new Map12To4Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
					node2, node3, node4);
		}

		static final CompactMapNode nodeOf5x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, node1, node2, node3, node4, node5 });
		}

		static final CompactMapNode nodeOf6x12(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, node1, node2, node3, node4, node5,
					node6 });
		}

		static final CompactMapNode nodeOf0x13(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13) {
			return new Map13To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13);
		}

		static final CompactMapNode nodeOf1x13(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1) {
			return new Map13To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, node1);
		}

		static final CompactMapNode nodeOf2x13(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2) {
			return new Map13To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, node1, node2);
		}

		static final CompactMapNode nodeOf3x13(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return new Map13To3Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, node1, node2, node3);
		}

		static final CompactMapNode nodeOf4x13(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3,
					node4 });
		}

		static final CompactMapNode nodeOf5x13(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3,
					node4, node5 });
		}

		static final CompactMapNode nodeOf0x14(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14) {
			return new Map14To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14);
		}

		static final CompactMapNode nodeOf1x14(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1) {
			return new Map14To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, node1);
		}

		static final CompactMapNode nodeOf2x14(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1,
				final CompactMapNode node2) {
			return new Map14To2Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, node1, node2);
		}

		static final CompactMapNode nodeOf3x14(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1,
					node2, node3 });
		}

		static final CompactMapNode nodeOf4x14(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1,
					node2, node3, node4 });
		}

		static final CompactMapNode nodeOf0x15(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15) {
			return new Map15To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, key15, val15);
		}

		static final CompactMapNode nodeOf1x15(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final CompactMapNode node1) {
			return new Map15To1Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, key15, val15, node1);
		}

		static final CompactMapNode nodeOf2x15(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final CompactMapNode node1, final CompactMapNode node2) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, node1, node2 });
		}

		static final CompactMapNode nodeOf3x15(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, node1, node2, node3 });
		}

		static final CompactMapNode nodeOf0x16(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16) {
			return new Map16To0Node_5Bits_Spec0To16_IntKey_IntValue(mutator, nodeMap, dataMap,
					key1, val1, key2, val2, key3, val3, key4, val4, key5, val5, key6, val6, key7,
					val7, key8, val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
					val13, key14, val14, key15, val15, key16, val16);
		}

		static final CompactMapNode nodeOf1x16(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final CompactMapNode node1) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, node1 });
		}

		static final CompactMapNode nodeOf2x16(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final CompactMapNode node1,
				final CompactMapNode node2) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, node1, node2 });
		}

		static final CompactMapNode nodeOf0x17(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final int key17, final int val17) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, key17, val17 });
		}

		static final CompactMapNode nodeOf1x17(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final int key17, final int val17,
				final CompactMapNode node1) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, key17, val17, node1 });
		}

		static final CompactMapNode nodeOf0x18(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16, final int key17, final int val17,
				final int key18, final int val18) {
			return nodeOf(mutator, nodeMap, dataMap, new Object[] { key1, val1, key2, val2, key3,
					val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
					key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key15,
					val15, key16, val16, key17, val17, key18, val18 });
		}

		static final int index(final int bitmap, final int bitpos) {
			return java.lang.Integer.bitCount(bitmap & (bitpos - 1));
		}

		static final int index(final int bitmap, final int mask, final int bitpos) {
			return (bitmap == -1) ? mask : index(bitmap, bitpos);
		}

		int dataIndex(final int bitpos) {
			return java.lang.Integer.bitCount(dataMap() & (bitpos - 1));
		}

		int nodeIndex(final int bitpos) {
			return java.lang.Integer.bitCount(nodeMap() & (bitpos - 1));
		}

		CompactMapNode nodeAt(final int bitpos) {
			return getNode(nodeIndex(bitpos));
		}

		boolean containsKey(final int key, final int keyHash, final int shift) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			final int dataMap = dataMap();
			if ((dataMap & bitpos) != 0) {
				final int index = index(dataMap, mask, bitpos);
				return getKey(index) == key;
			}

			final int nodeMap = nodeMap();
			if ((nodeMap & bitpos) != 0) {
				final int index = index(nodeMap, mask, bitpos);
				return getNode(index).containsKey(key, keyHash, shift + bitPartitionSize());
			}

			return false;
		}

		boolean containsKey(final int key, final int keyHash, final int shift,
				final Comparator<Object> cmp) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			final int dataMap = dataMap();
			if ((dataMap & bitpos) != 0) {
				final int index = index(dataMap, mask, bitpos);
				return getKey(index) == key;
			}

			final int nodeMap = nodeMap();
			if ((nodeMap & bitpos) != 0) {
				final int index = index(nodeMap, mask, bitpos);
				return getNode(index).containsKey(key, keyHash, shift + bitPartitionSize(), cmp);
			}

			return false;
		}

		Optional<java.lang.Integer> findByKey(final int key, final int keyHash, final int shift) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int index = dataIndex(bitpos);
				if (getKey(index) == key) {
					final java.lang.Integer result = getValue(index);

					return Optional.of(result);
				}

				return Optional.empty();
			}

			if ((nodeMap() & bitpos) != 0) { // node (not value)
				final AbstractMapNode subNode = nodeAt(bitpos);

				return subNode.findByKey(key, keyHash, shift + bitPartitionSize());
			}

			return Optional.empty();
		}

		Optional<java.lang.Integer> findByKey(final int key, final int keyHash, final int shift,
				final Comparator<Object> cmp) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int index = dataIndex(bitpos);
				if (getKey(index) == key) {
					final java.lang.Integer result = getValue(index);

					return Optional.of(result);
				}

				return Optional.empty();
			}

			if ((nodeMap() & bitpos) != 0) { // node (not value)
				final AbstractMapNode subNode = nodeAt(bitpos);

				return subNode.findByKey(key, keyHash, shift + bitPartitionSize(), cmp);
			}

			return Optional.empty();
		}

		CompactMapNode updated(final AtomicReference<Thread> mutator, final int key, final int val,
				final int keyHash, final int shift, final MapResult details) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int dataIndex = dataIndex(bitpos);
				final int currentKey = getKey(dataIndex);

				if (currentKey == key) {
					final int currentVal = getValue(dataIndex);

					// update mapping
					details.updated(currentVal);
					return copyAndSetValue(mutator, bitpos, val);
				} else {
					final int currentVal = getValue(dataIndex);
					final CompactMapNode subNodeNew = mergeTwoKeyValPairs(currentKey, currentVal,
							transformHashCode(currentKey), key, val, keyHash, shift
									+ bitPartitionSize());

					details.modified();
					return copyAndMigrateFromInlineToNode(mutator, bitpos, subNodeNew);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);
				final CompactMapNode subNodeNew = subNode.updated(mutator, key, val, keyHash, shift
						+ bitPartitionSize(), details);

				if (details.isModified()) {
					return copyAndSetNode(mutator, bitpos, subNodeNew);
				} else {
					return this;
				}
			} else {
				// no value
				details.modified();
				return copyAndInsertValue(mutator, bitpos, key, val);
			}
		}

		CompactMapNode updated(final AtomicReference<Thread> mutator, final int key, final int val,
				final int keyHash, final int shift, final MapResult details,
				final Comparator<Object> cmp) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int dataIndex = dataIndex(bitpos);
				final int currentKey = getKey(dataIndex);

				if (currentKey == key) {
					final int currentVal = getValue(dataIndex);

					// update mapping
					details.updated(currentVal);
					return copyAndSetValue(mutator, bitpos, val);
				} else {
					final int currentVal = getValue(dataIndex);
					final CompactMapNode subNodeNew = mergeTwoKeyValPairs(currentKey, currentVal,
							transformHashCode(currentKey), key, val, keyHash, shift
									+ bitPartitionSize());

					details.modified();
					return copyAndMigrateFromInlineToNode(mutator, bitpos, subNodeNew);
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);
				final CompactMapNode subNodeNew = subNode.updated(mutator, key, val, keyHash, shift
						+ bitPartitionSize(), details, cmp);

				if (details.isModified()) {
					return copyAndSetNode(mutator, bitpos, subNodeNew);
				} else {
					return this;
				}
			} else {
				// no value
				details.modified();
				return copyAndInsertValue(mutator, bitpos, key, val);
			}
		}

		CompactMapNode removed(final AtomicReference<Thread> mutator, final int key,
				final int keyHash, final int shift, final MapResult details) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int dataIndex = dataIndex(bitpos);

				if (getKey(dataIndex) == key) {
					final int currentVal = getValue(dataIndex);
					details.updated(currentVal);

					if (this.payloadArity() == 2 && this.nodeArity() == 0) {
						/*
						 * Create new node with remaining pair. The new node
						 * will a) either become the new root returned, or b)
						 * unwrapped and inlined during returning.
						 */
						final int newDataMap = (shift == 0) ? (int) (dataMap() ^ bitpos)
								: bitpos(mask(keyHash, 0));

						if (dataIndex == 0) {
							return CompactMapNode.nodeOf(mutator, (int) 0, newDataMap, getKey(1),
									getValue(1));
						} else {
							return CompactMapNode.nodeOf(mutator, (int) 0, newDataMap, getKey(0),
									getValue(0));
						}
					} else if (this.arity() == 17) {
						return removeInplaceValueAndConvertToSpecializedNode(mutator, bitpos);
					} else {
						return copyAndRemoveValue(mutator, bitpos);
					}
				} else {
					return this;
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);
				final CompactMapNode subNodeNew = subNode.removed(mutator, key, keyHash, shift
						+ bitPartitionSize(), details);

				if (!details.isModified()) {
					return this;
				}

				switch (subNodeNew.sizePredicate()) {
				case 0: {
					throw new IllegalStateException("Sub-node must have at least one element.");
				}
				case 1: {
					// inline value (move to front)
					details.modified();
					return copyAndMigrateFromNodeToInline(mutator, bitpos, subNodeNew);
				}
				default: {
					// modify current node (set replacement node)
					return copyAndSetNode(mutator, bitpos, subNodeNew);
				}
				}
			}

			return this;
		}

		CompactMapNode removed(final AtomicReference<Thread> mutator, final int key,
				final int keyHash, final int shift, final MapResult details,
				final Comparator<Object> cmp) {
			final int mask = mask(keyHash, shift);
			final int bitpos = bitpos(mask);

			if ((dataMap() & bitpos) != 0) { // inplace value
				final int dataIndex = dataIndex(bitpos);

				if (getKey(dataIndex) == key) {
					final int currentVal = getValue(dataIndex);
					details.updated(currentVal);

					if (this.payloadArity() == 2 && this.nodeArity() == 0) {
						/*
						 * Create new node with remaining pair. The new node
						 * will a) either become the new root returned, or b)
						 * unwrapped and inlined during returning.
						 */
						final int newDataMap = (shift == 0) ? (int) (dataMap() ^ bitpos)
								: bitpos(mask(keyHash, 0));

						if (dataIndex == 0) {
							return CompactMapNode.nodeOf(mutator, (int) 0, newDataMap, getKey(1),
									getValue(1));
						} else {
							return CompactMapNode.nodeOf(mutator, (int) 0, newDataMap, getKey(0),
									getValue(0));
						}
					} else if (this.arity() == 17) {
						return removeInplaceValueAndConvertToSpecializedNode(mutator, bitpos);
					} else {
						return copyAndRemoveValue(mutator, bitpos);
					}
				} else {
					return this;
				}
			} else if ((nodeMap() & bitpos) != 0) { // node (not value)
				final CompactMapNode subNode = nodeAt(bitpos);
				final CompactMapNode subNodeNew = subNode.removed(mutator, key, keyHash, shift
						+ bitPartitionSize(), details, cmp);

				if (!details.isModified()) {
					return this;
				}

				switch (subNodeNew.sizePredicate()) {
				case 0: {
					throw new IllegalStateException("Sub-node must have at least one element.");
				}
				case 1: {
					// inline value (move to front)
					details.modified();
					return copyAndMigrateFromNodeToInline(mutator, bitpos, subNodeNew);
				}
				default: {
					// modify current node (set replacement node)
					return copyAndSetNode(mutator, bitpos, subNodeNew);
				}
				}
			}

			return this;
		}

		/**
		 * @return 0 <= mask <= 2^BIT_PARTITION_SIZE - 1
		 */
		static byte recoverMask(int map, byte i_th) {
			assert 1 <= i_th && i_th <= 32;

			byte cnt1 = 0;
			byte mask = 0;

			while (mask < 32) {
				if ((map & 0x01) == 0x01) {
					cnt1 += 1;

					if (cnt1 == i_th) {
						return mask;
					}
				}

				map = (int) (map >> 1);
				mask += 1;
			}

			assert cnt1 != i_th;
			throw new RuntimeException("Called with invalid arguments.");
		}

		@Override
		public String toString() {
			final StringBuilder bldr = new StringBuilder();
			bldr.append('[');

			for (byte i = 0; i < payloadArity(); i++) {
				final byte pos = recoverMask(dataMap(), (byte) (i + 1));
				bldr.append(String.format("@%d<#%d,#%d>", pos, Objects.hashCode(getKey(i)),
						Objects.hashCode(getValue(i))));

				if (!((i + 1) == payloadArity())) {
					bldr.append(", ");
				}
			}

			if (payloadArity() > 0 && nodeArity() > 0) {
				bldr.append(", ");
			}

			for (byte i = 0; i < nodeArity(); i++) {
				final byte pos = recoverMask(nodeMap(), (byte) (i + 1));
				bldr.append(String.format("@%d: %s", pos, getNode(i)));

				if (!((i + 1) == nodeArity())) {
					bldr.append(", ");
				}
			}

			bldr.append(']');
			return bldr.toString();
		}

	}

	protected static abstract class CompactMixedMapNode extends CompactMapNode {

		private final int nodeMap;
		private final int dataMap;

		CompactMixedMapNode(final AtomicReference<Thread> mutator, final int nodeMap,
				final int dataMap) {
			this.nodeMap = nodeMap;
			this.dataMap = dataMap;
		}

		@Override
		public int nodeMap() {
			return nodeMap;
		}

		@Override
		public int dataMap() {
			return dataMap;
		}

	}

	protected static abstract class CompactNodesOnlyMapNode extends CompactMapNode {

		private final int nodeMap;

		CompactNodesOnlyMapNode(final AtomicReference<Thread> mutator, final int nodeMap,
				final int dataMap) {
			this.nodeMap = nodeMap;
		}

		@Override
		public int nodeMap() {
			return nodeMap;
		}

		@Override
		public int dataMap() {
			return 0;
		}

	}

	protected static abstract class CompactValuesOnlyMapNode extends CompactMapNode {

		private final int dataMap;

		CompactValuesOnlyMapNode(final AtomicReference<Thread> mutator, final int nodeMap,
				final int dataMap) {
			this.dataMap = dataMap;
		}

		@Override
		public int nodeMap() {
			return 0;
		}

		@Override
		public int dataMap() {
			return dataMap;
		}

	}

	protected static abstract class CompactEmptyMapNode extends CompactMapNode {

		CompactEmptyMapNode(final AtomicReference<Thread> mutator, final int nodeMap,
				final int dataMap) {
		}

		@Override
		public int nodeMap() {
			return 0;
		}

		@Override
		public int dataMap() {
			return 0;
		}

	}

	static final class FeatureFlags {
		public static final long SUPPORTS_NOTHING = 0;
		public static final long SUPPORTS_NODES = 1 << 0;
		public static final long SUPPORTS_PAYLOAD = 1 << 1;
	}

	private static final class BitmapIndexedMapNode extends CompactMixedMapNode {

		final AtomicReference<Thread> mutator;
		final Object[] nodes;

		private BitmapIndexedMapNode(final AtomicReference<Thread> mutator, final int nodeMap,
				final int dataMap, final Object[] nodes) {
			super(mutator, nodeMap, dataMap);

			this.mutator = mutator;
			this.nodes = nodes;

			if (DEBUG) {

				assert (TUPLE_LENGTH * java.lang.Integer.bitCount(dataMap)
						+ java.lang.Integer.bitCount(nodeMap) == nodes.length);

				for (int i = 0; i < TUPLE_LENGTH * payloadArity(); i++) {
					assert ((nodes[i] instanceof CompactMapNode) == false);
				}
				for (int i = TUPLE_LENGTH * payloadArity(); i < nodes.length; i++) {
					assert ((nodes[i] instanceof CompactMapNode) == true);
				}
			}

			assert arity() > 16;
			assert nodeInvariant();
		}

		@Override
		int getKey(final int index) {
			return (int) nodes[TUPLE_LENGTH * index];
		}

		@Override
		int getValue(final int index) {
			return (int) nodes[TUPLE_LENGTH * index + 1];
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			return entryOf((int) nodes[TUPLE_LENGTH * index], (int) nodes[TUPLE_LENGTH * index + 1]);
		}

		@SuppressWarnings("unchecked")
		@Override
		CompactMapNode getNode(final int index) {
			return (CompactMapNode) nodes[nodes.length - 1 - index];
		}

		@SuppressWarnings("unchecked")
		@Override
		Iterator<? extends AbstractMapNode> nodeIterator() {
			final int length = nodeArity();
			final int offset = nodes.length - length;

			if (DEBUG) {
				for (int i = offset; i < offset + length; i++) {
					assert ((nodes[i] instanceof AbstractMapNode) == true);
				}
			}

			return (Iterator) ArrayIterator.of(nodes, offset, length);
		}

		@Override
		boolean hasPayload() {
			return dataMap() != 0;
		}

		@Override
		int payloadArity() {
			return java.lang.Integer.bitCount(dataMap());
		}

		@Override
		boolean hasNodes() {
			return nodeMap() != 0;
		}

		@Override
		int nodeArity() {
			return java.lang.Integer.bitCount(nodeMap());
		}

		@Override
		Object getSlot(final int index) {
			return nodes[index];
		}

		@Override
		boolean hasSlots() {
			return nodes.length != 0;
		}

		@Override
		int slotArity() {
			return nodes.length;
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = TUPLE_LENGTH * dataIndex(bitpos) + 1;

			if (isAllowedToEdit(this.mutator, mutator)) {
				// no copying if already editable
				this.nodes[idx] = val;
				return this;
			} else {
				final Object[] src = this.nodes;
				final Object[] dst = (Object[]) new Object[src.length];

				// copy 'src' and set 1 element(s) at position 'idx'
				System.arraycopy(src, 0, dst, 0, src.length);
				dst[idx + 0] = val;

				return nodeOf(mutator, nodeMap(), dataMap(), dst);
			}
		}

		@Override
		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {

			final int idx = this.nodes.length - 1 - nodeIndex(bitpos);

			if (isAllowedToEdit(this.mutator, mutator)) {
				// no copying if already editable
				this.nodes[idx] = node;
				return this;
			} else {
				final Object[] src = this.nodes;
				final Object[] dst = (Object[]) new Object[src.length];

				// copy 'src' and set 1 element(s) at position 'idx'
				System.arraycopy(src, 0, dst, 0, src.length);
				dst[idx + 0] = node;

				return nodeOf(mutator, nodeMap(), dataMap(), dst);
			}
		}

		@Override
		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = TUPLE_LENGTH * dataIndex(bitpos);

			final Object[] src = this.nodes;
			final Object[] dst = (Object[]) new Object[src.length + 2];

			// copy 'src' and insert 2 element(s) at position 'idx'
			System.arraycopy(src, 0, dst, 0, idx);
			dst[idx + 0] = key;
			dst[idx + 1] = val;
			System.arraycopy(src, idx, dst, idx + 2, src.length - idx);

			return nodeOf(mutator, nodeMap(), (int) (dataMap() | bitpos), dst);
		}

		@Override
		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int idx = TUPLE_LENGTH * dataIndex(bitpos);

			final Object[] src = this.nodes;
			final Object[] dst = (Object[]) new Object[src.length - 2];

			// copy 'src' and remove 2 element(s) at position 'idx'
			System.arraycopy(src, 0, dst, 0, idx);
			System.arraycopy(src, idx + 2, dst, idx, src.length - idx - 2);

			return nodeOf(mutator, nodeMap(), (int) (dataMap() ^ bitpos), dst);
		}

		@Override
		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {

			final int idxOld = TUPLE_LENGTH * dataIndex(bitpos);
			final int idxNew = this.nodes.length - TUPLE_LENGTH - nodeIndex(bitpos);

			final Object[] src = this.nodes;
			final Object[] dst = new Object[src.length - 2 + 1];

			// copy 'src' and remove 2 element(s) at position 'idxOld' and
			// insert 1 element(s) at position 'idxNew' (TODO: carefully test)
			assert idxOld <= idxNew;
			System.arraycopy(src, 0, dst, 0, idxOld);
			System.arraycopy(src, idxOld + 2, dst, idxOld, idxNew - idxOld);
			dst[idxNew + 0] = node;
			System.arraycopy(src, idxNew + 2, dst, idxNew + 1, src.length - idxNew - 2);

			return nodeOf(mutator, (int) (nodeMap() | bitpos), (int) (dataMap() ^ bitpos), dst);
		}

		@Override
		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {

			final int idxOld = this.nodes.length - 1 - nodeIndex(bitpos);
			final int idxNew = TUPLE_LENGTH * dataIndex(bitpos);

			final Object[] src = this.nodes;
			final Object[] dst = new Object[src.length - 1 + 2];

			// copy 'src' and remove 1 element(s) at position 'idxOld' and
			// insert 2 element(s) at position 'idxNew' (TODO: carefully test)
			assert idxOld >= idxNew;
			System.arraycopy(src, 0, dst, 0, idxNew);
			dst[idxNew + 0] = node.getKey(0);
			dst[idxNew + 1] = node.getValue(0);
			System.arraycopy(src, idxNew, dst, idxNew + 2, idxOld - idxNew);
			System.arraycopy(src, idxOld + 1, dst, idxOld + 2, src.length - idxOld - 1);

			return nodeOf(mutator, (int) (nodeMap() ^ bitpos), (int) (dataMap() | bitpos), dst);
		}

		@Override
		CompactMapNode removeInplaceValueAndConvertToSpecializedNode(
				final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (payloadArity()) { // 0 <= payloadArity <= 17 // or ts.nMax
			case 1: {

				switch (valIndex) {
				case 0: {

					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);
				final CompactMapNode node11 = getNode(10);
				final CompactMapNode node12 = getNode(11);
				final CompactMapNode node13 = getNode(12);
				final CompactMapNode node14 = getNode(13);
				final CompactMapNode node15 = getNode(14);
				final CompactMapNode node16 = getNode(15);

				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);

			}
			case 2: {
				int key1;
				int val1;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);
				final CompactMapNode node11 = getNode(10);
				final CompactMapNode node12 = getNode(11);
				final CompactMapNode node13 = getNode(12);
				final CompactMapNode node14 = getNode(13);
				final CompactMapNode node15 = getNode(14);

				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13,
						node14, node15);

			}
			case 3: {
				int key1;
				int val1;
				int key2;
				int val2;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);
				final CompactMapNode node11 = getNode(10);
				final CompactMapNode node12 = getNode(11);
				final CompactMapNode node13 = getNode(12);
				final CompactMapNode node14 = getNode(13);

				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);

			}
			case 4: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);
				final CompactMapNode node11 = getNode(10);
				final CompactMapNode node12 = getNode(11);
				final CompactMapNode node13 = getNode(12);

				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);

			}
			case 5: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);
				final CompactMapNode node11 = getNode(10);
				final CompactMapNode node12 = getNode(11);

				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);

			}
			case 6: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);
				final CompactMapNode node11 = getNode(10);

				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);

			}
			case 7: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);
				final CompactMapNode node10 = getNode(9);

				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);

			}
			case 8: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);
				final CompactMapNode node9 = getNode(8);

				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);

			}
			case 9: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);
				final CompactMapNode node8 = getNode(7);

				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);

			}
			case 10: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);
				final CompactMapNode node7 = getNode(6);

				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);

			}
			case 11: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);
				final CompactMapNode node6 = getNode(5);

				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);

			}
			case 12: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;
				int key11;
				int val11;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(11);
					val11 = getValue(11);
					break;
				}
				case 11: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);
				final CompactMapNode node5 = getNode(4);

				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);

			}
			case 13: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;
				int key11;
				int val11;
				int key12;
				int val12;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 11: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(12);
					val12 = getValue(12);
					break;
				}
				case 12: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);
				final CompactMapNode node4 = getNode(3);

				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);

			}
			case 14: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;
				int key11;
				int val11;
				int key12;
				int val12;
				int key13;
				int val13;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 11: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 12: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(13);
					val13 = getValue(13);
					break;
				}
				case 13: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);
				final CompactMapNode node3 = getNode(2);

				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);

			}
			case 15: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;
				int key11;
				int val11;
				int key12;
				int val12;
				int key13;
				int val13;
				int key14;
				int val14;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 11: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 12: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 13: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(14);
					val14 = getValue(14);
					break;
				}
				case 14: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(13);
					val14 = getValue(13);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);
				final CompactMapNode node2 = getNode(1);

				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);

			}
			case 16: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;
				int key11;
				int val11;
				int key12;
				int val12;
				int key13;
				int val13;
				int key14;
				int val14;
				int key15;
				int val15;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 11: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 12: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 13: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 14: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(13);
					val14 = getValue(13);
					key15 = getKey(15);
					val15 = getValue(15);
					break;
				}
				case 15: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(13);
					val14 = getValue(13);
					key15 = getKey(14);
					val15 = getValue(14);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				final CompactMapNode node1 = getNode(0);

				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);

			}
			case 17: {
				int key1;
				int val1;
				int key2;
				int val2;
				int key3;
				int val3;
				int key4;
				int val4;
				int key5;
				int val5;
				int key6;
				int val6;
				int key7;
				int val7;
				int key8;
				int val8;
				int key9;
				int val9;
				int key10;
				int val10;
				int key11;
				int val11;
				int key12;
				int val12;
				int key13;
				int val13;
				int key14;
				int val14;
				int key15;
				int val15;
				int key16;
				int val16;

				switch (valIndex) {
				case 0: {

					key1 = getKey(1);
					val1 = getValue(1);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 1: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(2);
					val2 = getValue(2);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 2: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(3);
					val3 = getValue(3);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 3: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(4);
					val4 = getValue(4);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 4: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(5);
					val5 = getValue(5);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 5: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(6);
					val6 = getValue(6);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 6: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(7);
					val7 = getValue(7);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 7: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(8);
					val8 = getValue(8);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 8: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(9);
					val9 = getValue(9);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 9: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(10);
					val10 = getValue(10);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 10: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(11);
					val11 = getValue(11);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 11: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(12);
					val12 = getValue(12);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 12: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(13);
					val13 = getValue(13);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 13: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(14);
					val14 = getValue(14);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 14: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(13);
					val14 = getValue(13);
					key15 = getKey(15);
					val15 = getValue(15);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 15: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(13);
					val14 = getValue(13);
					key15 = getKey(14);
					val15 = getValue(14);
					key16 = getKey(16);
					val16 = getValue(16);
					break;
				}
				case 16: {

					key1 = getKey(0);
					val1 = getValue(0);
					key2 = getKey(1);
					val2 = getValue(1);
					key3 = getKey(2);
					val3 = getValue(2);
					key4 = getKey(3);
					val4 = getValue(3);
					key5 = getKey(4);
					val5 = getValue(4);
					key6 = getKey(5);
					val6 = getValue(5);
					key7 = getKey(6);
					val7 = getValue(6);
					key8 = getKey(7);
					val8 = getValue(7);
					key9 = getKey(8);
					val9 = getValue(8);
					key10 = getKey(9);
					val10 = getValue(9);
					key11 = getKey(10);
					val11 = getValue(10);
					key12 = getKey(11);
					val12 = getValue(11);
					key13 = getKey(12);
					val13 = getValue(12);
					key14 = getKey(13);
					val14 = getValue(13);
					key15 = getKey(14);
					val15 = getValue(14);
					key16 = getKey(15);
					val16 = getValue(15);
					break;
				}
				default:
					throw new IllegalStateException("Index out of range.");
				}

				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);

			}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}
	}

	private static final class HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMapNode {
		private final int[] keys;
		private final int[] vals;
		private final int hash;

		HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(final int hash, final int[] keys,
				final int[] vals) {
			this.keys = keys;
			this.vals = vals;
			this.hash = hash;

			assert payloadArity() >= 2;
		}

		boolean containsKey(final int key, final int keyHash, final int shift) {
			if (this.hash == keyHash) {
				for (int k : keys) {
					if (k == key) {
						return true;
					}
				}
			}
			return false;
		}

		boolean containsKey(final int key, final int keyHash, final int shift,
				final Comparator<Object> cmp) {
			if (this.hash == keyHash) {
				for (int k : keys) {
					if (k == key) {
						return true;
					}
				}
			}
			return false;
		}

		Optional<java.lang.Integer> findByKey(final int key, final int keyHash, final int shift) {
			for (int i = 0; i < keys.length; i++) {
				final int _key = keys[i];
				if (key == _key) {
					final int val = vals[i];
					return Optional.of(val);
				}
			}
			return Optional.empty();
		}

		Optional<java.lang.Integer> findByKey(final int key, final int keyHash, final int shift,
				final Comparator<Object> cmp) {
			for (int i = 0; i < keys.length; i++) {
				final int _key = keys[i];
				if (key == _key) {
					final int val = vals[i];
					return Optional.of(val);
				}
			}
			return Optional.empty();
		}

		CompactMapNode updated(final AtomicReference<Thread> mutator, final int key, final int val,
				final int keyHash, final int shift, final MapResult details) {
			assert this.hash == keyHash;

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					final int currentVal = vals[idx];

					if (currentVal == val) {
						return this;
					} else {
						// add new mapping
						final int[] src = this.vals;
						final int[] dst = new int[src.length];

						// copy 'src' and set 1 element(s) at position 'idx'
						System.arraycopy(src, 0, dst, 0, src.length);
						dst[idx + 0] = val;

						final CompactMapNode thisNew = new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(
								this.hash, this.keys, dst);

						details.updated(currentVal);
						return thisNew;
					}
				}
			}

			final int[] keysNew = new int[this.keys.length + 1];

			// copy 'this.keys' and insert 1 element(s) at position
			// 'keys.length'
			System.arraycopy(this.keys, 0, keysNew, 0, keys.length);
			keysNew[keys.length + 0] = key;
			System.arraycopy(this.keys, keys.length, keysNew, keys.length + 1, this.keys.length
					- keys.length);

			final int[] valsNew = new int[this.vals.length + 1];

			// copy 'this.vals' and insert 1 element(s) at position
			// 'vals.length'
			System.arraycopy(this.vals, 0, valsNew, 0, vals.length);
			valsNew[vals.length + 0] = val;
			System.arraycopy(this.vals, vals.length, valsNew, vals.length + 1, this.vals.length
					- vals.length);

			details.modified();
			return new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(keyHash, keysNew,
					valsNew);
		}

		CompactMapNode updated(final AtomicReference<Thread> mutator, final int key, final int val,
				final int keyHash, final int shift, final MapResult details,
				final Comparator<Object> cmp) {
			assert this.hash == keyHash;

			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					final int currentVal = vals[idx];

					if (currentVal == val) {
						return this;
					} else {
						// add new mapping
						final int[] src = this.vals;
						final int[] dst = new int[src.length];

						// copy 'src' and set 1 element(s) at position 'idx'
						System.arraycopy(src, 0, dst, 0, src.length);
						dst[idx + 0] = val;

						final CompactMapNode thisNew = new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(
								this.hash, this.keys, dst);

						details.updated(currentVal);
						return thisNew;
					}
				}
			}

			final int[] keysNew = new int[this.keys.length + 1];

			// copy 'this.keys' and insert 1 element(s) at position
			// 'keys.length'
			System.arraycopy(this.keys, 0, keysNew, 0, keys.length);
			keysNew[keys.length + 0] = key;
			System.arraycopy(this.keys, keys.length, keysNew, keys.length + 1, this.keys.length
					- keys.length);

			final int[] valsNew = new int[this.vals.length + 1];

			// copy 'this.vals' and insert 1 element(s) at position
			// 'vals.length'
			System.arraycopy(this.vals, 0, valsNew, 0, vals.length);
			valsNew[vals.length + 0] = val;
			System.arraycopy(this.vals, vals.length, valsNew, vals.length + 1, this.vals.length
					- vals.length);

			details.modified();
			return new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(keyHash, keysNew,
					valsNew);
		}

		CompactMapNode removed(final AtomicReference<Thread> mutator, final int key,
				final int keyHash, final int shift, final MapResult details) {
			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					final int currentVal = vals[idx];
					details.updated(currentVal);

					if (this.arity() == 1) {
						return nodeOf(mutator);
					} else if (this.arity() == 2) {
						/*
						 * Create root node with singleton element. This node
						 * will be a) either be the new root returned, or b)
						 * unwrapped and inlined.
						 */
						final int theOtherKey = (idx == 0) ? keys[1] : keys[0];
						final int theOtherVal = (idx == 0) ? vals[1] : vals[0];
						return CompactMapNode.nodeOf(mutator).updated(mutator, theOtherKey,
								theOtherVal, keyHash, 0, details);
					} else {
						final int[] keysNew = new int[this.keys.length - 1];

						// copy 'this.keys' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.keys, 0, keysNew, 0, idx);
						System.arraycopy(this.keys, idx + 1, keysNew, idx, this.keys.length - idx
								- 1);

						final int[] valsNew = new int[this.vals.length - 1];

						// copy 'this.vals' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.vals, 0, valsNew, 0, idx);
						System.arraycopy(this.vals, idx + 1, valsNew, idx, this.vals.length - idx
								- 1);

						return new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(keyHash,
								keysNew, valsNew);
					}
				}
			}
			return this;
		}

		CompactMapNode removed(final AtomicReference<Thread> mutator, final int key,
				final int keyHash, final int shift, final MapResult details,
				final Comparator<Object> cmp) {
			for (int idx = 0; idx < keys.length; idx++) {
				if (keys[idx] == key) {
					final int currentVal = vals[idx];
					details.updated(currentVal);

					if (this.arity() == 1) {
						return nodeOf(mutator);
					} else if (this.arity() == 2) {
						/*
						 * Create root node with singleton element. This node
						 * will be a) either be the new root returned, or b)
						 * unwrapped and inlined.
						 */
						final int theOtherKey = (idx == 0) ? keys[1] : keys[0];
						final int theOtherVal = (idx == 0) ? vals[1] : vals[0];
						return CompactMapNode.nodeOf(mutator).updated(mutator, theOtherKey,
								theOtherVal, keyHash, 0, details, cmp);
					} else {
						final int[] keysNew = new int[this.keys.length - 1];

						// copy 'this.keys' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.keys, 0, keysNew, 0, idx);
						System.arraycopy(this.keys, idx + 1, keysNew, idx, this.keys.length - idx
								- 1);

						final int[] valsNew = new int[this.vals.length - 1];

						// copy 'this.vals' and remove 1 element(s) at position
						// 'idx'
						System.arraycopy(this.vals, 0, valsNew, 0, idx);
						System.arraycopy(this.vals, idx + 1, valsNew, idx, this.vals.length - idx
								- 1);

						return new HashCollisionMapNode_5Bits_Spec0To16_IntKey_IntValue(keyHash,
								keysNew, valsNew);
					}
				}
			}
			return this;
		}

		@Override
		boolean hasPayload() {
			return true;
		}

		@Override
		int payloadArity() {
			return keys.length;
		}

		@Override
		boolean hasNodes() {
			return false;
		}

		@Override
		int nodeArity() {
			return 0;
		}

		@Override
		int arity() {
			return payloadArity();
		}

		@Override
		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		@Override
		int getKey(final int index) {
			return keys[index];
		}

		@Override
		int getValue(final int index) {
			return vals[index];
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			return entryOf(keys[index], vals[index]);
		}

		@Override
		public CompactMapNode getNode(int index) {
			throw new IllegalStateException("Is leaf node.");
		}

		@Override
		Object getSlot(final int index) {
			throw new UnsupportedOperationException();
		}

		@Override
		boolean hasSlots() {
			throw new UnsupportedOperationException();
		}

		@Override
		int slotArity() {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new UnsupportedOperationException();
		}

		@Override
		CompactMapNode removeInplaceValueAndConvertToSpecializedNode(
				final AtomicReference<Thread> mutator, final int bitpos) {
			throw new UnsupportedOperationException();
		}

		@Override
		int nodeMap() {
			throw new UnsupportedOperationException();
		}

		@Override
		int dataMap() {
			throw new UnsupportedOperationException();
		}

	}

	/**
	 * Iterator skeleton that uses a fixed stack in depth.
	 */
	private static abstract class AbstractMapIterator {

		private static final int MAX_DEPTH = 7;

		protected int currentValueCursor;
		protected int currentValueLength;
		protected AbstractMapNode currentValueNode;

		private int currentStackLevel = -1;
		private final int[] nodeCursorsAndLengths = new int[MAX_DEPTH * 2];

		@SuppressWarnings("unchecked")
		AbstractMapNode[] nodes = new AbstractMapNode[MAX_DEPTH];

		AbstractMapIterator(AbstractMapNode rootNode) {
			if (rootNode.hasNodes()) {
				currentStackLevel = 0;

				nodes[0] = rootNode;
				nodeCursorsAndLengths[0] = 0;
				nodeCursorsAndLengths[1] = rootNode.nodeArity();
			}

			if (rootNode.hasPayload()) {
				currentValueNode = rootNode;
				currentValueCursor = 0;
				currentValueLength = rootNode.payloadArity();
			}
		}

		/*
		 * search for next node that contains values
		 */
		private boolean searchNextValueNode() {
			while (currentStackLevel >= 0) {
				final int currentCursorIndex = currentStackLevel * 2;
				final int currentLengthIndex = currentCursorIndex + 1;

				final int nodeCursor = nodeCursorsAndLengths[currentCursorIndex];
				final int nodeLength = nodeCursorsAndLengths[currentLengthIndex];

				if (nodeCursor < nodeLength) {
					final AbstractMapNode nextNode = nodes[currentStackLevel].getNode(nodeCursor);
					nodeCursorsAndLengths[currentCursorIndex]++;

					if (nextNode.hasNodes()) {
						/*
						 * put node on next stack level for depth-first
						 * traversal
						 */
						final int nextStackLevel = ++currentStackLevel;
						final int nextCursorIndex = nextStackLevel * 2;
						final int nextLengthIndex = nextCursorIndex + 1;

						nodes[nextStackLevel] = nextNode;
						nodeCursorsAndLengths[nextCursorIndex] = 0;
						nodeCursorsAndLengths[nextLengthIndex] = nextNode.nodeArity();
					}

					if (nextNode.hasPayload()) {
						/*
						 * found next node that contains values
						 */
						currentValueNode = nextNode;
						currentValueCursor = 0;
						currentValueLength = nextNode.payloadArity();
						return true;
					}
				} else {
					currentStackLevel--;
				}
			}

			return false;
		}

		public boolean hasNext() {
			if (currentValueCursor < currentValueLength) {
				return true;
			} else {
				return searchNextValueNode();
			}
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}
	}

	protected static class MapKeyIterator extends AbstractMapIterator implements
			Iterator<java.lang.Integer> {

		MapKeyIterator(AbstractMapNode rootNode) {
			super(rootNode);
		}

		@Override
		public java.lang.Integer next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getKey(currentValueCursor++);
			}
		}

	}

	protected static class MapValueIterator extends AbstractMapIterator implements
			Iterator<java.lang.Integer> {

		MapValueIterator(AbstractMapNode rootNode) {
			super(rootNode);
		}

		@Override
		public java.lang.Integer next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getValue(currentValueCursor++);
			}
		}

	}

	protected static class MapEntryIterator extends AbstractMapIterator implements
			Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> {

		MapEntryIterator(AbstractMapNode rootNode) {
			super(rootNode);
		}

		@Override
		public Map.Entry<java.lang.Integer, java.lang.Integer> next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			} else {
				return currentValueNode.getKeyValueEntry(currentValueCursor++);
			}
		}

	}

	/**
	 * Iterator that first iterates over inlined-values and then continues depth
	 * first recursively.
	 */
	private static class TrieMap_5Bits_Spec0To16_IntKey_IntValueNodeIterator implements
			Iterator<AbstractMapNode> {

		final Deque<Iterator<? extends AbstractMapNode>> nodeIteratorStack;

		TrieMap_5Bits_Spec0To16_IntKey_IntValueNodeIterator(AbstractMapNode rootNode) {
			nodeIteratorStack = new ArrayDeque<>();
			nodeIteratorStack.push(Collections.singleton(rootNode).iterator());
		}

		@Override
		public boolean hasNext() {
			while (true) {
				if (nodeIteratorStack.isEmpty()) {
					return false;
				} else {
					if (nodeIteratorStack.peek().hasNext()) {
						return true;
					} else {
						nodeIteratorStack.pop();
						continue;
					}
				}
			}
		}

		@Override
		public AbstractMapNode next() {
			if (!hasNext()) {
				throw new NoSuchElementException();
			}

			AbstractMapNode innerNode = nodeIteratorStack.peek().next();

			if (innerNode.hasNodes()) {
				nodeIteratorStack.push(innerNode.nodeIterator());
			}

			return innerNode;
		}

		@Override
		public void remove() {
			throw new UnsupportedOperationException();
		}
	}

	static final class TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue implements
			TransientMap<java.lang.Integer, java.lang.Integer> {
		final private AtomicReference<Thread> mutator;
		private AbstractMapNode rootNode;
		private int hashCode;
		private int cachedSize;

		TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue(
				TrieMap_5Bits_Spec0To16_IntKey_IntValue trieMap_5Bits_Spec0To16_IntKey_IntValue) {
			this.mutator = new AtomicReference<Thread>(Thread.currentThread());
			this.rootNode = trieMap_5Bits_Spec0To16_IntKey_IntValue.rootNode;
			this.hashCode = trieMap_5Bits_Spec0To16_IntKey_IntValue.hashCode;
			this.cachedSize = trieMap_5Bits_Spec0To16_IntKey_IntValue.cachedSize;
			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
		}

		private boolean checkHashCodeAndSize(final int targetHash, final int targetSize) {
			int hash = 0;
			int size = 0;

			for (Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> it = entryIterator(); it
					.hasNext();) {
				final Map.Entry<java.lang.Integer, java.lang.Integer> entry = it.next();
				final int key = entry.getKey();
				final int val = entry.getValue();

				hash += (int) key ^ (int) val;
				size += 1;
			}

			return hash == targetHash && size == targetSize;
		}

		public java.lang.Integer put(final java.lang.Integer key, final java.lang.Integer val) {
			throw new UnsupportedOperationException();
		}

		public void putAll(final Map<? extends java.lang.Integer, ? extends java.lang.Integer> m) {
			throw new UnsupportedOperationException();
		}

		public void clear() {
			throw new UnsupportedOperationException();
		}

		public java.lang.Integer remove(final Object key) {
			throw new UnsupportedOperationException();
		}

		public boolean containsKey(final Object o) {
			try {
				@SuppressWarnings("unchecked")
				final int key = (int) o;
				return rootNode.containsKey(key, transformHashCode(key), 0);
			} catch (ClassCastException unused) {
				return false;
			}
		}

		public boolean containsKeyEquivalent(final Object o, final Comparator<Object> cmp) {
			try {
				@SuppressWarnings("unchecked")
				final int key = (int) o;
				return rootNode.containsKey(key, transformHashCode(key), 0, cmp);
			} catch (ClassCastException unused) {
				return false;
			}
		}

		public boolean containsValue(final Object o) {
			for (Iterator<java.lang.Integer> iterator = valueIterator(); iterator.hasNext();) {
				if (iterator.next().equals(o)) {
					return true;
				}
			}
			return false;
		}

		public boolean containsValueEquivalent(final Object o, final Comparator<Object> cmp) {
			for (Iterator<java.lang.Integer> iterator = valueIterator(); iterator.hasNext();) {
				if (cmp.compare(iterator.next(), o) == 0) {
					return true;
				}
			}
			return false;
		}

		public java.lang.Integer get(final Object o) {
			try {
				@SuppressWarnings("unchecked")
				final int key = (int) o;
				final Optional<java.lang.Integer> result = rootNode.findByKey(key,
						transformHashCode(key), 0);

				if (result.isPresent()) {
					return result.get();
				} else {
					return null;
				}
			} catch (ClassCastException unused) {
				return null;
			}
		}

		public java.lang.Integer getEquivalent(final Object o, final Comparator<Object> cmp) {
			try {
				@SuppressWarnings("unchecked")
				final int key = (int) o;
				final Optional<java.lang.Integer> result = rootNode.findByKey(key,
						transformHashCode(key), 0, cmp);

				if (result.isPresent()) {
					return result.get();
				} else {
					return null;
				}
			} catch (ClassCastException unused) {
				return null;
			}
		}

		public java.lang.Integer __put(final java.lang.Integer key, final java.lang.Integer val) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final MapResult details = MapResult.unchanged();

			final CompactMapNode newRootNode = rootNode.updated(mutator, key, val,
					transformHashCode(keyHash), 0, details);

			if (details.isModified()) {
				if (details.hasReplacedValue()) {
					final int old = details.getReplacedValue();

					final int valHashOld = (int) old;
					final int valHashNew = (int) val;

					rootNode = newRootNode;
					hashCode = hashCode + (keyHash ^ valHashNew) - (keyHash ^ valHashOld);

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return details.getReplacedValue();
				} else {
					final int valHashNew = (int) val;
					rootNode = newRootNode;
					hashCode += (keyHash ^ valHashNew);
					cachedSize += 1;

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return null;
				}
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return null;
		}

		public java.lang.Integer __putEquivalent(final java.lang.Integer key,
				final java.lang.Integer val, final Comparator<Object> cmp) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final MapResult details = MapResult.unchanged();

			final CompactMapNode newRootNode = rootNode.updated(mutator, key, val,
					transformHashCode(keyHash), 0, details, cmp);

			if (details.isModified()) {
				if (details.hasReplacedValue()) {
					final int old = details.getReplacedValue();

					final int valHashOld = (int) old;
					final int valHashNew = (int) val;

					rootNode = newRootNode;
					hashCode = hashCode + (keyHash ^ valHashNew) - (keyHash ^ valHashOld);

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return details.getReplacedValue();
				} else {
					final int valHashNew = (int) val;
					rootNode = newRootNode;
					hashCode += (keyHash ^ valHashNew);
					cachedSize += 1;

					if (DEBUG) {
						assert checkHashCodeAndSize(hashCode, cachedSize);
					}
					return null;
				}
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}
			return null;
		}

		public boolean __putAll(
				final Map<? extends java.lang.Integer, ? extends java.lang.Integer> map) {
			boolean modified = false;

			for (Map.Entry<? extends java.lang.Integer, ? extends java.lang.Integer> entry : map
					.entrySet()) {
				final boolean isPresent = this.containsKey(entry.getKey());
				final java.lang.Integer replaced = this.__put(entry.getKey(), entry.getValue());

				if (!isPresent || replaced != null) {
					modified = true;
				}
			}

			return modified;
		}

		public boolean __putAllEquivalent(
				final Map<? extends java.lang.Integer, ? extends java.lang.Integer> map,
				final Comparator<Object> cmp) {
			boolean modified = false;

			for (Map.Entry<? extends java.lang.Integer, ? extends java.lang.Integer> entry : map
					.entrySet()) {
				final boolean isPresent = this.containsKeyEquivalent(entry.getKey(), cmp);
				final java.lang.Integer replaced = this.__putEquivalent(entry.getKey(),
						entry.getValue(), cmp);

				if (!isPresent || replaced != null) {
					modified = true;
				}
			}

			return modified;
		}

		public java.lang.Integer __remove(final java.lang.Integer key) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final MapResult details = MapResult.unchanged();

			final CompactMapNode newRootNode = rootNode.removed(mutator, key,
					transformHashCode(keyHash), 0, details);

			if (details.isModified()) {
				assert details.hasReplacedValue();
				final int valHash = (int) details.getReplacedValue();

				rootNode = newRootNode;
				hashCode = hashCode - (keyHash ^ valHash);
				cachedSize = cachedSize - 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return details.getReplacedValue();
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}

			return null;
		}

		public java.lang.Integer __removeEquivalent(final java.lang.Integer key,
				final Comparator<Object> cmp) {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			final int keyHash = key.hashCode();
			final MapResult details = MapResult.unchanged();

			final CompactMapNode newRootNode = rootNode.removed(mutator, key,
					transformHashCode(keyHash), 0, details, cmp);

			if (details.isModified()) {
				assert details.hasReplacedValue();
				final int valHash = (int) details.getReplacedValue();

				rootNode = newRootNode;
				hashCode = hashCode - (keyHash ^ valHash);
				cachedSize = cachedSize - 1;

				if (DEBUG) {
					assert checkHashCodeAndSize(hashCode, cachedSize);
				}
				return details.getReplacedValue();
			}

			if (DEBUG) {
				assert checkHashCodeAndSize(hashCode, cachedSize);
			}

			return null;
		}

		public int size() {
			return cachedSize;
		}

		public boolean isEmpty() {
			return cachedSize == 0;
		}

		public Iterator<java.lang.Integer> keyIterator() {
			return new TransientMapKeyIterator(this);
		}

		public Iterator<java.lang.Integer> valueIterator() {
			return new TransientMapValueIterator(this);
		}

		public Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> entryIterator() {
			return new TransientMapEntryIterator(this);
		}

		public static class TransientMapKeyIterator extends MapKeyIterator {
			final TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue collection;
			int lastKey;

			public TransientMapKeyIterator(
					final TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue collection) {
				super(collection.rootNode);
				this.collection = collection;
			}

			public java.lang.Integer next() {
				return lastKey = super.next();
			}

			public void remove() {
				// TODO: test removal at iteration rigorously
				collection.__remove(lastKey);
			}
		}

		public static class TransientMapValueIterator extends MapValueIterator {
			final TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue collection;

			public TransientMapValueIterator(
					final TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue collection) {
				super(collection.rootNode);
				this.collection = collection;
			}

			public java.lang.Integer next() {
				return super.next();
			}

			public void remove() {
				throw new UnsupportedOperationException();
			}
		}

		public static class TransientMapEntryIterator extends MapEntryIterator {
			final TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue collection;

			public TransientMapEntryIterator(
					final TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue collection) {
				super(collection.rootNode);
				this.collection = collection;
			}

			public Map.Entry<java.lang.Integer, java.lang.Integer> next() {
				return super.next();
			}

			public void remove() {
				throw new UnsupportedOperationException();
			}
		}

		@Override
		public Set<java.lang.Integer> keySet() {
			Set<java.lang.Integer> keySet = null;

			if (keySet == null) {
				keySet = new AbstractSet<java.lang.Integer>() {
					@Override
					public Iterator<java.lang.Integer> iterator() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.keyIterator();
					}

					@Override
					public int size() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.size();
					}

					@Override
					public boolean isEmpty() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.isEmpty();
					}

					@Override
					public void clear() {
						TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.clear();
					}

					@Override
					public boolean contains(Object k) {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.containsKey(k);
					}
				};
			}

			return keySet;
		}

		@Override
		public Collection<java.lang.Integer> values() {
			Collection<java.lang.Integer> values = null;

			if (values == null) {
				values = new AbstractCollection<java.lang.Integer>() {
					@Override
					public Iterator<java.lang.Integer> iterator() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this
								.valueIterator();
					}

					@Override
					public int size() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.size();
					}

					@Override
					public boolean isEmpty() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.isEmpty();
					}

					@Override
					public void clear() {
						TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.clear();
					}

					@Override
					public boolean contains(Object v) {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this
								.containsValue(v);
					}
				};
			}

			return values;
		}

		@Override
		public Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet() {
			Set<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> entrySet = null;

			if (entrySet == null) {
				entrySet = new AbstractSet<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>>() {
					@Override
					public Iterator<java.util.Map.Entry<java.lang.Integer, java.lang.Integer>> iterator() {
						return new Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>>() {
							private final Iterator<Map.Entry<java.lang.Integer, java.lang.Integer>> i = entryIterator();

							@Override
							public boolean hasNext() {
								return i.hasNext();
							}

							@Override
							public Map.Entry<java.lang.Integer, java.lang.Integer> next() {
								return i.next();
							}

							@Override
							public void remove() {
								i.remove();
							}
						};
					}

					@Override
					public int size() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.size();
					}

					@Override
					public boolean isEmpty() {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.isEmpty();
					}

					@Override
					public void clear() {
						TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.clear();
					}

					@Override
					public boolean contains(Object k) {
						return TransientTrieMap_5Bits_Spec0To16_IntKey_IntValue.this.containsKey(k);
					}
				};
			}

			return entrySet;
		}

		@Override
		public boolean equals(final Object other) {
			if (other == this) {
				return true;
			}
			if (other == null) {
				return false;
			}

			if (other instanceof Map) {
				Map that = (Map) other;

				if (this.size() != that.size())
					return false;

				for (@SuppressWarnings("unchecked")
				Iterator<Map.Entry> it = that.entrySet().iterator(); it.hasNext();) {
					Map.Entry entry = it.next();

					try {
						@SuppressWarnings("unchecked")
						final int key = (java.lang.Integer) entry.getKey();
						final Optional<java.lang.Integer> result = rootNode.findByKey(key,
								transformHashCode(key), 0);

						if (!result.isPresent()) {
							return false;
						} else {
							@SuppressWarnings("unchecked")
							final int val = (java.lang.Integer) entry.getValue();

							if (!result.get().equals(val)) {
								return false;
							}
						}
					} catch (ClassCastException unused) {
						return false;
					}
				}

				return true;
			}

			return false;
		}

		@Override
		public int hashCode() {
			return hashCode;
		}

		@Override
		public ImmutableMap<java.lang.Integer, java.lang.Integer> freeze() {
			if (mutator.get() == null) {
				throw new IllegalStateException("Transient already frozen.");
			}

			mutator.set(null);
			return new TrieMap_5Bits_Spec0To16_IntKey_IntValue(rootNode, hashCode, cachedSize);
		}
	}

	private static final class Map0To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactEmptyMapNode {

		private Map0To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap) {
			super(mutator, nodeMap, dataMap);
		}

		boolean hasSlots() {
			return false;
		}

		int slotArity() {
			return 0;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_EMPTY;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x1(mutator, nodeMap, dataMap, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map0To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;

		private Map0To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 1;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x1(mutator, nodeMap, dataMap, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x0(mutator, nodeMap, dataMap, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x1(mutator, nodeMap, dataMap, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map0To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 2;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x1(mutator, nodeMap, dataMap, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x0(mutator, nodeMap, dataMap, node, node2);
			case 1:
				return nodeOf2x0(mutator, nodeMap, dataMap, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x1(mutator, nodeMap, dataMap, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x1(mutator, nodeMap, dataMap, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map0To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 3;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x0(mutator, nodeMap, dataMap, node, node2, node3);
			case 1:
				return nodeOf3x0(mutator, nodeMap, dataMap, node1, node, node3);
			case 2:
				return nodeOf3x0(mutator, nodeMap, dataMap, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x1(mutator, nodeMap, dataMap, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x1(mutator, nodeMap, dataMap, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x1(mutator, nodeMap, dataMap, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map0To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 4;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x0(mutator, nodeMap, dataMap, node, node2, node3, node4);
			case 1:
				return nodeOf4x0(mutator, nodeMap, dataMap, node1, node, node3, node4);
			case 2:
				return nodeOf4x0(mutator, nodeMap, dataMap, node1, node2, node, node4);
			case 3:
				return nodeOf4x0(mutator, nodeMap, dataMap, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map0To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 5;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map0To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 6;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map0To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 7;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7);
			case 1:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7);
			case 2:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7);
			case 3:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7);
			case 4:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7);
			case 5:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7);
			case 6:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map0To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 8;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8);
			case 1:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8);
			case 2:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8);
			case 3:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8);
			case 4:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8);
			case 5:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8);
			case 6:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8);
			case 7:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map0To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 9;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 1:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9);
			case 2:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9);
			case 3:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9);
			case 4:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9);
			case 5:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9);
			case 6:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9);
			case 7:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9);
			case 8:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map0To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 10;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10);
			case 6:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10);
			case 7:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10);
			case 8:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10);
			case 9:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To11Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		private Map0To11Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 11;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node11;
			case 1:
				return node10;
			case 2:
				return node9;
			case 3:
				return node8;
			case 4:
				return node7;
			case 5:
				return node6;
			case 6:
				return node5;
			case 7:
				return node4;
			case 8:
				return node3;
			case 9:
				return node2;
			case 10:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 11;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf11x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To12Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		private Map0To12Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node12;
			case 1:
				return node11;
			case 2:
				return node10;
			case 3:
				return node9;
			case 4:
				return node8;
			case 5:
				return node7;
			case 6:
				return node6;
			case 7:
				return node5;
			case 8:
				return node4;
			case 9:
				return node3;
			case 10:
				return node2;
			case 11:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 12;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf12x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To13Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		private Map0To13Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node13;
			case 1:
				return node12;
			case 2:
				return node11;
			case 3:
				return node10;
			case 4:
				return node9;
			case 5:
				return node8;
			case 6:
				return node7;
			case 7:
				return node6;
			case 8:
				return node5;
			case 9:
				return node4;
			case 10:
				return node3;
			case 11:
				return node2;
			case 12:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 13;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf13x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To14Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;

		private Map0To14Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node14;
			case 1:
				return node13;
			case 2:
				return node12;
			case 3:
				return node11;
			case 4:
				return node10;
			case 5:
				return node9;
			case 6:
				return node8;
			case 7:
				return node7;
			case 8:
				return node6;
			case 9:
				return node5;
			case 10:
				return node4;
			case 11:
				return node3;
			case 12:
				return node2;
			case 13:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 14;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf14x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 5:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10, node11, node12, node13, node14);
			case 6:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10, node11, node12, node13, node14);
			case 7:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10, node11, node12, node13, node14);
			case 8:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10, node11, node12, node13, node14);
			case 9:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node, node11, node12, node13, node14);
			case 10:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node, node12, node13, node14);
			case 11:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node, node13, node14);
			case 12:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node, node14);
			case 13:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node11, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node12, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node13,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (valIndex) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To15Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;
		private final CompactMapNode node15;

		private Map0To15Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node15;
			case 1:
				return node14;
			case 2:
				return node13;
			case 3:
				return node12;
			case 4:
				return node11;
			case 5:
				return node10;
			case 6:
				return node9;
			case 7:
				return node8;
			case 8:
				return node7;
			case 9:
				return node6;
			case 10:
				return node5;
			case 11:
				return node4;
			case 12:
				return node3;
			case 13:
				return node2;
			case 14:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14, node15);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 15;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf15x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 1:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 2:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 3:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 4:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 5:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			case 6:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10, node11, node12, node13, node14, node15);
			case 7:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10, node11, node12, node13, node14, node15);
			case 8:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10, node11, node12, node13, node14, node15);
			case 9:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node, node11, node12, node13, node14, node15);
			case 10:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node, node12, node13, node14, node15);
			case 11:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node, node13, node14, node15);
			case 12:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node, node14, node15);
			case 13:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node, node15);
			case 14:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node11, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node12, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node13,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 14:
				switch (valIndex) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map0To16Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactNodesOnlyMapNode {

		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;
		private final CompactMapNode node15;
		private final CompactMapNode node16;

		private Map0To16Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15,
				final CompactMapNode node16) {
			super(mutator, nodeMap, dataMap);
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;
			this.node16 = node16;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		int getValue(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node16;
			case 1:
				return node15;
			case 2:
				return node14;
			case 3:
				return node13;
			case 4:
				return node12;
			case 5:
				return node11;
			case 6:
				return node10;
			case 7:
				return node9;
			case 8:
				return node8;
			case 9:
				return node7;
			case 10:
				return node6;
			case 11:
				return node5;
			case 12:
				return node4;
			case 13:
				return node3;
			case 14:
				return node2;
			case 15:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14, node15, node16);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 16;
		}

		boolean hasPayload() {
			return false;
		}

		int payloadArity() {
			return 0;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf16x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15, node16);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf16x0(mutator, nodeMap, dataMap, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 1:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 2:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 3:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 4:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 5:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 6:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 7:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10, node11, node12, node13, node14, node15,
						node16);
			case 8:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10, node11, node12, node13, node14, node15,
						node16);
			case 9:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node, node11, node12, node13, node14, node15,
						node16);
			case 10:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node, node12, node13, node14, node15,
						node16);
			case 11:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node, node13, node14, node15,
						node16);
			case 12:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node, node14, node15,
						node16);
			case 13:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node, node15,
						node16);
			case 14:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node,
						node16);
			case 15:
				return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node11, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node12, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node13,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node14, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node15, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 14:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node16);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 15:
				switch (valIndex) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;

		private Map1To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 2;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x1(mutator, nodeMap, dataMap, key1, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x2(mutator, nodeMap, dataMap, key, val, key1, val1);
			case 1:
				return nodeOf0x2(mutator, nodeMap, dataMap, key1, val1, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x0(mutator, nodeMap, dataMap);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x0(mutator, nodeMap, dataMap, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map1To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;

		private Map1To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 3;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x1(mutator, nodeMap, dataMap, key1, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1);
			case 1:
				return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x0(mutator, nodeMap, dataMap, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x1(mutator, nodeMap, dataMap, key1, val1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x0(mutator, nodeMap, dataMap, node, node1);
				case 1:
					return nodeOf2x0(mutator, nodeMap, dataMap, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x2(mutator, nodeMap, dataMap, key, val, key1, val1);
				case 1:
					return nodeOf0x2(mutator, nodeMap, dataMap, key1, val1, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map1To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 4;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x1(mutator, nodeMap, dataMap, key1, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2);
			case 1:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x0(mutator, nodeMap, dataMap, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x1(mutator, nodeMap, dataMap, key1, val1, node, node2);
			case 1:
				return nodeOf2x1(mutator, nodeMap, dataMap, key1, val1, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x0(mutator, nodeMap, dataMap, node, node1, node2);
				case 1:
					return nodeOf3x0(mutator, nodeMap, dataMap, node1, node, node2);
				case 2:
					return nodeOf3x0(mutator, nodeMap, dataMap, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2);
				case 1:
					return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1);
				case 1:
					return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map1To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 5;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3);
			case 1:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x0(mutator, nodeMap, dataMap, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3);
			case 1:
				return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3);
			case 2:
				return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x0(mutator, nodeMap, dataMap, node, node1, node2, node3);
				case 1:
					return nodeOf4x0(mutator, nodeMap, dataMap, node1, node, node2, node3);
				case 2:
					return nodeOf4x0(mutator, nodeMap, dataMap, node1, node2, node, node3);
				case 3:
					return nodeOf4x0(mutator, nodeMap, dataMap, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3);
				case 1:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3);
				case 1:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2);
				case 1:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map1To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 6;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4);
			case 1:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x0(mutator, nodeMap, dataMap, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4);
			case 1:
				return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4);
			case 2:
				return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4);
			case 3:
				return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map1To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 7;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5);
			case 1:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5);
			case 2:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5);
			case 3:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5);
			case 4:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4, node5);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4, node5);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4, node5);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node5);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map1To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 8;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6);
			case 1:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6);
			case 2:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6);
			case 3:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6);
			case 4:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node, node6);
			case 5:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4, node5, node6);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4, node5, node6);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4, node5, node6);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node5, node6);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node6);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map1To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 9;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7);
			case 1:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7);
			case 2:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7);
			case 3:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7);
			case 4:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node, node6, node7);
			case 5:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node, node7);
			case 6:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4, node5, node6, node7);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4, node5, node6, node7);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4, node5, node6, node7);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node5, node6, node7);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node6, node7);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node7);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map1To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 10;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8);
			case 1:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8);
			case 2:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8);
			case 3:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8);
			case 4:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node, node6, node7, node8);
			case 5:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node, node7, node8);
			case 6:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node, node8);
			case 7:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node5, node6, node7, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node6, node7, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node7, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node8);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map1To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 11;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node, node6, node7, node8, node9);
			case 5:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node, node7, node8, node9);
			case 6:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node, node8, node9);
			case 7:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node7, node, node9);
			case 8:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node6, node7, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node7, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node8, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node7, node9);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map1To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf10x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf11x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2, node3,
							node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node3,
							node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node3,
							node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node7, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node8, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node7, node9, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node7, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node7, node8, node10);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node7, node8, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
							node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To11Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		private Map1To11Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node11;
			case 1:
				return node10;
			case 2:
				return node9;
			case 3:
				return node8;
			case 4:
				return node7;
			case 5:
				return node6;
			case 6:
				return node5;
			case 7:
				return node4;
			case 8:
				return node3;
			case 9:
				return node2;
			case 10:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 11;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf11x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf12x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To12Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		private Map1To12Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node12;
			case 1:
				return node11;
			case 2:
				return node10;
			case 3:
				return node9;
			case 4:
				return node8;
			case 5:
				return node7;
			case 6:
				return node6;
			case 7:
				return node5;
			case 8:
				return node4;
			case 9:
				return node3;
			case 10:
				return node2;
			case 11:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 12;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf12x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf13x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				case 2:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				case 3:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9, node10, node11, node12);
				case 4:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9, node10, node11, node12);
				case 5:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9, node10, node11, node12);
				case 6:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9, node10, node11, node12);
				case 7:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9, node10, node11, node12);
				case 8:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9, node10, node11, node12);
				case 9:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node, node10, node11, node12);
				case 10:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node, node11, node12);
				case 11:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node, node12);
				case 12:
					return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To13Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		private Map1To13Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node13;
			case 1:
				return node12;
			case 2:
				return node11;
			case 3:
				return node10;
			case 4:
				return node9;
			case 5:
				return node8;
			case 6:
				return node7;
			case 7:
				return node6;
			case 8:
				return node5;
			case 9:
				return node4;
			case 10:
				return node3;
			case 11:
				return node2;
			case 12:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 13;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 1:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf13x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 2:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 3:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 4:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node, node6, node7, node8, node9, node10, node11, node12, node13);
			case 5:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node, node7, node8, node9, node10, node11, node12, node13);
			case 6:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node, node8, node9, node10, node11, node12, node13);
			case 7:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node, node9, node10, node11, node12, node13);
			case 8:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node, node10, node11, node12, node13);
			case 9:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node, node11, node12, node13);
			case 10:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node, node12, node13);
			case 11:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node, node13);
			case 12:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf14x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				case 1:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				case 2:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				case 3:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				case 4:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9, node10, node11, node12, node13);
				case 5:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9, node10, node11, node12, node13);
				case 6:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9, node10, node11, node12, node13);
				case 7:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9, node10, node11, node12, node13);
				case 8:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9, node10, node11, node12, node13);
				case 9:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node, node10, node11, node12, node13);
				case 10:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node, node11, node12, node13);
				case 11:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node, node12, node13);
				case 12:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node, node13);
				case 13:
					return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12,
							node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12,
							node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12,
							node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12,
							node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node13);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To14Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;

		private Map1To14Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node14;
			case 1:
				return node13;
			case 2:
				return node12;
			case 3:
				return node11;
			case 4:
				return node10;
			case 5:
				return node9;
			case 6:
				return node8;
			case 7:
				return node7;
			case 8:
				return node6;
			case 9:
				return node5;
			case 10:
				return node4;
			case 11:
				return node3;
			case 12:
				return node2;
			case 13:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 14;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 1:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf14x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 1:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 2:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 3:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14);
			case 4:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node, node6, node7, node8, node9, node10, node11, node12, node13,
						node14);
			case 5:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node, node7, node8, node9, node10, node11, node12, node13,
						node14);
			case 6:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node, node8, node9, node10, node11, node12, node13,
						node14);
			case 7:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node, node9, node10, node11, node12, node13,
						node14);
			case 8:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node, node10, node11, node12, node13,
						node14);
			case 9:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node, node11, node12, node13,
						node14);
			case 10:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node, node12, node13,
						node14);
			case 11:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node, node13,
						node14);
			case 12:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node,
						node14);
			case 13:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf15x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 1:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 2:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 3:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 4:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 5:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 6:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9, node10, node11, node12, node13,
							node14);
				case 7:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9, node10, node11, node12, node13,
							node14);
				case 8:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9, node10, node11, node12, node13,
							node14);
				case 9:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node, node10, node11, node12, node13,
							node14);
				case 10:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node, node11, node12, node13,
							node14);
				case 11:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node, node12, node13,
							node14);
				case 12:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node, node13,
							node14);
				case 13:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node13, node,
							node14);
				case 14:
					return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node13, node14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12,
							node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12,
							node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12,
							node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12,
							node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node13, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node14);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (valIndex) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map1To15Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;
		private final CompactMapNode node15;

		private Map1To15Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14, final CompactMapNode node15) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
			this.node15 = node15;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node15;
			case 1:
				return node14;
			case 2:
				return node13;
			case 3:
				return node12;
			case 4:
				return node11;
			case 5:
				return node10;
			case 6:
				return node9;
			case 7:
				return node8;
			case 8:
				return node7;
			case 9:
				return node6;
			case 10:
				return node5;
			case 11:
				return node4;
			case 12:
				return node3;
			case 13:
				return node2;
			case 14:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14, node15);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 15;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 1;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf15x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14, node15);
			case 1:
				return nodeOf15x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf15x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11, node12, node13, node14, node15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node, node2, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15);
			case 1:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node3, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15);
			case 2:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node, node4,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15);
			case 3:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node,
						node5, node6, node7, node8, node9, node10, node11, node12, node13, node14,
						node15);
			case 4:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node, node6, node7, node8, node9, node10, node11, node12, node13,
						node14, node15);
			case 5:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node, node7, node8, node9, node10, node11, node12, node13,
						node14, node15);
			case 6:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node, node8, node9, node10, node11, node12, node13,
						node14, node15);
			case 7:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node, node9, node10, node11, node12, node13,
						node14, node15);
			case 8:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node, node10, node11, node12, node13,
						node14, node15);
			case 9:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node, node11, node12, node13,
						node14, node15);
			case 10:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node, node12, node13,
						node14, node15);
			case 11:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node, node13,
						node14, node15);
			case 12:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node,
						node14, node15);
			case 13:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13,
						node, node15);
			case 14:
				return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13,
						node14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf16x0(mutator, nodeMap, dataMap, node, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 1:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node, node2, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 2:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node, node3, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 3:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node, node4,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 4:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node,
							node5, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 5:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node, node6, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 6:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node, node7, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 7:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node, node8, node9, node10, node11, node12, node13,
							node14, node15);
				case 8:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node, node9, node10, node11, node12, node13,
							node14, node15);
				case 9:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node, node10, node11, node12, node13,
							node14, node15);
				case 10:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node, node11, node12, node13,
							node14, node15);
				case 11:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node, node12, node13,
							node14, node15);
				case 12:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node, node13,
							node14, node15);
				case 13:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node13, node,
							node14, node15);
				case 14:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node13, node14,
							node, node15);
				case 15:
					return nodeOf16x0(mutator, nodeMap, dataMap, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11, node12, node13, node14,
							node15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12,
							node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node11, node12,
							node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12,
							node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node12,
							node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node13, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node13, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node14, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node14, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node15);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node15);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 14:
				switch (valIndex) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key, val, key1, val1, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key, val, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;

		private Map2To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 4;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x2(mutator, nodeMap, dataMap, key1, val, key2, val2);
			case 1:
				return nodeOf0x2(mutator, nodeMap, dataMap, key1, val1, key2, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2);
			case 1:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2);
			case 2:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x1(mutator, nodeMap, dataMap, key2, val2);
			case 1:
				return nodeOf0x1(mutator, nodeMap, dataMap, key1, val1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x1(mutator, nodeMap, dataMap, key2, val2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x1(mutator, nodeMap, dataMap, key1, val1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map2To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;

		private Map2To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 5;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1);
			case 1:
				return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, node1);
			case 1:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, node1);
			case 2:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x1(mutator, nodeMap, dataMap, key2, val2, node1);
			case 1:
				return nodeOf1x1(mutator, nodeMap, dataMap, key1, val1, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x1(mutator, nodeMap, dataMap, key2, val2, node, node1);
				case 1:
					return nodeOf2x1(mutator, nodeMap, dataMap, key2, val2, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x1(mutator, nodeMap, dataMap, key1, val1, node, node1);
				case 1:
					return nodeOf2x1(mutator, nodeMap, dataMap, key1, val1, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2);
				case 1:
					return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2);
				case 2:
					return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map2To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 6;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2);
			case 1:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2);
			case 1:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2);
			case 2:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x1(mutator, nodeMap, dataMap, key2, val2, node1, node2);
			case 1:
				return nodeOf2x1(mutator, nodeMap, dataMap, key1, val1, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2);
			case 1:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2);
				case 1:
					return nodeOf3x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2);
				case 2:
					return nodeOf3x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2);
				case 1:
					return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2);
				case 2:
					return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2);
				case 1:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2);
				case 2:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1);
				case 1:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1);
				case 2:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map2To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 7;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3);
			case 1:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3);
			case 1:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3);
			case 2:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3);
			case 1:
				return nodeOf3x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3);
			case 1:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3);
			case 2:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3);
				case 2:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3);
				case 2:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2);
				case 2:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map2To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 8;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4);
			case 1:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4);
			case 1:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4);
			case 2:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4);
			case 1:
				return nodeOf4x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4);
			case 1:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4);
			case 2:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4);
			case 3:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map2To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 9;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
						node5);
			case 1:
				return nodeOf5x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5);
			case 2:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5);
			case 3:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5);
			case 4:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map2To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 10;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
						node5, node6);
			case 1:
				return nodeOf6x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6);
			case 2:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6);
			case 3:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6);
			case 4:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6);
			case 5:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map2To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 11;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
						node5, node6, node7);
			case 1:
				return nodeOf7x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7);
			case 3:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7);
			case 4:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7);
			case 5:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7);
			case 6:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map2To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 1:
				return nodeOf8x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map2To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map2To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf10x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To11Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		private Map2To11Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node11;
			case 1:
				return node10;
			case 2:
				return node9;
			case 3:
				return node8;
			case 4:
				return node7;
			case 5:
				return node6;
			case 6:
				return node5;
			case 7:
				return node4;
			case 8:
				return node3;
			case 9:
				return node2;
			case 10:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 11;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 1:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 2:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf11x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8, node9, node10, node11);
			case 4:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8, node9, node10, node11);
			case 5:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8, node9, node10, node11);
			case 6:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8, node9, node10, node11);
			case 7:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node, node9, node10, node11);
			case 8:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node, node10, node11);
			case 9:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To12Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		private Map2To12Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node12;
			case 1:
				return node11;
			case 2:
				return node10;
			case 3:
				return node9;
			case 4:
				return node8;
			case 5:
				return node7;
			case 6:
				return node6;
			case 7:
				return node5;
			case 8:
				return node4;
			case 9:
				return node3;
			case 10:
				return node2;
			case 11:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 12;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 1:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 2:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf12x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 3:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8, node9, node10, node11, node12);
			case 4:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8, node9, node10, node11, node12);
			case 5:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8, node9, node10, node11, node12);
			case 6:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8, node9, node10, node11, node12);
			case 7:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node, node9, node10, node11, node12);
			case 8:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node, node10, node11, node12);
			case 9:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node, node11, node12);
			case 10:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node, node12);
			case 11:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 2:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 3:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 4:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11, node12);
				case 5:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11, node12);
				case 6:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11, node12);
				case 7:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11, node12);
				case 8:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11, node12);
				case 9:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11, node12);
				case 10:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11, node12);
				case 11:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node, node12);
				case 12:
					return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 1:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 2:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 3:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11, node12);
				case 4:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11, node12);
				case 5:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11, node12);
				case 6:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11, node12);
				case 7:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11, node12);
				case 8:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11, node12);
				case 9:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11, node12);
				case 10:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11, node12);
				case 11:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node, node12);
				case 12:
					return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To13Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		private Map2To13Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node13;
			case 1:
				return node12;
			case 2:
				return node11;
			case 3:
				return node10;
			case 4:
				return node9;
			case 5:
				return node8;
			case 6:
				return node7;
			case 7:
				return node6;
			case 8:
				return node5;
			case 9:
				return node4;
			case 10:
				return node3;
			case 11:
				return node2;
			case 12:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 13;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 1:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 1:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 2:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf13x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13);
			case 1:
				return nodeOf13x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 1:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 2:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 3:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 4:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 5:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8, node9, node10, node11, node12,
						node13);
			case 6:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8, node9, node10, node11, node12,
						node13);
			case 7:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node, node9, node10, node11, node12,
						node13);
			case 8:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node, node10, node11, node12,
						node13);
			case 9:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node, node11, node12,
						node13);
			case 10:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node, node12,
						node13);
			case 11:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node,
						node13);
			case 12:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 3:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
				case 4:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
				case 5:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11, node12,
							node13);
				case 6:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11, node12,
							node13);
				case 7:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11, node12,
							node13);
				case 8:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11, node12,
							node13);
				case 9:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11, node12,
							node13);
				case 10:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11, node12,
							node13);
				case 11:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node, node12,
							node13);
				case 12:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12, node,
							node13);
				case 13:
					return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 3:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
				case 4:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11, node12,
							node13);
				case 5:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11, node12,
							node13);
				case 6:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11, node12,
							node13);
				case 7:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11, node12,
							node13);
				case 8:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11, node12,
							node13);
				case 9:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11, node12,
							node13);
				case 10:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11, node12,
							node13);
				case 11:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node, node12,
							node13);
				case 12:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12, node,
							node13);
				case 13:
					return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node13);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node13);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map2To14Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;
		private final CompactMapNode node14;

		private Map2To14Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13,
				final CompactMapNode node14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
			this.node14 = node14;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node14;
			case 1:
				return node13;
			case 2:
				return node12;
			case 3:
				return node11;
			case 4:
				return node10;
			case 5:
				return node9;
			case 6:
				return node8;
			case 7:
				return node7;
			case 8:
				return node6;
			case 9:
				return node5;
			case 10:
				return node4;
			case 11:
				return node3;
			case 12:
				return node2;
			case 13:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13, node14);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 14;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 2;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 1:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf14x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13, node14);
			case 1:
				return nodeOf14x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13, node14);
			case 2:
				return nodeOf14x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13, node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf14x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13,
						node14);
			case 1:
				return nodeOf14x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
						node4, node5, node6, node7, node8, node9, node10, node11, node12, node13,
						node14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 1:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 2:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 3:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 4:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node, node6, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 5:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node, node7, node8, node9, node10, node11, node12,
						node13, node14);
			case 6:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node, node8, node9, node10, node11, node12,
						node13, node14);
			case 7:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node, node9, node10, node11, node12,
						node13, node14);
			case 8:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node, node10, node11, node12,
						node13, node14);
			case 9:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node, node11, node12,
						node13, node14);
			case 10:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node, node12,
						node13, node14);
			case 11:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node,
						node13, node14);
			case 12:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node, node14);
			case 13:
				return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 3:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 4:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 5:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 6:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 7:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11, node12,
							node13, node14);
				case 8:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11, node12,
							node13, node14);
				case 9:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11, node12,
							node13, node14);
				case 10:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11, node12,
							node13, node14);
				case 11:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node, node12,
							node13, node14);
				case 12:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12, node,
							node13, node14);
				case 13:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node, node14);
				case 14:
					return nodeOf15x1(mutator, nodeMap, dataMap, key2, val2, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node, node1, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node, node2,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node,
							node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 3:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node, node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 4:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 5:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node, node6, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 6:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node, node7, node8, node9, node10, node11, node12,
							node13, node14);
				case 7:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node, node8, node9, node10, node11, node12,
							node13, node14);
				case 8:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node, node9, node10, node11, node12,
							node13, node14);
				case 9:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node, node10, node11, node12,
							node13, node14);
				case 10:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node, node11, node12,
							node13, node14);
				case 11:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node, node12,
							node13, node14);
				case 12:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12, node,
							node13, node14);
				case 13:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node, node14);
				case 14:
					return nodeOf15x1(mutator, nodeMap, dataMap, key1, val1, node1, node2, node3,
							node4, node5, node6, node7, node8, node9, node10, node11, node12,
							node13, node14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node6, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node7, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node8, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node9, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node10, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node11,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node12, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node13, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node13, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node13, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node14);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node14);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node14);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (valIndex) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;

		private Map3To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 6;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3);
			case 1:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3);
			case 2:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3);
			case 1:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3);
			case 2:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3);
			case 3:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x2(mutator, nodeMap, dataMap, key2, val2, key3, val3);
			case 1:
				return nodeOf0x2(mutator, nodeMap, dataMap, key1, val1, key3, val3);
			case 2:
				return nodeOf0x2(mutator, nodeMap, dataMap, key1, val1, key2, val2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map3To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;

		private Map3To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 7;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1);
			case 1:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1);
			case 2:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1);
			case 1:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1);
			case 2:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1);
			case 3:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1);
			case 1:
				return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1);
			case 2:
				return nodeOf1x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node, node1);
				case 1:
					return nodeOf2x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node, node1);
				case 1:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node, node1);
				case 1:
					return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3);
				case 1:
					return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3);
				case 2:
					return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3);
				case 3:
					return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map3To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 8;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2);
			case 1:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2);
			case 2:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2);
			case 1:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2);
			case 2:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2);
			case 3:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2);
			case 1:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2);
			case 2:
				return nodeOf2x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2);
			case 1:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2);
				case 2:
					return nodeOf3x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2);
				case 2:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2);
				case 1:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2);
				case 2:
					return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2);
				case 1:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2);
				case 2:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2);
				case 3:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1);
				case 1:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1);
				case 2:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1);
				case 3:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map3To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 9;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3);
			case 1:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3);
			case 2:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3);
			case 1:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3);
			case 2:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3);
			case 3:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3);
			case 1:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3);
			case 2:
				return nodeOf3x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3);
			case 1:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3);
			case 2:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3);
				case 2:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3);
				case 3:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3);
				case 2:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3);
				case 3:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2);
				case 2:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2);
				case 3:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map3To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 10;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4);
			case 1:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4);
			case 2:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3, node4);
			case 1:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3, node4);
			case 2:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3, node4);
			case 3:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4);
			case 1:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4);
			case 2:
				return nodeOf4x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4);
			case 1:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4);
			case 2:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4);
			case 3:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4);
				case 3:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4);
				case 3:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4);
				case 3:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3);
				case 3:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map3To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 11;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5);
			case 2:
				return nodeOf5x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map3To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6);
			case 2:
				return nodeOf6x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map3To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map3To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node8);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map3To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map3To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 1:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 2:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 3:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf10x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7, node8, node9, node10);
			case 6:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node, node8, node9, node10);
			case 7:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node, node9, node10);
			case 8:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node, node10);
			case 9:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node2, node3, node4, node5, node6, node7, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node3, node4, node5, node6, node7, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node4, node5, node6, node7, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node5, node6, node7, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node6, node7, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node7, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node8, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node7, node9,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, node1, node2, node3, node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To11Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		private Map3To11Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node11;
			case 1:
				return node10;
			case 2:
				return node9;
			case 3:
				return node8;
			case 4:
				return node7;
			case 5:
				return node6;
			case 6:
				return node5;
			case 7:
				return node4;
			case 8:
				return node3;
			case 9:
				return node2;
			case 10:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 11;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 1:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 2:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 1:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 2:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 3:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf11x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf11x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 1:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 2:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 3:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7, node8, node9, node10,
						node11);
			case 4:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7, node8, node9, node10,
						node11);
			case 5:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7, node8, node9, node10,
						node11);
			case 6:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node, node8, node9, node10,
						node11);
			case 7:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node, node9, node10,
						node11);
			case 8:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node, node10,
						node11);
			case 9:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node, node11);
			case 10:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 2:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 3:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 4:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11);
				case 5:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11);
				case 6:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11);
				case 7:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11);
				case 8:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11);
				case 9:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11);
				case 10:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11);
				case 11:
					return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 2:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 3:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 4:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11);
				case 5:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11);
				case 6:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11);
				case 7:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11);
				case 8:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11);
				case 9:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11);
				case 10:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11);
				case 11:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 1:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 2:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 3:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11);
				case 4:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11);
				case 5:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11);
				case 6:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11);
				case 7:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11);
				case 8:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11);
				case 9:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11);
				case 10:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11);
				case 11:
					return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To12Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		private Map3To12Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node12;
			case 1:
				return node11;
			case 2:
				return node10;
			case 3:
				return node9;
			case 4:
				return node8;
			case 5:
				return node7;
			case 6:
				return node6;
			case 7:
				return node5;
			case 8:
				return node4;
			case 9:
				return node3;
			case 10:
				return node2;
			case 11:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 12;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 1:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 2:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 1:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 2:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 3:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf12x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			case 2:
				return nodeOf12x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 1:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 2:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 3:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 4:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7, node8, node9, node10,
						node11, node12);
			case 5:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7, node8, node9, node10,
						node11, node12);
			case 6:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node, node8, node9, node10,
						node11, node12);
			case 7:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node, node9, node10,
						node11, node12);
			case 8:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node, node10,
						node11, node12);
			case 9:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node,
						node11, node12);
			case 10:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node, node12);
			case 11:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 2:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 3:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 4:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 5:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11, node12);
				case 6:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11, node12);
				case 7:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11, node12);
				case 8:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11, node12);
				case 9:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11, node12);
				case 10:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11, node12);
				case 11:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node, node12);
				case 12:
					return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 2:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 3:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 4:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 5:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11, node12);
				case 6:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11, node12);
				case 7:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11, node12);
				case 8:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11, node12);
				case 9:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11, node12);
				case 10:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11, node12);
				case 11:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node, node12);
				case 12:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 1:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 2:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 3:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 4:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11, node12);
				case 5:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11, node12);
				case 6:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11, node12);
				case 7:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11, node12);
				case 8:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11, node12);
				case 9:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11, node12);
				case 10:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11, node12);
				case 11:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node, node12);
				case 12:
					return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map3To13Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;
		private final CompactMapNode node13;

		private Map3To13Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11,
				final CompactMapNode node12, final CompactMapNode node13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
			this.node13 = node13;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node13;
			case 1:
				return node12;
			case 2:
				return node11;
			case 3:
				return node10;
			case 4:
				return node9;
			case 5:
				return node8;
			case 6:
				return node7;
			case 7:
				return node6;
			case 8:
				return node5;
			case 9:
				return node4;
			case 10:
				return node3;
			case 11:
				return node2;
			case 12:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12, node13);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 13;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 3;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 1:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 2:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf13x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12, node13);
			case 1:
				return nodeOf13x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12, node13);
			case 2:
				return nodeOf13x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12, node13);
			case 3:
				return nodeOf13x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12, node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf13x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 1:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			case 2:
				return nodeOf13x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1, node2,
						node3, node4, node5, node6, node7, node8, node9, node10, node11, node12,
						node13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 1:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 2:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 3:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node, node5, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 4:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node, node6, node7, node8, node9, node10,
						node11, node12, node13);
			case 5:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node, node7, node8, node9, node10,
						node11, node12, node13);
			case 6:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node, node8, node9, node10,
						node11, node12, node13);
			case 7:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node, node9, node10,
						node11, node12, node13);
			case 8:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node, node10,
						node11, node12, node13);
			case 9:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node,
						node11, node12, node13);
			case 10:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node, node12, node13);
			case 11:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node, node13);
			case 12:
				return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 2:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 3:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 4:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 5:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 6:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11, node12, node13);
				case 7:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11, node12, node13);
				case 8:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11, node12, node13);
				case 9:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11, node12, node13);
				case 10:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11, node12, node13);
				case 11:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node, node12, node13);
				case 12:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node, node13);
				case 13:
					return nodeOf14x2(mutator, nodeMap, dataMap, key2, val2, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 2:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 3:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 4:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 5:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 6:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11, node12, node13);
				case 7:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11, node12, node13);
				case 8:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11, node12, node13);
				case 9:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11, node12, node13);
				case 10:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11, node12, node13);
				case 11:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node, node12, node13);
				case 12:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node, node13);
				case 13:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key3, val3, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node,
							node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 1:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node, node2, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 2:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node, node3, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 3:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node, node4, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 4:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node, node5, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 5:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node, node6, node7, node8, node9, node10,
							node11, node12, node13);
				case 6:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node, node7, node8, node9, node10,
							node11, node12, node13);
				case 7:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node, node8, node9, node10,
							node11, node12, node13);
				case 8:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node, node9, node10,
							node11, node12, node13);
				case 9:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node, node10,
							node11, node12, node13);
				case 10:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node,
							node11, node12, node13);
				case 11:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node, node12, node13);
				case 12:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node, node13);
				case 13:
					return nodeOf14x2(mutator, nodeMap, dataMap, key1, val1, key2, val2, node1,
							node2, node3, node4, node5, node6, node7, node8, node9, node10, node11,
							node12, node13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node5, node6, node7, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node6, node7, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node7, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node8, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node9,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node10, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node11, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node12, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node13);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node13);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node13);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node13);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (valIndex) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;

		private Map4To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 8;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4);
			case 1:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4);
			case 2:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4);
			case 3:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4);
			case 1:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4);
			case 2:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4);
			case 3:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4);
			case 4:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4);
			case 1:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4);
			case 2:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4);
			case 3:
				return nodeOf0x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map4To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;

		private Map4To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 9;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1);
			case 1:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1);
			case 2:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1);
			case 3:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1);
			case 1:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1);
			case 2:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1);
			case 3:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1);
			case 4:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1);
			case 1:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1);
			case 2:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1);
			case 3:
				return nodeOf1x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1);
				case 1:
					return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4);
				case 1:
					return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4);
				case 2:
					return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4);
				case 3:
					return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4);
				case 4:
					return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map4To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 10;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2);
			case 1:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2);
			case 2:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2);
			case 3:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2);
			case 1:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2);
			case 2:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2);
			case 3:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2);
			case 4:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2);
			case 1:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2);
			case 2:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2);
			case 3:
				return nodeOf2x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2);
			case 1:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2);
				case 1:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2);
				case 2:
					return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2);
				case 1:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2);
				case 2:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2);
				case 3:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2);
				case 4:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1);
				case 1:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1);
				case 2:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1);
				case 3:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1);
				case 4:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map4To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 11;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3);
			case 1:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3);
			case 2:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3);
			case 3:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3);
			case 1:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3);
			case 2:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3);
			case 3:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3);
			case 4:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3);
			case 1:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3);
			case 2:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3);
			case 3:
				return nodeOf3x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3);
			case 1:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3);
			case 2:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2, node3);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2, node3);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node, node3);
				case 3:
					return nodeOf4x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2, node3);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2, node3);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node, node3);
				case 3:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2, node3);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2, node3);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node, node3);
				case 3:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2, node3);
				case 1:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2, node3);
				case 2:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node, node3);
				case 3:
					return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3);
				case 2:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3);
				case 3:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3);
				case 4:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3);
				case 2:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3);
				case 3:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3);
				case 4:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2);
				case 2:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2);
				case 3:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2);
				case 4:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map4To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4);
			case 1:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4);
			case 2:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4);
			case 3:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4);
			case 1:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4);
			case 2:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3, node4);
			case 3:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4);
			case 4:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4);
			case 1:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4);
			case 2:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4);
			case 3:
				return nodeOf4x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4);
			case 1:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4);
			case 2:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4);
			case 3:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4);
				case 3:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4);
				case 4:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4);
				case 3:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4);
				case 4:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4);
				case 3:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4);
				case 4:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3);
				case 3:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3);
				case 4:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map4To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4, node5);
				case 4:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4, node5);
				case 4:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4, node5);
				case 4:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node5);
				case 4:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4);
				case 4:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map4To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4, node5, node6);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4, node5, node6);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node5, node6);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node6);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map4To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4, node5, node6, node7);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node5, node6, node7);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node6, node7);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node7);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map4To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 4:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
						node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node, node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node, node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							node1, node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node, node1, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							node1, node2, node3, node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node5, node6, node7, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node6, node7, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node7, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node8);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node8);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node8);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node8);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map4To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
						node9);
			case 1:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
						node9);
			case 2:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
						node9);
			case 3:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 4:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6, node7, node8, node9);
			case 5:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node, node7, node8, node9);
			case 6:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node, node8, node9);
			case 7:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node, node9);
			case 8:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9);
				case 3:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9);
				case 5:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9);
				case 6:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9);
				case 7:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9);
				case 8:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9);
				case 9:
					return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9);
				case 3:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9);
				case 5:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9);
				case 6:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9);
				case 7:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9);
				case 8:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9);
				case 9:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9);
				case 3:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9);
				case 5:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9);
				case 6:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9);
				case 7:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9);
				case 8:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9);
				case 9:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 1:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 2:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9);
				case 3:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9);
				case 5:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9);
				case 6:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9);
				case 7:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9);
				case 8:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9);
				case 9:
					return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4, node5, node6, node7, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4, node5, node6, node7, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4, node5, node6, node7, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node5, node6, node7, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node5, node6, node7, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node6, node7, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node6, node7, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node7, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node7, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node8,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node8,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node9);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
							node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
							node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map4To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 1:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 2:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 3:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 1:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 2:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 3:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 4:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf10x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 1:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 2:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6, node7, node8, node9,
						node10);
			case 3:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6, node7, node8, node9,
						node10);
			case 4:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6, node7, node8, node9,
						node10);
			case 5:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node, node7, node8, node9,
						node10);
			case 6:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node, node8, node9,
						node10);
			case 7:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node, node9,
						node10);
			case 8:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
						node10);
			case 9:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 3:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10);
				case 5:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10);
				case 6:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10);
				case 7:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10);
				case 8:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10);
				case 9:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10);
				case 10:
					return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 3:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10);
				case 5:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10);
				case 6:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10);
				case 7:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10);
				case 8:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10);
				case 9:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10);
				case 10:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 3:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10);
				case 5:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10);
				case 6:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10);
				case 7:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10);
				case 8:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10);
				case 9:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10);
				case 10:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 1:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 2:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 3:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10);
				case 5:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10);
				case 6:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10);
				case 7:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10);
				case 8:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10);
				case 9:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10);
				case 10:
					return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node2, node3, node4, node5, node6, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node3, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node3, node4, node5, node6, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node4, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node4, node5, node6, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node5, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node5, node6, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node6, node7, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node6, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node7, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node7, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node8,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node8,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node9, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
							node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node10);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
							node8, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
							node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To11Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		private Map4To11Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node11;
			case 1:
				return node10;
			case 2:
				return node9;
			case 3:
				return node8;
			case 4:
				return node7;
			case 5:
				return node6;
			case 6:
				return node5;
			case 7:
				return node4;
			case 8:
				return node3;
			case 9:
				return node2;
			case 10:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 11;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 1:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 2:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 3:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 1:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 2:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 3:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 4:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf11x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 1:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 2:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			case 3:
				return nodeOf11x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 1:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 2:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 3:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6, node7, node8, node9,
						node10, node11);
			case 4:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6, node7, node8, node9,
						node10, node11);
			case 5:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node, node7, node8, node9,
						node10, node11);
			case 6:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node, node8, node9,
						node10, node11);
			case 7:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node, node9,
						node10, node11);
			case 8:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
						node10, node11);
			case 9:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node, node11);
			case 10:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 3:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 4:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11);
				case 5:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11);
				case 6:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11);
				case 7:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11);
				case 8:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11);
				case 9:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11);
				case 10:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11);
				case 11:
					return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 3:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 4:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11);
				case 5:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11);
				case 6:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11);
				case 7:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11);
				case 8:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11);
				case 9:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11);
				case 10:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11);
				case 11:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 3:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 4:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11);
				case 5:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11);
				case 6:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11);
				case 7:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11);
				case 8:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11);
				case 9:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11);
				case 10:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11);
				case 11:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 1:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 2:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 3:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11);
				case 4:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11);
				case 5:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11);
				case 6:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11);
				case 7:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11);
				case 8:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11);
				case 9:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11);
				case 10:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11);
				case 11:
					return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map4To12Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;
		private final CompactMapNode node12;

		private Map4To12Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7, final CompactMapNode node8,
				final CompactMapNode node9, final CompactMapNode node10,
				final CompactMapNode node11, final CompactMapNode node12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
			this.node12 = node12;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node12;
			case 1:
				return node11;
			case 2:
				return node10;
			case 3:
				return node9;
			case 4:
				return node8;
			case 5:
				return node7;
			case 6:
				return node6;
			case 7:
				return node5;
			case 8:
				return node4;
			case 9:
				return node3;
			case 10:
				return node2;
			case 11:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11, node12);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 12;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 4;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 1:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 2:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 3:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf12x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11, node12);
			case 1:
				return nodeOf12x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11, node12);
			case 2:
				return nodeOf12x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11, node12);
			case 3:
				return nodeOf12x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11, node12);
			case 4:
				return nodeOf12x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf12x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 1:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 2:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			case 3:
				return nodeOf12x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						node1, node2, node3, node4, node5, node6, node7, node8, node9, node10,
						node11, node12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 1:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 2:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node, node4, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 3:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node, node5, node6, node7, node8, node9,
						node10, node11, node12);
			case 4:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node, node6, node7, node8, node9,
						node10, node11, node12);
			case 5:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node, node7, node8, node9,
						node10, node11, node12);
			case 6:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node, node8, node9,
						node10, node11, node12);
			case 7:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node, node9,
						node10, node11, node12);
			case 8:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
						node10, node11, node12);
			case 9:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node, node11, node12);
			case 10:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node, node12);
			case 11:
				return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 3:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 4:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 5:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11, node12);
				case 6:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11, node12);
				case 7:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11, node12);
				case 8:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11, node12);
				case 9:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11, node12);
				case 10:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11, node12);
				case 11:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node, node12);
				case 12:
					return nodeOf13x3(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 3:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 4:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 5:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11, node12);
				case 6:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11, node12);
				case 7:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11, node12);
				case 8:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11, node12);
				case 9:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11, node12);
				case 10:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11, node12);
				case 11:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node, node12);
				case 12:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 3:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 4:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 5:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11, node12);
				case 6:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11, node12);
				case 7:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11, node12);
				case 8:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11, node12);
				case 9:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11, node12);
				case 10:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11, node12);
				case 11:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node, node12);
				case 12:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node, node1, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 1:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node, node2, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 2:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node, node3, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 3:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node, node4, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 4:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node, node5, node6, node7, node8,
							node9, node10, node11, node12);
				case 5:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node, node6, node7, node8,
							node9, node10, node11, node12);
				case 6:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node, node7, node8,
							node9, node10, node11, node12);
				case 7:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node, node8,
							node9, node10, node11, node12);
				case 8:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node,
							node9, node10, node11, node12);
				case 9:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node, node10, node11, node12);
				case 10:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node, node11, node12);
				case 11:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node, node12);
				case 12:
					return nodeOf13x3(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, node1, node2, node3, node4, node5, node6, node7, node8, node9,
							node10, node11, node12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node4, node5, node6, node7,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node5, node6, node7,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node6, node7,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node7,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node8, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node9, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node10, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node11, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node12);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node12);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node12);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node12);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node12);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (valIndex) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;

		private Map5To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 10;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5);
			case 1:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5);
			case 2:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5);
			case 3:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5);
			case 4:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5);
			case 1:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5);
			case 2:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5);
			case 3:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5);
			case 4:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5);
			case 5:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5);
			case 1:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5);
			case 2:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5);
			case 3:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5);
			case 4:
				return nodeOf0x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map5To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;

		private Map5To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 11;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1);
			case 1:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1);
			case 2:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1);
			case 3:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1);
			case 4:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1);
			case 1:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1);
			case 2:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1);
			case 3:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1);
			case 4:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1);
			case 5:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1);
			case 1:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1);
			case 2:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1);
			case 3:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1);
			case 4:
				return nodeOf1x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1);
				case 1:
					return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5);
				case 1:
					return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5);
				case 2:
					return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5);
				case 3:
					return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5);
				case 4:
					return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5);
				case 5:
					return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map5To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2);
			case 1:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2);
			case 2:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2);
			case 3:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2);
			case 4:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2);
			case 1:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2);
			case 2:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2);
			case 3:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2);
			case 4:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2);
			case 5:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2);
			case 1:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2);
			case 2:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2);
			case 3:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2);
			case 4:
				return nodeOf2x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2);
			case 1:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2);
				case 1:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2);
				case 2:
					return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2);
				case 1:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2);
				case 2:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2);
				case 3:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2);
				case 4:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2);
				case 5:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1);
				case 1:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1);
				case 2:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1);
				case 3:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1);
				case 4:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1);
				case 5:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map5To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3);
			case 1:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3);
			case 2:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3);
			case 3:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3);
			case 4:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3);
			case 1:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3);
			case 2:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3);
			case 3:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3);
			case 4:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3);
			case 5:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3);
			case 1:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3);
			case 2:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3);
			case 3:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3);
			case 4:
				return nodeOf3x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3);
			case 1:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3);
			case 2:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2, node3);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2, node3);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node, node3);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2, node3);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2, node3);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node, node3);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2, node3);
				case 1:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2, node3);
				case 2:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node, node3);
				case 3:
					return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3);
				case 2:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3);
				case 3:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3);
				case 4:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3);
				case 5:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3);
				case 2:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3);
				case 3:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3);
				case 4:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3);
				case 5:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2);
				case 2:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2);
				case 3:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2);
				case 4:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2);
				case 5:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map5To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4);
			case 1:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4);
			case 2:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4);
			case 3:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4);
			case 4:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4);
			case 1:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4);
			case 2:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4);
			case 3:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4);
			case 4:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4);
			case 5:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4);
			case 1:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4);
			case 2:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4);
			case 3:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4);
			case 4:
				return nodeOf4x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4);
			case 1:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4);
			case 2:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4);
			case 3:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4);
				case 3:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4);
				case 4:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4);
				case 5:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4);
				case 3:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4);
				case 4:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4);
				case 5:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4);
				case 3:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4);
				case 4:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4);
				case 5:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3);
				case 3:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3);
				case 4:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3);
				case 5:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map5To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4, node5);
				case 4:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4, node5);
				case 5:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4, node5);
				case 4:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4, node5);
				case 5:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4, node5);
				case 4:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4, node5);
				case 5:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node5);
				case 4:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node5);
				case 5:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4);
				case 4:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4);
				case 5:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map5To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4, node5, node6);
				case 5:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4, node5, node6);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4, node5, node6);
				case 5:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4, node5, node6);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4, node5, node6);
				case 5:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node5, node6);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node5, node6);
				case 5:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node6);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node6);
				case 5:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5);
				case 5:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map5To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7);
			case 1:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7);
			case 2:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7);
			case 3:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7);
			case 4:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5, node6,
						node7);
			case 5:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5, node6,
						node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4, node5, node6,
							node7);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4, node5, node6,
							node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4, node5, node6,
							node7);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4, node5, node6,
							node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4, node5, node6,
							node7);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4, node5, node6,
							node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node5, node6,
							node7);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node5, node6,
							node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node6,
							node7);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node6,
							node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node7);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map5To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 1:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 2:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 3:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 4:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
						node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8);
			case 1:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8);
			case 2:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8);
			case 3:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8);
			case 4:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8);
			case 5:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5, node6,
						node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf8x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
						node8);
			case 1:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
						node8);
			case 2:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
						node8);
			case 3:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
						node8);
			case 4:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
						node8);
			case 5:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
						node8);
			case 6:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
						node8);
			case 7:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7,
							node8);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7,
							node8);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7,
							node8);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7,
							node8);
				case 4:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7,
							node8);
				case 5:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7,
							node8);
				case 6:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7,
							node8);
				case 7:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node,
							node8);
				case 8:
					return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node8,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7,
							node8);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7,
							node8);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7,
							node8);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7,
							node8);
				case 4:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7,
							node8);
				case 5:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7,
							node8);
				case 6:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7,
							node8);
				case 7:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node,
							node8);
				case 8:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node8,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7,
							node8);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7,
							node8);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7,
							node8);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7,
							node8);
				case 4:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7,
							node8);
				case 5:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7,
							node8);
				case 6:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7,
							node8);
				case 7:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node,
							node8);
				case 8:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node8,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node, node1, node2, node3, node4, node5, node6, node7,
							node8);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node, node2, node3, node4, node5, node6, node7,
							node8);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node, node3, node4, node5, node6, node7,
							node8);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node, node4, node5, node6, node7,
							node8);
				case 4:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node, node5, node6, node7,
							node8);
				case 5:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node, node6, node7,
							node8);
				case 6:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node6, node, node7,
							node8);
				case 7:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node,
							node8);
				case 8:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, node1, node2, node3, node4, node5, node6, node7, node8,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node, node1, node2, node3, node4, node5, node6, node7,
							node8);
				case 1:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node, node2, node3, node4, node5, node6, node7,
							node8);
				case 2:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node, node3, node4, node5, node6, node7,
							node8);
				case 3:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node, node4, node5, node6, node7,
							node8);
				case 4:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node, node5, node6, node7,
							node8);
				case 5:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node, node6, node7,
							node8);
				case 6:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node6, node, node7,
							node8);
				case 7:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node6, node7, node,
							node8);
				case 8:
					return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, node1, node2, node3, node4, node5, node6, node7, node8,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4, node5, node6,
							node7, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4, node5, node6,
							node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4, node5, node6,
							node7, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4, node5, node6,
							node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4, node5, node6,
							node7, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4, node5, node6,
							node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node5, node6,
							node7, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node5, node6,
							node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node6,
							node7, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node6,
							node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node7, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node8);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node7);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map5To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 1:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 2:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 3:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 4:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9);
			case 1:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9);
			case 2:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9);
			case 3:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9);
			case 4:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9);
			case 5:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5, node6,
						node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 1:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
						node8, node9);
			case 2:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
						node8, node9);
			case 3:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
						node8, node9);
			case 4:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
						node8, node9);
			case 5:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
						node8, node9);
			case 6:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
						node8, node9);
			case 7:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node, node9);
			case 8:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9);
				case 6:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9);
				case 7:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9);
				case 8:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9);
				case 9:
					return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9);
				case 6:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9);
				case 7:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9);
				case 8:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9);
				case 9:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9);
				case 6:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9);
				case 7:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9);
				case 8:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9);
				case 9:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9);
				case 6:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9);
				case 7:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9);
				case 8:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9);
				case 9:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9);
				case 6:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9);
				case 7:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9);
				case 8:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9);
				case 9:
					return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4, node5, node6,
							node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4, node5, node6,
							node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4, node5, node6,
							node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node5, node6,
							node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node6,
							node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map5To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9, final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 1:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 2:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 3:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 4:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9, node10);
			case 4:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9, node10);
			case 5:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5, node6,
						node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf10x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 1:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 2:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 3:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			case 4:
				return nodeOf10x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 1:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 2:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
						node8, node9, node10);
			case 3:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
						node8, node9, node10);
			case 4:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
						node8, node9, node10);
			case 5:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
						node8, node9, node10);
			case 6:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
						node8, node9, node10);
			case 7:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node, node9, node10);
			case 8:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node, node10);
			case 9:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10);
				case 6:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10);
				case 7:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10);
				case 8:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10);
				case 9:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10);
				case 10:
					return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10);
				case 6:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10);
				case 7:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10);
				case 8:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10);
				case 9:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10);
				case 10:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10);
				case 6:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10);
				case 7:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10);
				case 8:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10);
				case 9:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10);
				case 10:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10);
				case 6:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10);
				case 7:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10);
				case 8:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10);
				case 9:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10);
				case 10:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10);
				case 6:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10);
				case 7:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10);
				case 8:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10);
				case 9:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10);
				case 10:
					return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node2, node3, node4, node5, node6,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node3, node4, node5, node6,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node4, node5, node6,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node5, node6,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node6,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node7, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node7, node8, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map5To11Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;
		private final CompactMapNode node11;

		private Map5To11Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10, final CompactMapNode node11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
			this.node11 = node11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 21;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node11;
			case 1:
				return node10;
			case 2:
				return node9;
			case 3:
				return node8;
			case 4:
				return node7;
			case 5:
				return node6;
			case 6:
				return node5;
			case 7:
				return node4;
			case 8:
				return node3;
			case 9:
				return node2;
			case 10:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10, node11);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 11;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 5;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 1:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 2:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 3:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 4:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf11x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11);
			case 1:
				return nodeOf11x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11);
			case 2:
				return nodeOf11x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10, node11);
			case 3:
				return nodeOf11x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9, node10, node11);
			case 4:
				return nodeOf11x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, node1, node2, node3, node4, node5, node6,
						node7, node8, node9, node10, node11);
			case 5:
				return nodeOf11x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, node1, node2, node3, node4, node5, node6,
						node7, node8, node9, node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf11x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 1:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 2:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 3:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			case 4:
				return nodeOf11x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, node1, node2, node3, node4, node5, node6, node7, node8, node9,
						node10, node11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 1:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node, node3, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 2:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node, node4, node5, node6, node7,
						node8, node9, node10, node11);
			case 3:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node, node5, node6, node7,
						node8, node9, node10, node11);
			case 4:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node, node6, node7,
						node8, node9, node10, node11);
			case 5:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node7,
						node8, node9, node10, node11);
			case 6:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
						node8, node9, node10, node11);
			case 7:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node, node9, node10, node11);
			case 8:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node, node10, node11);
			case 9:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node, node11);
			case 10:
				return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x4(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 4:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node, node5, node6,
							node7, node8, node9, node10, node11);
				case 5:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node, node6,
							node7, node8, node9, node10, node11);
				case 6:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node,
							node7, node8, node9, node10, node11);
				case 7:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node, node8, node9, node10, node11);
				case 8:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node, node9, node10, node11);
				case 9:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node, node10, node11);
				case 10:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node, node11);
				case 11:
					return nodeOf12x4(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, node1, node2, node3, node4, node5, node6, node7,
							node8, node9, node10, node11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node2, node3, node4, node5,
							node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node3, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node3, node4, node5,
							node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node3, node4, node5,
							node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node3, node4, node5,
							node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node4, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node4, node5,
							node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node4, node5,
							node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node4, node5,
							node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node5, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node5,
							node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node5,
							node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node5,
							node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node6,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node6, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node6, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node6, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node7, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node7, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node5, node7, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node5, node7, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node8, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node8, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node5, node6, node8, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node5, node6, node8, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node9, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node9, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node9, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node5, node6, node7, node9, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node10, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node10, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node10, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node5, node6, node7, node8, node10, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node11);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node11);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node11);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node11);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node11);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node11);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (valIndex) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;

		private Map6To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 12;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6);
			case 1:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6);
			case 2:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6);
			case 3:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6);
			case 4:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6);
			case 5:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6);
			case 1:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6);
			case 2:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6);
			case 3:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6);
			case 4:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6);
			case 5:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6);
			case 6:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6);
			case 1:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6);
			case 2:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6);
			case 3:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6);
			case 4:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6);
			case 5:
				return nodeOf0x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map6To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;

		private Map6To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 13;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1);
			case 1:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1);
			case 2:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1);
			case 3:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1);
			case 4:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1);
			case 5:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1);
			case 1:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1);
			case 2:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1);
			case 3:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1);
			case 4:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1);
			case 5:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1);
			case 6:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1);
			case 1:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1);
			case 2:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1);
			case 3:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1);
			case 4:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1);
			case 5:
				return nodeOf1x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1);
				case 1:
					return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6);
				case 1:
					return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6);
				case 2:
					return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6);
				case 3:
					return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6);
				case 4:
					return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6);
				case 5:
					return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6);
				case 6:
					return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map6To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2);
			case 1:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2);
			case 2:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2);
			case 3:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2);
			case 4:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2);
			case 5:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2);
			case 1:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2);
			case 2:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2);
			case 3:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2);
			case 4:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2);
			case 5:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2);
			case 6:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2);
			case 1:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2);
			case 2:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2);
			case 3:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2);
			case 4:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2);
			case 5:
				return nodeOf2x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2);
			case 1:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2);
				case 1:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2);
				case 2:
					return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2);
				case 1:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2);
				case 2:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2);
				case 3:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2);
				case 4:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2);
				case 5:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2);
				case 6:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1);
				case 1:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1);
				case 2:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1);
				case 3:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1);
				case 4:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1);
				case 5:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1);
				case 6:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map6To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 1:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 2:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 3:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3);
			case 4:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3);
			case 5:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 1:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 2:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 3:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3);
			case 4:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3);
			case 5:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3);
			case 6:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3);
			case 1:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3);
			case 2:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3);
			case 3:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3);
			case 4:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3);
			case 5:
				return nodeOf3x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3);
			case 1:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3);
			case 2:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2, node3);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2, node3);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node, node3);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2, node3);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2, node3);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node, node3);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2, node3);
				case 1:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2, node3);
				case 2:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node, node3);
				case 3:
					return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3);
				case 2:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3);
				case 3:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3);
				case 4:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3);
				case 5:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3);
				case 6:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3);
				case 2:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3);
				case 3:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3);
				case 4:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3);
				case 5:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3);
				case 6:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2);
				case 2:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2);
				case 3:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2);
				case 4:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2);
				case 5:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2);
				case 6:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map6To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 1:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 2:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 3:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4);
			case 4:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4);
			case 5:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 1:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 2:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 3:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			case 4:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4);
			case 5:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4);
			case 6:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4);
			case 1:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4);
			case 2:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4);
			case 3:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4);
			case 4:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4);
			case 5:
				return nodeOf4x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4);
			case 1:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4);
			case 2:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4);
			case 3:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4);
				case 3:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4);
				case 4:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4);
				case 5:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4);
				case 6:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4);
				case 3:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4);
				case 4:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4);
				case 5:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4);
				case 6:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4);
				case 3:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4);
				case 4:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4);
				case 5:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4);
				case 6:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3);
				case 3:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3);
				case 4:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3);
				case 5:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3);
				case 6:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map6To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5);
			case 4:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
						node5);
			case 5:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
						node5);
			case 6:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
						node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5);
				case 4:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4,
							node5);
				case 5:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4,
							node5);
				case 6:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5);
				case 4:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4,
							node5);
				case 5:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4,
							node5);
				case 6:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5);
				case 4:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4,
							node5);
				case 5:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4,
							node5);
				case 6:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5);
				case 4:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node5);
				case 5:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node5);
				case 6:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4);
				case 4:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4);
				case 5:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4);
				case 6:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map6To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6);
			case 1:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6);
			case 2:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6);
			case 3:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6);
			case 1:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6);
			case 2:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6);
			case 3:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6);
			case 4:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6);
			case 5:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
						node5, node6);
			case 6:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
						node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4,
							node5, node6);
				case 5:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4,
							node5, node6);
				case 6:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4,
							node5, node6);
				case 5:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4,
							node5, node6);
				case 6:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4,
							node5, node6);
				case 5:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4,
							node5, node6);
				case 6:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node5, node6);
				case 5:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node5, node6);
				case 6:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node6);
				case 5:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node6);
				case 6:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5);
				case 5:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5);
				case 6:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map6To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7);
			case 1:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7);
			case 2:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7);
			case 3:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7);
			case 4:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
						node6, node7);
			case 5:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
						node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7);
			case 1:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7);
			case 2:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7);
			case 3:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7);
			case 4:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7);
			case 5:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
						node5, node6, node7);
			case 6:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
						node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
						node6, node7);
			case 1:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
						node6, node7);
			case 2:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
						node6, node7);
			case 3:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
						node6, node7);
			case 4:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
						node6, node7);
			case 5:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node, node7);
			case 6:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7);
				case 5:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7);
				case 6:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7);
				case 7:
					return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7);
				case 5:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7);
				case 6:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7);
				case 7:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7);
				case 5:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7);
				case 6:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7);
				case 7:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7);
				case 5:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7);
				case 6:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7);
				case 7:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7);
				case 5:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7);
				case 6:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7);
				case 7:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7);
				case 1:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7);
				case 2:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7);
				case 3:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7);
				case 4:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7);
				case 5:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7);
				case 6:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7);
				case 7:
					return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4,
							node5, node6, node7);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4,
							node5, node6, node7);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4,
							node5, node6, node7);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node5, node6, node7);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node6, node7);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node7);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6);
				case 6:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map6To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 1:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 2:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 3:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 4:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 5:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
						node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 1:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 2:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 3:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 4:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 5:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 6:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 1:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 2:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 3:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 4:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8);
			case 5:
				return nodeOf8x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
						node6, node7, node8);
			case 1:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
						node6, node7, node8);
			case 2:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
						node6, node7, node8);
			case 3:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
						node6, node7, node8);
			case 4:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
						node6, node7, node8);
			case 5:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node, node7, node8);
			case 6:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node, node8);
			case 7:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7, node8);
				case 5:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7, node8);
				case 6:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7, node8);
				case 7:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8);
				case 8:
					return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7, node8);
				case 5:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7, node8);
				case 6:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7, node8);
				case 7:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8);
				case 8:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7, node8);
				case 5:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7, node8);
				case 6:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7, node8);
				case 7:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8);
				case 8:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7, node8);
				case 5:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7, node8);
				case 6:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7, node8);
				case 7:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8);
				case 8:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node, node5, node6,
							node7, node8);
				case 5:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node, node6,
							node7, node8);
				case 6:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node,
							node7, node8);
				case 7:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8);
				case 8:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node, node1, node2, node3, node4, node5, node6,
							node7, node8);
				case 1:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node, node2, node3, node4, node5, node6,
							node7, node8);
				case 2:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node, node3, node4, node5, node6,
							node7, node8);
				case 3:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node, node4, node5, node6,
							node7, node8);
				case 4:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node, node5, node6,
							node7, node8);
				case 5:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node, node6,
							node7, node8);
				case 6:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node,
							node7, node8);
				case 7:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node, node8);
				case 8:
					return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4,
							node5, node6, node7, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4,
							node5, node6, node7, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4,
							node5, node6, node7, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node5, node6, node7, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node6, node7, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node7, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node8);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node7);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map6To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 21;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 1:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 2:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 3:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 4:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 5:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 5:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 6:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 1:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 2:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 3:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 4:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			case 5:
				return nodeOf9x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 1:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
						node6, node7, node8, node9);
			case 2:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
						node6, node7, node8, node9);
			case 3:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
						node6, node7, node8, node9);
			case 4:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
						node6, node7, node8, node9);
			case 5:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node, node7, node8, node9);
			case 6:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node, node8, node9);
			case 7:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node, node9);
			case 8:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9);
				case 6:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9);
				case 7:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9);
				case 8:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9);
				case 9:
					return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9);
				case 6:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9);
				case 7:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9);
				case 8:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9);
				case 9:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9);
				case 6:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9);
				case 7:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9);
				case 8:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9);
				case 9:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9);
				case 6:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9);
				case 7:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9);
				case 8:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9);
				case 9:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9);
				case 6:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9);
				case 7:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9);
				case 8:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9);
				case 9:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 1:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9);
				case 2:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9);
				case 3:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9);
				case 4:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9);
				case 5:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9);
				case 6:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9);
				case 7:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9);
				case 8:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9);
				case 9:
					return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map6To10Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;
		private final CompactMapNode node10;

		private Map6To10Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8, final CompactMapNode node9,
				final CompactMapNode node10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
			this.node10 = node10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 22;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node10;
			case 1:
				return node9;
			case 2:
				return node8;
			case 3:
				return node7;
			case 4:
				return node6;
			case 5:
				return node5;
			case 6:
				return node4;
			case 7:
				return node3;
			case 8:
				return node2;
			case 9:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9,
					node10);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 10;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 6;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf10x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			case 6:
				return nodeOf10x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf10x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 1:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 2:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 3:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 4:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			case 5:
				return nodeOf10x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, node1, node2, node3, node4, node5, node6, node7,
						node8, node9, node10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node, node2, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 1:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node, node3, node4, node5,
						node6, node7, node8, node9, node10);
			case 2:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node, node4, node5,
						node6, node7, node8, node9, node10);
			case 3:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node5,
						node6, node7, node8, node9, node10);
			case 4:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
						node6, node7, node8, node9, node10);
			case 5:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node, node7, node8, node9, node10);
			case 6:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node, node8, node9, node10);
			case 7:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node, node9, node10);
			case 8:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node, node10);
			case 9:
				return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x5(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node, node1, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 1:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node, node2, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 2:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node, node3, node4, node5,
							node6, node7, node8, node9, node10);
				case 3:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node, node4, node5,
							node6, node7, node8, node9, node10);
				case 4:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node, node5,
							node6, node7, node8, node9, node10);
				case 5:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node,
							node6, node7, node8, node9, node10);
				case 6:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node, node7, node8, node9, node10);
				case 7:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node, node8, node9, node10);
				case 8:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node8, node, node9, node10);
				case 9:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node, node10);
				case 10:
					return nodeOf11x5(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, node1, node2, node3, node4, node5, node6,
							node7, node8, node9, node10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node2, node3, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node3, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node4,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node5, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node6, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node7, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node8, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node7, node9, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node10);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (valIndex) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;

		private Map7To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 14;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7);
			case 1:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7);
			case 2:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7);
			case 3:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7);
			case 4:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7);
			case 5:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7);
			case 6:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7);
			case 1:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7);
			case 2:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7);
			case 3:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7);
			case 4:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7);
			case 5:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7);
			case 6:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7);
			case 7:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7);
			case 1:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7);
			case 2:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7);
			case 3:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7);
			case 4:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7);
			case 5:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7);
			case 6:
				return nodeOf0x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map7To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;

		private Map7To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 15;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 1:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 2:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 3:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1);
			case 4:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1);
			case 5:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1);
			case 6:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 1:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 2:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 3:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1);
			case 4:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1);
			case 5:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1);
			case 6:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1);
			case 7:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1);
			case 1:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1);
			case 2:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1);
			case 3:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1);
			case 4:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1);
			case 5:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1);
			case 6:
				return nodeOf1x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1);
				case 1:
					return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7);
				case 1:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7);
				case 2:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7);
				case 3:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7);
				case 4:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7);
				case 5:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7);
				case 6:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7);
				case 7:
					return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map7To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 1:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 2:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 3:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2);
			case 4:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2);
			case 5:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2);
			case 6:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 1:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 2:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 3:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			case 4:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2);
			case 5:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2);
			case 6:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2);
			case 7:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2);
			case 1:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2);
			case 2:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2);
			case 3:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2);
			case 4:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2);
			case 5:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2);
			case 6:
				return nodeOf2x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2);
			case 1:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2);
				case 1:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2);
				case 2:
					return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2);
				case 1:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2);
				case 2:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2);
				case 3:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2);
				case 4:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2);
				case 5:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2);
				case 6:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2);
				case 7:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
				case 1:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
				case 2:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1);
				case 3:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1);
				case 4:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1);
				case 5:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1);
				case 6:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1);
				case 7:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map7To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 1:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 2:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 3:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 4:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3);
			case 5:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3);
			case 6:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 1:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 2:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 3:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3);
			case 4:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3);
			case 5:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3);
			case 6:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3);
			case 7:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 1:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 2:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 3:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3);
			case 4:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3);
			case 5:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3);
			case 6:
				return nodeOf3x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3);
			case 1:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3);
			case 2:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2, node3);
				case 1:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2, node3);
				case 2:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node, node3);
				case 3:
					return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3);
				case 2:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3);
				case 3:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3);
				case 4:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3);
				case 5:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3);
				case 6:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3);
				case 7:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3);
				case 2:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3);
				case 3:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3);
				case 4:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3);
				case 5:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3);
				case 6:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3);
				case 7:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2);
				case 2:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2);
				case 3:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
				case 4:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2);
				case 5:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2);
				case 6:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2);
				case 7:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map7To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 1:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 2:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 3:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 4:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4);
			case 5:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4);
			case 6:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4);
			case 1:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4);
			case 2:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4);
			case 3:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4);
			case 4:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4);
			case 5:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3, node4);
			case 6:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3, node4);
			case 7:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 1:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 2:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 3:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			case 4:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3, node4);
			case 5:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3, node4);
			case 6:
				return nodeOf4x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4);
			case 1:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4);
			case 2:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4);
			case 3:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4);
				case 3:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3,
							node4);
				case 4:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3,
							node4);
				case 5:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3,
							node4);
				case 6:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3,
							node4);
				case 7:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4);
				case 3:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3,
							node4);
				case 4:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3,
							node4);
				case 5:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3,
							node4);
				case 6:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3,
							node4);
				case 7:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4);
				case 3:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node4);
				case 4:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node4);
				case 5:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node4);
				case 6:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node4);
				case 7:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3);
				case 3:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3);
				case 4:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3);
				case 5:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3);
				case 6:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3);
				case 7:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map7To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5);
			case 1:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5);
			case 2:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5);
			case 3:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5);
			case 4:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4,
						node5);
			case 5:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4,
						node5);
			case 6:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4,
						node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5);
			case 1:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5);
			case 2:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5);
			case 3:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5);
			case 4:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5);
			case 5:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3, node4, node5);
			case 6:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3, node4, node5);
			case 7:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4,
						node5);
			case 1:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4,
						node5);
			case 2:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4,
						node5);
			case 3:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
						node5);
			case 4:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
							node5);
				case 1:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
							node5);
				case 2:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
							node5);
				case 3:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
							node5);
				case 4:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
							node5);
				case 5:
					return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5);
				case 4:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5);
				case 5:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3,
							node4, node5);
				case 6:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3,
							node4, node5);
				case 7:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5);
				case 4:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5);
				case 5:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3,
							node4, node5);
				case 6:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3,
							node4, node5);
				case 7:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5);
				case 4:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5);
				case 5:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node4, node5);
				case 6:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node4, node5);
				case 7:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5);
				case 4:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5);
				case 5:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node5);
				case 6:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node5);
				case 7:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4);
				case 4:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4);
				case 5:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4);
				case 6:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4);
				case 7:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map7To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6);
			case 1:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6);
			case 2:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6);
			case 3:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6);
			case 4:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6);
			case 5:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4,
						node5, node6);
			case 6:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4,
						node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6);
			case 1:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6);
			case 2:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6);
			case 3:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6);
			case 4:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6);
			case 5:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6);
			case 6:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3, node4, node5, node6);
			case 7:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6);
			case 1:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6);
			case 2:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6);
			case 3:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6);
			case 4:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6);
			case 5:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
						node6);
			case 6:
				return nodeOf6x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4,
						node5, node6);
			case 1:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4,
						node5, node6);
			case 2:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4,
						node5, node6);
			case 3:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
						node5, node6);
			case 4:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node, node6);
			case 5:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
							node5, node6);
				case 1:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
							node5, node6);
				case 2:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
							node5, node6);
				case 3:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
							node5, node6);
				case 4:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
							node5, node6);
				case 5:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node, node6);
				case 6:
					return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6);
				case 5:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3,
							node4, node5, node6);
				case 6:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3,
							node4, node5, node6);
				case 7:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6);
				case 5:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3,
							node4, node5, node6);
				case 6:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3,
							node4, node5, node6);
				case 7:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6);
				case 5:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node4, node5, node6);
				case 6:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node4, node5, node6);
				case 7:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6);
				case 5:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node5, node6);
				case 6:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node5, node6);
				case 7:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6);
				case 5:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node6);
				case 6:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node6);
				case 7:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5);
				case 5:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5);
				case 6:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5);
				case 7:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map7To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 21;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			case 1:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			case 2:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			case 3:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			case 4:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			case 5:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			case 6:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4,
						node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7);
			case 1:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7);
			case 2:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7);
			case 3:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7);
			case 6:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3, node4, node5, node6, node7);
			case 7:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7);
			case 1:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7);
			case 2:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7);
			case 3:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7);
			case 4:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7);
			case 5:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
						node6, node7);
			case 6:
				return nodeOf7x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4,
						node5, node6, node7);
			case 1:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4,
						node5, node6, node7);
			case 2:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4,
						node5, node6, node7);
			case 3:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
						node5, node6, node7);
			case 4:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node, node6, node7);
			case 5:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node, node7);
			case 6:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
							node5, node6, node7);
				case 1:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
							node5, node6, node7);
				case 2:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
							node5, node6, node7);
				case 3:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
							node5, node6, node7);
				case 4:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
							node5, node6, node7);
				case 5:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node, node6, node7);
				case 6:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node6, node, node7);
				case 7:
					return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3,
							node4, node5, node6, node7);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3,
							node4, node5, node6, node7);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node4, node5, node6, node7);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node5, node6, node7);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node6, node7);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node7);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6);
				case 6:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node6);
				case 7:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map7To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 22;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 1:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 2:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 3:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 4:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 5:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 6:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4,
						node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 1:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 2:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 3:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 4:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 5:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8);
			case 6:
				return nodeOf8x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4,
						node5, node6, node7, node8);
			case 1:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4,
						node5, node6, node7, node8);
			case 2:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4,
						node5, node6, node7, node8);
			case 3:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
						node5, node6, node7, node8);
			case 4:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node, node6, node7, node8);
			case 5:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node, node7, node8);
			case 6:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node, node8);
			case 7:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node, node1, node2, node3, node4,
							node5, node6, node7, node8);
				case 1:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node, node2, node3, node4,
							node5, node6, node7, node8);
				case 2:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node, node3, node4,
							node5, node6, node7, node8);
				case 3:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node, node4,
							node5, node6, node7, node8);
				case 4:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node,
							node5, node6, node7, node8);
				case 5:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node, node6, node7, node8);
				case 6:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node6, node, node7, node8);
				case 7:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node6, node7, node, node8);
				case 8:
					return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
							node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3,
							node4, node5, node6, node7, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3,
							node4, node5, node6, node7, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node4, node5, node6, node7, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node5, node6, node7, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node6, node7, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node7, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node8);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node8);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node8);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node8);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node8);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node8);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node6, node8);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node6, node7);
				case 7:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map7To9Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;
		private final CompactMapNode node9;

		private Map7To9Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6, final CompactMapNode node7,
				final CompactMapNode node8, final CompactMapNode node9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
			this.node9 = node9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 23;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node9;
			case 1:
				return node8;
			case 2:
				return node7;
			case 3:
				return node6;
			case 4:
				return node5;
			case 5:
				return node4;
			case 6:
				return node3;
			case 7:
				return node2;
			case 8:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8, node9);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 9;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 7;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 5:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 6:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, node1, node2, node3, node4,
						node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf9x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
						node4, node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 5:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 6:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			case 7:
				return nodeOf9x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
						node3, node4, node5, node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf9x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 1:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 2:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 3:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 4:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 5:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			case 6:
				return nodeOf9x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, node1, node2, node3, node4, node5,
						node6, node7, node8, node9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node, node2, node3, node4,
						node5, node6, node7, node8, node9);
			case 1:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node3, node4,
						node5, node6, node7, node8, node9);
			case 2:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node4,
						node5, node6, node7, node8, node9);
			case 3:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
						node5, node6, node7, node8, node9);
			case 4:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node, node6, node7, node8, node9);
			case 5:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node, node7, node8, node9);
			case 6:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node, node8, node9);
			case 7:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node, node9);
			case 8:
				return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node, node1, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node, node3,
							node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
							node, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
							node5, node, node6, node7, node8, node9);
				case 6:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
							node5, node6, node, node7, node8, node9);
				case 7:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
							node5, node6, node7, node, node8, node9);
				case 8:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
							node5, node6, node7, node8, node, node9);
				case 9:
					return nodeOf10x6(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, node1, node2, node3, node4,
							node5, node6, node7, node8, node9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node2,
							node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node2, node3,
							node4, node5, node6, node7, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node2, node3,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node3, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node3,
							node4, node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node3,
							node4, node5, node6, node7, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node3,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node4, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node4, node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node4, node5, node6, node7, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node4, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node5, node6, node7, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node5, node6, node7, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node5, node6, node7, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node5, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node6, node7, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node6, node7, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node6, node7, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node6, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node7, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node7, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node7, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node7, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node8, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node8, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node8, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node8, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node8, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node8, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node6, node8, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node6, node8, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7, node9);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7, node9);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7, node9);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node9);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node9);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node9);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node9);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node6, node7, node9);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (valIndex) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, node1,
							node2, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, node1, node2,
							node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;

		private Map8To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 16;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 1:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 2:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 3:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8);
			case 4:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8);
			case 5:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8);
			case 6:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8);
			case 7:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 1:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 2:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 3:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			case 4:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8);
			case 5:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8);
			case 6:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8);
			case 7:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8);
			case 8:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8);
			case 1:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8);
			case 2:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8);
			case 3:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8);
			case 4:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8);
			case 5:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8);
			case 6:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8);
			case 7:
				return nodeOf0x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map8To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;

		private Map8To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 17;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 1:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 2:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 3:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 4:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1);
			case 5:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1);
			case 6:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1);
			case 7:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 1:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 2:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 3:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 4:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 5:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, node1);
			case 6:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, node1);
			case 7:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, node1);
			case 8:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 1:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 2:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 3:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1);
			case 4:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1);
			case 5:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1);
			case 6:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1);
			case 7:
				return nodeOf1x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1);
				case 1:
					return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
				case 1:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
				case 2:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
				case 3:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
				case 4:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8);
				case 5:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8);
				case 6:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8);
				case 7:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8);
				case 8:
					return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map8To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 1:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 2:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 3:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 4:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2);
			case 5:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2);
			case 6:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2);
			case 7:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2);
			case 1:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2);
			case 2:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2);
			case 3:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2);
			case 4:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2);
			case 5:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2);
			case 6:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2);
			case 7:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2);
			case 8:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 1:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 2:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 3:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			case 4:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2);
			case 5:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2);
			case 6:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2);
			case 7:
				return nodeOf2x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2);
			case 1:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2);
				case 1:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2);
				case 2:
					return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2);
				case 1:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2);
				case 2:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2);
				case 3:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2);
				case 4:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2);
				case 5:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2);
				case 6:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2);
				case 7:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2);
				case 8:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1);
				case 1:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1);
				case 2:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1);
				case 3:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1);
				case 4:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1);
				case 5:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1);
				case 6:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1);
				case 7:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1);
				case 8:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map8To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3);
			case 1:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3);
			case 2:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3);
			case 3:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3);
			case 4:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
						node3);
			case 5:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
						node3);
			case 6:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
						node3);
			case 7:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
						node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3);
			case 1:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3);
			case 2:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3);
			case 3:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3);
			case 4:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3);
			case 5:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2, node3);
			case 6:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2, node3);
			case 7:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2, node3);
			case 8:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 1:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 2:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 3:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 4:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3);
			case 5:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3);
			case 6:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3);
			case 7:
				return nodeOf3x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
						node3);
			case 1:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
						node3);
			case 2:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3);
				case 2:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3);
				case 3:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3);
				case 4:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3);
				case 5:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2, node3);
				case 6:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2, node3);
				case 7:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2, node3);
				case 8:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3);
				case 2:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3);
				case 3:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3);
				case 4:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3);
				case 5:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node3);
				case 6:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node3);
				case 7:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node3);
				case 8:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2);
				case 2:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2);
				case 3:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2);
				case 4:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2);
				case 5:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2);
				case 6:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2);
				case 7:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2);
				case 8:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map8To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4);
			case 1:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4);
			case 2:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4);
			case 3:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4);
			case 4:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4);
			case 5:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
						node3, node4);
			case 6:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
						node3, node4);
			case 7:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
						node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4);
			case 1:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4);
			case 2:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4);
			case 3:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4);
			case 4:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4);
			case 5:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4);
			case 6:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2, node3, node4);
			case 7:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2, node3, node4);
			case 8:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4);
			case 1:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4);
			case 2:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4);
			case 3:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4);
			case 4:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4);
			case 5:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3, node4);
			case 6:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3, node4);
			case 7:
				return nodeOf4x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
						node3, node4);
			case 1:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
						node3, node4);
			case 2:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node, node4);
			case 3:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
							node3, node4);
				case 1:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
							node3, node4);
				case 2:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
							node3, node4);
				case 3:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node, node4);
				case 4:
					return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4);
				case 3:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4);
				case 4:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4);
				case 5:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2, node3, node4);
				case 6:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2, node3, node4);
				case 7:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2, node3, node4);
				case 8:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4);
				case 3:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4);
				case 4:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4);
				case 5:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node3, node4);
				case 6:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node3, node4);
				case 7:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node3, node4);
				case 8:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4);
				case 3:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4);
				case 4:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4);
				case 5:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node4);
				case 6:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node4);
				case 7:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node4);
				case 8:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3);
				case 3:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3);
				case 4:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3);
				case 5:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3);
				case 6:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3);
				case 7:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3);
				case 8:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map8To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 21;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			case 2:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			case 3:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			case 4:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			case 5:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			case 6:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
						node3, node4, node5);
			case 7:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
						node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5);
			case 1:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5);
			case 2:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5);
			case 3:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5);
			case 1:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5);
			case 2:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5);
			case 3:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5);
			case 4:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5);
			case 5:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3, node4,
						node5);
			case 6:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3, node4,
						node5);
			case 7:
				return nodeOf5x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
						node3, node4, node5);
			case 2:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node, node4, node5);
			case 3:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node, node5);
			case 4:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
							node3, node4, node5);
				case 1:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
							node3, node4, node5);
				case 2:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
							node3, node4, node5);
				case 3:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node, node4, node5);
				case 4:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node, node5);
				case 5:
					return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 4:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 5:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 6:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2, node3, node4, node5);
				case 7:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2, node3, node4, node5);
				case 8:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 4:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 5:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 6:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node3, node4, node5);
				case 7:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node3, node4, node5);
				case 8:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 4:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 5:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 6:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node4, node5);
				case 7:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node4, node5);
				case 8:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 4:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 5:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 6:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node5);
				case 7:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node5);
				case 8:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 4:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 5:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 6:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4);
				case 7:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4);
				case 8:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map8To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 22;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 2:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 3:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 4:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 5:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 6:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
						node3, node4, node5, node6);
			case 7:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
						node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 1:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 2:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 3:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 4:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 5:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 6:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3, node4,
						node5, node6);
			case 7:
				return nodeOf6x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
						node3, node4, node5, node6);
			case 2:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node, node4, node5, node6);
			case 3:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node, node5, node6);
			case 4:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node, node6);
			case 5:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
							node3, node4, node5, node6);
				case 1:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
							node3, node4, node5, node6);
				case 2:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
							node3, node4, node5, node6);
				case 3:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node, node4, node5, node6);
				case 4:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node, node5, node6);
				case 5:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node, node6);
				case 6:
					return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 5:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 6:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2, node3, node4, node5, node6);
				case 7:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2, node3, node4, node5, node6);
				case 8:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 5:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 6:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node3, node4, node5, node6);
				case 7:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node3, node4, node5, node6);
				case 8:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 5:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 6:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node4, node5, node6);
				case 7:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node4, node5, node6);
				case 8:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 5:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 6:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node5, node6);
				case 7:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node5, node6);
				case 8:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 5:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 6:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node6);
				case 7:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node6);
				case 8:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 5:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 6:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node5);
				case 7:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node5);
				case 8:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map8To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 23;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 6:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			case 7:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
						node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 1:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 2:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 3:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 4:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 5:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 6:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3, node4,
						node5, node6, node7);
			case 7:
				return nodeOf7x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
						node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node, node4, node5, node6, node7);
			case 3:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node, node5, node6, node7);
			case 4:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node, node6, node7);
			case 5:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node, node7);
			case 6:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
							node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
							node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
							node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2, node3, node4, node5, node6, node7);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node3, node4, node5, node6, node7);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node4, node5, node6, node7);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node5, node6, node7);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node6, node7);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node5, node7);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 6:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 7:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node5, node6);
				case 8:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map8To8Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;
		private final CompactMapNode node8;

		private Map8To8Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5, final CompactMapNode node6,
				final CompactMapNode node7, final CompactMapNode node8) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
			this.node8 = node8;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 24;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node8;
			case 1:
				return node7;
			case 2:
				return node6;
			case 3:
				return node5;
			case 4:
				return node4;
			case 5:
				return node3;
			case 6:
				return node2;
			case 7:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7, node8);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 8;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 8;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, node1, node2,
						node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf8x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val, key3,
						val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
						node2, node3, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 4:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 5:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 6:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 7:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
						node1, node2, node3, node4, node5, node6, node7, node8);
			case 8:
				return nodeOf8x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
						node1, node2, node3, node4, node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf8x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 1:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 2:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 3:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 4:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 5:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 6:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3, node4,
						node5, node6, node7, node8);
			case 7:
				return nodeOf8x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3, node4,
						node5, node6, node7, node8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node2,
						node3, node4, node5, node6, node7, node8);
			case 1:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node,
						node3, node4, node5, node6, node7, node8);
			case 2:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node, node4, node5, node6, node7, node8);
			case 3:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node, node5, node6, node7, node8);
			case 4:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node, node6, node7, node8);
			case 5:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node, node7, node8);
			case 6:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node, node8);
			case 7:
				return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node, node1, node2,
							node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node, node2,
							node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node,
							node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node, node5, node6, node7, node8);
				case 5:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node, node6, node7, node8);
				case 6:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node6, node, node7, node8);
				case 7:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node6, node7, node, node8);
				case 8:
					return nodeOf9x7(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, node1, node2, node3,
							node4, node5, node6, node7, node8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node2, node3, node4, node5, node6, node7, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node2, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node3, node4, node5, node6, node7, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node3, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node4, node5, node6, node7, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node4, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node5, node6, node7, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node5, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node6, node7, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node6, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node5, node7, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node5, node7, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node5, node6, node8);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node5, node6, node8);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (valIndex) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 7:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8,
							node1, node2, node3, node4, node5, node6, node7);
				case 8:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val,
							node1, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;

		private Map9To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 18;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 1:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 2:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 3:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 4:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9);
			case 5:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9);
			case 6:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9);
			case 7:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9);
			case 8:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9);
			case 1:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9);
			case 2:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9);
			case 3:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9);
			case 4:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9);
			case 5:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9);
			case 6:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9);
			case 7:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9);
			case 8:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9);
			case 9:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 1:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 2:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 3:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			case 4:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9);
			case 5:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9);
			case 6:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9);
			case 7:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9);
			case 8:
				return nodeOf0x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map9To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;

		private Map9To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 19;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1);
			case 1:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1);
			case 2:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1);
			case 3:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1);
			case 4:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1);
			case 5:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1);
			case 6:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1);
			case 7:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1);
			case 8:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1);
			case 1:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1);
			case 2:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1);
			case 3:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1);
			case 4:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1);
			case 5:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1);
			case 6:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1);
			case 7:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1);
			case 8:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1);
			case 9:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 1:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 2:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 3:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 4:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1);
			case 5:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1);
			case 6:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1);
			case 7:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1);
			case 8:
				return nodeOf1x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node, node1);
				case 1:
					return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9);
				case 1:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9);
				case 2:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9);
				case 3:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9);
				case 4:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9);
				case 5:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9);
				case 6:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9);
				case 7:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9);
				case 8:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9);
				case 9:
					return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map9To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2);
			case 1:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2);
			case 2:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2);
			case 3:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2);
			case 4:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2);
			case 5:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1, node2);
			case 6:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1, node2);
			case 7:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1, node2);
			case 8:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2);
			case 1:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2);
			case 2:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2);
			case 3:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2);
			case 4:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2);
			case 5:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2);
			case 6:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1, node2);
			case 7:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1, node2);
			case 8:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1, node2);
			case 9:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 1:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 2:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 3:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 4:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2);
			case 5:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2);
			case 6:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2);
			case 7:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2);
			case 8:
				return nodeOf2x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node, node2);
			case 1:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node,
							node1, node2);
				case 1:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node, node2);
				case 2:
					return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2);
				case 1:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2);
				case 2:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2);
				case 3:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2);
				case 4:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2);
				case 5:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node2);
				case 6:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node2);
				case 7:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node2);
				case 8:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node2);
				case 9:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1);
				case 1:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1);
				case 2:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1);
				case 3:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1);
				case 4:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1);
				case 5:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1);
				case 6:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1);
				case 7:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1);
				case 8:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1);
				case 9:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map9To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 21;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			case 1:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			case 2:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			case 3:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			case 4:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			case 5:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			case 6:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1, node2, node3);
			case 7:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1, node2, node3);
			case 8:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3);
			case 1:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3);
			case 2:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3);
			case 3:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3);
			case 4:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3);
			case 5:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3);
			case 6:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1, node2, node3);
			case 7:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1, node2, node3);
			case 8:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1, node2, node3);
			case 9:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3);
			case 1:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3);
			case 2:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3);
			case 3:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3);
			case 4:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3);
			case 5:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
						node3);
			case 6:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
						node3);
			case 7:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
						node3);
			case 8:
				return nodeOf3x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node, node2, node3);
			case 1:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node, node3);
			case 2:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node,
							node1, node2, node3);
				case 1:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node, node2, node3);
				case 2:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node, node3);
				case 3:
					return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3);
				case 2:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3);
				case 3:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3);
				case 4:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3);
				case 5:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3);
				case 6:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node2, node3);
				case 7:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node2, node3);
				case 8:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node2, node3);
				case 9:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3);
				case 2:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3);
				case 3:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3);
				case 4:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3);
				case 5:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3);
				case 6:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node3);
				case 7:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node3);
				case 8:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node3);
				case 9:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2);
				case 2:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2);
				case 3:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2);
				case 4:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2);
				case 5:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2);
				case 6:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2);
				case 7:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2);
				case 8:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2);
				case 9:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map9To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 22;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 1:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 2:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 3:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 4:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 5:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 6:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1, node2, node3, node4);
			case 7:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1, node2, node3, node4);
			case 8:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4);
			case 1:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4);
			case 2:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4);
			case 3:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4);
			case 4:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4);
			case 5:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4);
			case 6:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4);
			case 7:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1, node2, node3, node4);
			case 8:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1, node2, node3, node4);
			case 9:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 1:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 2:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 3:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 4:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 5:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 6:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
						node3, node4);
			case 7:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
						node3, node4);
			case 8:
				return nodeOf4x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node, node2, node3, node4);
			case 1:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node, node3, node4);
			case 2:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node, node4);
			case 3:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node,
							node1, node2, node3, node4);
				case 1:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node, node2, node3, node4);
				case 2:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node, node3, node4);
				case 3:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node, node4);
				case 4:
					return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4);
				case 3:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4);
				case 4:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4);
				case 5:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4);
				case 6:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node2, node3, node4);
				case 7:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node2, node3, node4);
				case 8:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node2, node3, node4);
				case 9:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4);
				case 3:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4);
				case 4:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4);
				case 5:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4);
				case 6:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node3, node4);
				case 7:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node3, node4);
				case 8:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node3, node4);
				case 9:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4);
				case 3:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4);
				case 4:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4);
				case 5:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4);
				case 6:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node4);
				case 7:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node4);
				case 8:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node4);
				case 9:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3);
				case 3:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3);
				case 4:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3);
				case 5:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3);
				case 6:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3);
				case 7:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3);
				case 8:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3);
				case 9:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map9To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 23;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 1:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 2:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 3:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 4:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 5:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 6:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
						node3, node4, node5);
			case 7:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
						node3, node4, node5);
			case 8:
				return nodeOf5x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node,
							node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5);
				case 4:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5);
				case 5:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5);
				case 6:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5);
				case 7:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node2, node3, node4, node5);
				case 8:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node2, node3, node4, node5);
				case 9:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5);
				case 4:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5);
				case 5:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5);
				case 6:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5);
				case 7:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node3, node4, node5);
				case 8:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node3, node4, node5);
				case 9:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5);
				case 4:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5);
				case 5:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5);
				case 6:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5);
				case 7:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node4, node5);
				case 8:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node4, node5);
				case 9:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5);
				case 4:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5);
				case 5:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5);
				case 6:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5);
				case 7:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node5);
				case 8:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node5);
				case 9:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4);
				case 4:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4);
				case 5:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4);
				case 6:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4);
				case 7:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node4);
				case 8:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node4);
				case 9:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map9To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 24;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 1:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 2:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 3:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 4:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 5:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 6:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 7:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
						node3, node4, node5, node6);
			case 8:
				return nodeOf6x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node,
							node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6);
				case 5:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6);
				case 6:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6);
				case 7:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node2, node3, node4, node5, node6);
				case 8:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node2, node3, node4, node5, node6);
				case 9:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5, node6);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6);
				case 5:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6);
				case 6:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6);
				case 7:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node3, node4, node5, node6);
				case 8:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node3, node4, node5, node6);
				case 9:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5, node6);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6);
				case 5:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6);
				case 6:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6);
				case 7:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node4, node5, node6);
				case 8:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node4, node5, node6);
				case 9:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5, node6);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6);
				case 5:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6);
				case 6:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6);
				case 7:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node5, node6);
				case 8:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node5, node6);
				case 9:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node6);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6);
				case 5:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6);
				case 6:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6);
				case 7:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node4, node6);
				case 8:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node4, node6);
				case 9:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5);
				case 5:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5);
				case 6:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5);
				case 7:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node4, node5);
				case 8:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node4, node5);
				case 9:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map9To7Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;
		private final CompactMapNode node7;

		private Map9To7Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final CompactMapNode node1, final CompactMapNode node2,
				final CompactMapNode node3, final CompactMapNode node4, final CompactMapNode node5,
				final CompactMapNode node6, final CompactMapNode node7) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
			this.node7 = node7;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 25;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node7;
			case 1:
				return node6;
			case 2:
				return node5;
			case 3:
				return node4;
			case 4:
				return node3;
			case 5:
				return node2;
			case 6:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6, node7);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 7;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 9;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf7x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, node1, node2, node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6, node7);
			case 6:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6, node7);
			case 7:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, node1, node2, node3, node4, node5, node6, node7);
			case 8:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, node1, node2, node3, node4, node5, node6, node7);
			case 9:
				return nodeOf7x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, node1, node2, node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf7x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 3:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 4:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 5:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 6:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 7:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1, node2,
						node3, node4, node5, node6, node7);
			case 8:
				return nodeOf7x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1, node2,
						node3, node4, node5, node6, node7);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node, node2, node3, node4, node5, node6, node7);
			case 1:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node, node3, node4, node5, node6, node7);
			case 2:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node, node4, node5, node6, node7);
			case 3:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node, node5, node6, node7);
			case 4:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node, node6, node7);
			case 5:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node, node7);
			case 6:
				return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node,
							node1, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node, node4, node5, node6, node7);
				case 4:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node, node5, node6, node7);
				case 5:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node5, node, node6, node7);
				case 6:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node5, node6, node, node7);
				case 7:
					return nodeOf8x8(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, node1,
							node2, node3, node4, node5, node6, node7, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node2, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6, node7);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6, node7);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node2, node3, node4, node5, node6, node7);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node2, node3, node4, node5, node6, node7);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node2, node3, node4, node5, node6, node7);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node2, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5, node6, node7);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5, node6, node7);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node3, node4, node5, node6, node7);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6, node7);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6, node7);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6, node7);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node3, node4, node5, node6, node7);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node3, node4, node5, node6, node7);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node3, node4, node5, node6, node7);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node3, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5, node6, node7);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5, node6, node7);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node4, node5, node6, node7);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6, node7);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6, node7);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6, node7);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node4, node5, node6, node7);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node4, node5, node6, node7);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node4, node5, node6, node7);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node4, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5, node6, node7);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5, node6, node7);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node5, node6, node7);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6, node7);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6, node7);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6, node7);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node5, node6, node7);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node5, node6, node7);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node5, node6, node7);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node5, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node6, node7);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node6, node7);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node6, node7);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6, node7);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6, node7);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6, node7);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node6, node7);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node4, node6, node7);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node4, node6, node7);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node4, node6, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5, node7);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5, node7);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5, node7);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node7);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node7);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node7);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node7);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node7);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node4, node5, node7);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node4, node5, node7);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (valIndex) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, node1, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6);
				case 6:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6);
				case 7:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, node1, node2, node3, node4, node5, node6);
				case 8:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, node1, node2, node3, node4, node5, node6);
				case 9:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, node1, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map10To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;

		private Map10To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 20;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10);
			case 1:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10);
			case 2:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10);
			case 3:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10);
			case 4:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10);
			case 5:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10);
			case 6:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10);
			case 7:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10);
			case 8:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10);
			case 9:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10);
			case 1:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10);
			case 2:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10);
			case 3:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10);
			case 4:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10);
			case 5:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10);
			case 6:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10);
			case 7:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10);
			case 8:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10);
			case 9:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10);
			case 10:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 1:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 2:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 3:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 4:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10);
			case 5:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10);
			case 6:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10);
			case 7:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10);
			case 8:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10);
			case 9:
				return nodeOf0x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map10To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;

		private Map10To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 21;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			case 1:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			case 2:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			case 3:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			case 4:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			case 5:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			case 6:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, node1);
			case 7:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, node1);
			case 8:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, node1);
			case 9:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1);
			case 1:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1);
			case 2:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1);
			case 3:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1);
			case 4:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1);
			case 5:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1);
			case 6:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, node1);
			case 7:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, node1);
			case 8:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, node1);
			case 9:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, node1);
			case 10:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1);
			case 1:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1);
			case 2:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1);
			case 3:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1);
			case 4:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1);
			case 5:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						node1);
			case 6:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						node1);
			case 7:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						node1);
			case 8:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						node1);
			case 9:
				return nodeOf1x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node, node1);
				case 1:
					return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10);
				case 1:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10);
				case 2:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10);
				case 3:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10);
				case 4:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10);
				case 5:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10);
				case 6:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10);
				case 7:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10);
				case 8:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10);
				case 9:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10);
				case 10:
					return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map10To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map10To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 22;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 1:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 2:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 3:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 4:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 5:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 6:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, node1, node2);
			case 7:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, node1, node2);
			case 8:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, node1, node2);
			case 9:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2);
			case 1:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2);
			case 2:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2);
			case 3:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2);
			case 4:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2);
			case 5:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2);
			case 6:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2);
			case 7:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, node1, node2);
			case 8:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, node1, node2);
			case 9:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, node1, node2);
			case 10:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 1:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 2:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 3:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 4:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 5:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 6:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						node1, node2);
			case 7:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						node1, node2);
			case 8:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						node1, node2);
			case 9:
				return nodeOf2x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node, node2);
			case 1:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node, node1, node2);
				case 1:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node, node2);
				case 2:
					return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2);
				case 1:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2);
				case 2:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2);
				case 3:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2);
				case 4:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2);
				case 5:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2);
				case 6:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node2);
				case 7:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node2);
				case 8:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node2);
				case 9:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node2);
				case 10:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1);
				case 1:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1);
				case 2:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1);
				case 3:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1);
				case 4:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1);
				case 5:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1);
				case 6:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1);
				case 7:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1);
				case 8:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1);
				case 9:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1);
				case 10:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map10To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map10To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 23;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 1:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 2:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 3:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 4:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 5:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 6:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			case 7:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, node1, node2, node3);
			case 8:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, node1, node2, node3);
			case 9:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3);
			case 1:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3);
			case 2:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3);
			case 3:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3);
			case 4:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3);
			case 5:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3);
			case 6:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3);
			case 7:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, node1, node2, node3);
			case 8:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, node1, node2, node3);
			case 9:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, node1, node2, node3);
			case 10:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 1:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 2:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 3:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 4:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 5:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 6:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						node1, node2, node3);
			case 7:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						node1, node2, node3);
			case 8:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						node1, node2, node3);
			case 9:
				return nodeOf3x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node, node2, node3);
			case 1:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node, node3);
			case 2:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node, node1, node2, node3);
				case 1:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node, node2, node3);
				case 2:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node, node3);
				case 3:
					return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3);
				case 2:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3);
				case 3:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3);
				case 4:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3);
				case 5:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3);
				case 6:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3);
				case 7:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node2, node3);
				case 8:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node2, node3);
				case 9:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node2, node3);
				case 10:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3);
				case 2:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3);
				case 3:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3);
				case 4:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3);
				case 5:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3);
				case 6:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3);
				case 7:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node3);
				case 8:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node3);
				case 9:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node3);
				case 10:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2);
				case 2:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2);
				case 3:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2);
				case 4:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2);
				case 5:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2);
				case 6:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2);
				case 7:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2);
				case 8:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2);
				case 9:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2);
				case 10:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map10To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map10To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 24;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 1:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 2:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 3:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 4:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 5:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 6:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 7:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, node1, node2, node3, node4);
			case 8:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, node1, node2, node3, node4);
			case 9:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4);
			case 1:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4);
			case 2:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4);
			case 3:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4);
			case 4:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4);
			case 5:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4);
			case 6:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4);
			case 7:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4);
			case 8:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, node1, node2, node3, node4);
			case 9:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, node1, node2, node3, node4);
			case 10:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 1:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 2:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 3:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 4:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 5:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 6:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 7:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						node1, node2, node3, node4);
			case 8:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						node1, node2, node3, node4);
			case 9:
				return nodeOf4x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node, node2, node3, node4);
			case 1:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node, node3, node4);
			case 2:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node, node4);
			case 3:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4);
				case 3:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4);
				case 4:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4);
				case 5:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4);
				case 6:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4);
				case 7:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node2, node3, node4);
				case 8:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node2, node3, node4);
				case 9:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node2, node3, node4);
				case 10:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4);
				case 3:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4);
				case 4:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4);
				case 5:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4);
				case 6:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4);
				case 7:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node3, node4);
				case 8:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node3, node4);
				case 9:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node3, node4);
				case 10:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4);
				case 3:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4);
				case 4:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4);
				case 5:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4);
				case 6:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4);
				case 7:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node4);
				case 8:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node4);
				case 9:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node4);
				case 10:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3);
				case 3:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3);
				case 4:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3);
				case 5:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3);
				case 6:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3);
				case 7:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node3);
				case 8:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node3);
				case 9:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node3);
				case 10:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map10To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map10To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 25;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4, node5);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4, node5);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4, node5);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5);
				case 4:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5);
				case 5:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5);
				case 6:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5);
				case 7:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5);
				case 8:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node2, node3, node4, node5);
				case 9:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node2, node3, node4, node5);
				case 10:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4, node5);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4, node5);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4, node5);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5);
				case 4:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5);
				case 5:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5);
				case 6:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5);
				case 7:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5);
				case 8:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node3, node4, node5);
				case 9:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node3, node4, node5);
				case 10:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4, node5);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4, node5);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4, node5);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5);
				case 4:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5);
				case 5:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5);
				case 6:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5);
				case 7:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5);
				case 8:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node4, node5);
				case 9:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node4, node5);
				case 10:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node5);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node5);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node5);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5);
				case 4:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5);
				case 5:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5);
				case 6:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5);
				case 7:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5);
				case 8:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node3, node5);
				case 9:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node3, node5);
				case 10:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4);
				case 4:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4);
				case 5:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4);
				case 6:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4);
				case 7:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4);
				case 8:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node3, node4);
				case 9:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node3, node4);
				case 10:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map10To6Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;
		private final CompactMapNode node6;

		private Map10To6Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4,
				final CompactMapNode node5, final CompactMapNode node6) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
			this.node6 = node6;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 26;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node6;
			case 1:
				return node5;
			case 2:
				return node4;
			case 3:
				return node3;
			case 4:
				return node2;
			case 5:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5, node6);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 6;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 10;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf6x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, node1, node2, node3, node4, node5, node6);
			case 10:
				return nodeOf6x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf6x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 2:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 3:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 4:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 5:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 6:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 7:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 8:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						node1, node2, node3, node4, node5, node6);
			case 9:
				return nodeOf6x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						node1, node2, node3, node4, node5, node6);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node, node2, node3, node4, node5, node6);
			case 1:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node, node3, node4, node5, node6);
			case 2:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node, node4, node5, node6);
			case 3:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node, node5, node6);
			case 4:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node, node6);
			case 5:
				return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10,
							val10, node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node, node1, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node, node3, node4, node5, node6);
				case 3:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node, node4, node5, node6);
				case 4:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node4, node, node5, node6);
				case 5:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node4, node5, node, node6);
				case 6:
					return nodeOf7x9(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
							key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							node1, node2, node3, node4, node5, node6, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 5:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 6:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 7:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 8:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node2, node3, node4, node5, node6);
				case 9:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node2, node3, node4, node5, node6);
				case 10:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node2, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 5:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 6:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 7:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 8:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node3, node4, node5, node6);
				case 9:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node3, node4, node5, node6);
				case 10:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node3, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 5:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 6:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 7:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 8:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node4, node5, node6);
				case 9:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node4, node5, node6);
				case 10:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node4, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 5:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 6:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 7:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 8:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node3, node5, node6);
				case 9:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node3, node5, node6);
				case 10:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node3, node5, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 5:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 6:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 7:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 8:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node3, node4, node6);
				case 9:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node3, node4, node6);
				case 10:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node3, node4, node6);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (valIndex) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 5:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 6:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 7:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 8:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, node1, node2, node3, node4, node5);
				case 9:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, node1, node2, node3, node4, node5);
				case 10:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, node1, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map11To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;

		private Map11To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 22;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 11;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 1:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 2:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 3:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 4:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 5:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 6:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11);
			case 7:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11);
			case 8:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11);
			case 9:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11);
			case 10:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11);
			case 1:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11);
			case 2:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11);
			case 3:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11);
			case 4:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11);
			case 5:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11);
			case 6:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11);
			case 7:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11);
			case 8:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11);
			case 9:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11);
			case 10:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11);
			case 11:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 1:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 2:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 3:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 4:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 5:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 6:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11);
			case 7:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11);
			case 8:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11);
			case 9:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11);
			case 10:
				return nodeOf0x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map11To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;

		private Map11To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 23;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 11;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 1:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 2:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 3:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 4:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 5:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 6:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			case 7:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, node1);
			case 8:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, node1);
			case 9:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, node1);
			case 10:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1);
			case 1:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1);
			case 2:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1);
			case 3:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1);
			case 4:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1);
			case 5:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1);
			case 6:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1);
			case 7:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, node1);
			case 8:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, node1);
			case 9:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, node1);
			case 10:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, node1);
			case 11:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 1:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 2:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 3:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 4:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 5:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 6:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, node1);
			case 7:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, node1);
			case 8:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, node1);
			case 9:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, node1);
			case 10:
				return nodeOf1x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node, node1);
				case 1:
					return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11);
				case 1:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11);
				case 2:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11);
				case 3:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11);
				case 4:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11);
				case 5:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11);
				case 6:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11);
				case 7:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11);
				case 8:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11);
				case 9:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11);
				case 10:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11);
				case 11:
					return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map11To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map11To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 24;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 11;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 1:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 2:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 3:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 4:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 5:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 6:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 7:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, node1, node2);
			case 8:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, node1, node2);
			case 9:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, node1, node2);
			case 10:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2);
			case 1:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2);
			case 2:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2);
			case 3:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2);
			case 4:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2);
			case 5:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2);
			case 6:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2);
			case 7:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2);
			case 8:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, node1, node2);
			case 9:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, node1, node2);
			case 10:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, node1, node2);
			case 11:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 1:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 2:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 3:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 4:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 5:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 6:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 7:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, node1, node2);
			case 8:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, node1, node2);
			case 9:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, node1, node2);
			case 10:
				return nodeOf2x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node, node2);
			case 1:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node, node1, node2);
				case 1:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node, node2);
				case 2:
					return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2);
				case 1:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2);
				case 2:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2);
				case 3:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2);
				case 4:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2);
				case 5:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2);
				case 6:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2);
				case 7:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node2);
				case 8:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node2);
				case 9:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node2);
				case 10:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node2);
				case 11:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1);
				case 1:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1);
				case 2:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1);
				case 3:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1);
				case 4:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1);
				case 5:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1);
				case 6:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1);
				case 7:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1);
				case 8:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1);
				case 9:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1);
				case 10:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1);
				case 11:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map11To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map11To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 25;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 11;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 1:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 2:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 3:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 4:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 5:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 6:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 7:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			case 8:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, node1, node2, node3);
			case 9:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, node1, node2, node3);
			case 10:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 1:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 2:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3);
			case 3:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3);
			case 4:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3);
			case 5:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3);
			case 6:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3);
			case 7:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3);
			case 8:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, node1, node2, node3);
			case 9:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, node1, node2, node3);
			case 10:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, node1, node2, node3);
			case 11:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 1:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 2:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 3:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 4:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 5:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 6:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 7:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, node1, node2, node3);
			case 8:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, node1, node2, node3);
			case 9:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, node1, node2, node3);
			case 10:
				return nodeOf3x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node, node2, node3);
			case 1:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node, node3);
			case 2:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node, node1, node2, node3);
				case 1:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node, node2, node3);
				case 2:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node, node3);
				case 3:
					return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3);
				case 2:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3);
				case 3:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3);
				case 4:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3);
				case 5:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3);
				case 6:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3);
				case 7:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3);
				case 8:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node2, node3);
				case 9:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node2, node3);
				case 10:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node2, node3);
				case 11:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3);
				case 2:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3);
				case 3:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3);
				case 4:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3);
				case 5:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3);
				case 6:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3);
				case 7:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3);
				case 8:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node3);
				case 9:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node3);
				case 10:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node3);
				case 11:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2);
				case 2:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2);
				case 3:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2);
				case 4:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2);
				case 5:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2);
				case 6:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2);
				case 7:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2);
				case 8:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node2);
				case 9:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node2);
				case 10:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node2);
				case 11:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map11To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map11To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 26;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 11;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 1:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 2:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 3:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 4:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 5:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 6:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 7:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 8:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, node1, node2, node3, node4);
			case 9:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, node1, node2, node3, node4);
			case 10:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 1:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 2:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 3:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 4:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 5:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 6:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 7:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 8:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4);
			case 9:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, node1, node2, node3, node4);
			case 10:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, node1, node2, node3, node4);
			case 11:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 1:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 2:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 3:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 4:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 5:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 6:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 7:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 8:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, node1, node2, node3, node4);
			case 9:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, node1, node2, node3, node4);
			case 10:
				return nodeOf4x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node, node2, node3, node4);
			case 1:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node, node3, node4);
			case 2:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node, node4);
			case 3:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 3:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 4:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 5:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 6:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 7:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 8:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node2, node3, node4);
				case 9:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node2, node3, node4);
				case 10:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node2, node3, node4);
				case 11:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 3:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 4:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 5:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 6:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 7:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 8:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node3, node4);
				case 9:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node3, node4);
				case 10:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node3, node4);
				case 11:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 3:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 4:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 5:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 6:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 7:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 8:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node2, node4);
				case 9:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node2, node4);
				case 10:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node2, node4);
				case 11:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node2, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 3:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 4:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 5:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 6:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 7:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 8:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node2, node3);
				case 9:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node2, node3);
				case 10:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node2, node3);
				case 11:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map11To5Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;
		private final CompactMapNode node5;

		private Map11To5Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3,
				final CompactMapNode node4, final CompactMapNode node5) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
			this.node5 = node5;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 27;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node5;
			case 1:
				return node4;
			case 2:
				return node3;
			case 3:
				return node2;
			case 4:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4, node5);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 5;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 11;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf5x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, node1, node2, node3, node4, node5);
			case 11:
				return nodeOf5x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf5x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 1:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 2:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 3:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 4:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 5:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 6:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 7:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 8:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, node1, node2, node3, node4, node5);
			case 9:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, node1, node2, node3, node4, node5);
			case 10:
				return nodeOf5x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, node1, node2, node3, node4, node5);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node, node2, node3, node4, node5);
			case 1:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node, node3, node4, node5);
			case 2:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node, node4, node5);
			case 3:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node, node5);
			case 4:
				return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node, node1, node2, node3, node4, node5);
				case 1:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node, node2, node3, node4, node5);
				case 2:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node, node3, node4, node5);
				case 3:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node3, node, node4, node5);
				case 4:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node3, node4, node, node5);
				case 5:
					return nodeOf6x10(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, node1, node2, node3, node4, node5, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3, node4, node5);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3, node4, node5);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node2, node3, node4, node5);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4,
							node5);
				case 4:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4,
							node5);
				case 5:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4,
							node5);
				case 6:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4,
							node5);
				case 7:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node2, node3, node4,
							node5);
				case 8:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node2, node3, node4, node5);
				case 9:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node2, node3, node4, node5);
				case 10:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node2, node3, node4, node5);
				case 11:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node2, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3, node4, node5);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3, node4, node5);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node3, node4, node5);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4,
							node5);
				case 4:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4,
							node5);
				case 5:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4,
							node5);
				case 6:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4,
							node5);
				case 7:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node3, node4,
							node5);
				case 8:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node3, node4, node5);
				case 9:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node3, node4, node5);
				case 10:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node3, node4, node5);
				case 11:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node3, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node4, node5);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node4, node5);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node4, node5);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4,
							node5);
				case 4:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4,
							node5);
				case 5:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4,
							node5);
				case 6:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4,
							node5);
				case 7:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node4,
							node5);
				case 8:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node2, node4, node5);
				case 9:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node2, node4, node5);
				case 10:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node2, node4, node5);
				case 11:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node2, node4, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3, node5);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3, node5);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3, node5);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node5);
				case 4:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node5);
				case 5:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node5);
				case 6:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node5);
				case 7:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node5);
				case 8:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node2, node3, node5);
				case 9:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node2, node3, node5);
				case 10:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node2, node3, node5);
				case 11:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node2, node3, node5);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (valIndex) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4);
				case 4:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4);
				case 5:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4);
				case 6:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4);
				case 7:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, node1, node2, node3,
							node4);
				case 8:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, node1, node2, node3, node4);
				case 9:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, node1, node2, node3, node4);
				case 10:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, node1, node2, node3, node4);
				case 11:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, node1, node2, node3, node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map12To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;

		private Map12To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 24;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 12;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 1:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 2:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 3:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 4:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 5:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 6:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 7:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12);
			case 8:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12);
			case 9:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12);
			case 10:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12);
			case 11:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12);
			case 1:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12);
			case 2:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12);
			case 3:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12);
			case 4:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12);
			case 5:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12);
			case 6:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12);
			case 7:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12);
			case 8:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12);
			case 9:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12);
			case 10:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12);
			case 11:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12);
			case 12:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 1:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 2:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 3:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 4:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 5:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 6:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 7:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12);
			case 8:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12);
			case 9:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12);
			case 10:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12);
			case 11:
				return nodeOf0x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map12To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;

		private Map12To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 25;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 12;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 1:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 2:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 3:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 4:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 5:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 6:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 7:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			case 8:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, node1);
			case 9:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, node1);
			case 10:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, node1);
			case 11:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 1:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 2:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1);
			case 3:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1);
			case 4:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1);
			case 5:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1);
			case 6:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1);
			case 7:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1);
			case 8:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, node1);
			case 9:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, node1);
			case 10:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, node1);
			case 11:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, node1);
			case 12:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 1:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 2:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 3:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 4:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 5:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 6:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 7:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, node1);
			case 8:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, node1);
			case 9:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, node1);
			case 10:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, node1);
			case 11:
				return nodeOf1x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node, node1);
				case 1:
					return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12);
				case 1:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12);
				case 2:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12);
				case 3:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12);
				case 4:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12);
				case 5:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12);
				case 6:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12);
				case 7:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12);
				case 8:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12);
				case 9:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12);
				case 10:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12);
				case 11:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12);
				case 12:
					return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map12To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map12To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 26;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 12;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 1:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 2:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 3:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 4:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 5:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 6:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 7:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 8:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, node1, node2);
			case 9:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, node1, node2);
			case 10:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, node1, node2);
			case 11:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 1:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 2:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 3:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 4:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 5:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 6:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 7:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 8:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2);
			case 9:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, node1, node2);
			case 10:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, node1, node2);
			case 11:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, node1, node2);
			case 12:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 1:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 2:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 3:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 4:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 5:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 6:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 7:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 8:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, node1, node2);
			case 9:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, node1, node2);
			case 10:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, node1, node2);
			case 11:
				return nodeOf2x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node, node2);
			case 1:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node, node1, node2);
				case 1:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node, node2);
				case 2:
					return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 1:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 2:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 3:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 4:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 5:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 6:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 7:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 8:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node2);
				case 9:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node2);
				case 10:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node2);
				case 11:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node2);
				case 12:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 1:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 2:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 3:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 4:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 5:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 6:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 7:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 8:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node1);
				case 9:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node1);
				case 10:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node1);
				case 11:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node1);
				case 12:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map12To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map12To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 27;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 12;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 1:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 2:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 3:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 4:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 5:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 6:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 7:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 8:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 9:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, node1, node2, node3);
			case 10:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, node1, node2, node3);
			case 11:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 1:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 2:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 3:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 4:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 5:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 6:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 7:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 8:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 9:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, node1, node2, node3);
			case 10:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, node1, node2, node3);
			case 11:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, node1, node2, node3);
			case 12:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 1:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 2:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 3:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 4:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 5:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 6:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 7:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 8:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, node1, node2, node3);
			case 9:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, node1, node2, node3);
			case 10:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, node1, node2, node3);
			case 11:
				return nodeOf3x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node, node2, node3);
			case 1:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node, node3);
			case 2:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node, node1, node2, node3);
				case 1:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node, node2, node3);
				case 2:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node2, node, node3);
				case 3:
					return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node2, node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2, node3);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2, node3);
				case 2:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2, node3);
				case 3:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3);
				case 4:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3);
				case 5:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3);
				case 6:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3);
				case 7:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3);
				case 8:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node2, node3);
				case 9:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node2, node3);
				case 10:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node2, node3);
				case 11:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node2, node3);
				case 12:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node3);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node3);
				case 2:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node3);
				case 3:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3);
				case 4:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3);
				case 5:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3);
				case 6:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3);
				case 7:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3);
				case 8:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node1, node3);
				case 9:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node1, node3);
				case 10:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node1, node3);
				case 11:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node1, node3);
				case 12:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
				case 2:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
				case 3:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2);
				case 4:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2);
				case 5:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2);
				case 6:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2);
				case 7:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2);
				case 8:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node1, node2);
				case 9:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node1, node2);
				case 10:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node1, node2);
				case 11:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node1, node2);
				case 12:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map12To4Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;
		private final CompactMapNode node4;

		private Map12To4Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final CompactMapNode node1,
				final CompactMapNode node2, final CompactMapNode node3, final CompactMapNode node4) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
			this.node4 = node4;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 28;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node4;
			case 1:
				return node3;
			case 2:
				return node2;
			case 3:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3, node4);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 4;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 12;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 1:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 2:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 3:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 4:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 5:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 6:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 7:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 8:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 9:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, node1, node2, node3, node4);
			case 10:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, node1, node2, node3, node4);
			case 11:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf4x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2, node3,
						node4);
			case 1:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2, node3,
						node4);
			case 2:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, node1, node2, node3,
						node4);
			case 3:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 4:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 5:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 6:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 7:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 8:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, node1, node2, node3, node4);
			case 9:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, node1, node2, node3,
						node4);
			case 10:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, node1, node2, node3,
						node4);
			case 11:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, node1, node2, node3,
						node4);
			case 12:
				return nodeOf4x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, node1, node2, node3,
						node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf4x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 1:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 2:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 3:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 4:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 5:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 6:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 7:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 8:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 9:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, node1, node2, node3, node4);
			case 10:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, node1, node2, node3, node4);
			case 11:
				return nodeOf4x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, node1, node2, node3, node4);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node, node2, node3, node4);
			case 1:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node, node3, node4);
			case 2:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node, node4);
			case 3:
				return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node, node1, node2, node3,
							node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node, node2, node3,
							node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node2, node, node3,
							node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node,
							node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, node1, node2, node3, node4,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node, node1, node2, node3, node4);
				case 1:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node, node2, node3, node4);
				case 2:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node2, node, node3, node4);
				case 3:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node2, node3, node, node4);
				case 4:
					return nodeOf5x11(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, node1, node2, node3, node4, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2, node3,
							node4);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2, node3,
							node4);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node2, node3,
							node4);
				case 3:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3, node4);
				case 4:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3, node4);
				case 5:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3, node4);
				case 6:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3, node4);
				case 7:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3, node4);
				case 8:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node2,
							node3, node4);
				case 9:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node2, node3,
							node4);
				case 10:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node2, node3,
							node4);
				case 11:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node2, node3,
							node4);
				case 12:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node2, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node3,
							node4);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node3,
							node4);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node3,
							node4);
				case 3:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3, node4);
				case 4:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3, node4);
				case 5:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3, node4);
				case 6:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3, node4);
				case 7:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3, node4);
				case 8:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node3, node4);
				case 9:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node1, node3,
							node4);
				case 10:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node1, node3,
							node4);
				case 11:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node1, node3,
							node4);
				case 12:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node1, node3,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
							node4);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
							node4);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
							node4);
				case 3:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node4);
				case 4:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node4);
				case 5:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node4);
				case 6:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node4);
				case 7:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node4);
				case 8:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node4);
				case 9:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node1, node2,
							node4);
				case 10:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node1, node2,
							node4);
				case 11:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node1, node2,
							node4);
				case 12:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node1, node2,
							node4);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (valIndex) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
							node3);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
							node3);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, node1, node2,
							node3);
				case 3:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
				case 4:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
				case 5:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
				case 6:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
				case 7:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
				case 8:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, node1,
							node2, node3);
				case 9:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, node1, node2,
							node3);
				case 10:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, node1, node2,
							node3);
				case 11:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, node1, node2,
							node3);
				case 12:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, node1, node2,
							node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map13To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;

		private Map13To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 26;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 13;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 1:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 2:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 3:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 4:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 5:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 6:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 7:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 8:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13);
			case 9:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13);
			case 10:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13);
			case 11:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13);
			case 12:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 1:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 2:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 3:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 4:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 5:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 6:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 7:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 8:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13);
			case 9:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13);
			case 10:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13);
			case 11:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13);
			case 12:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13);
			case 13:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 1:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 2:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 3:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 4:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 5:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 6:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 7:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 8:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13);
			case 9:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13);
			case 10:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13);
			case 11:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13);
			case 12:
				return nodeOf0x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map13To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final CompactMapNode node1;

		private Map13To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 27;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 13;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 1:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 2:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 3:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 4:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 5:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 6:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 7:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 8:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 9:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, node1);
			case 10:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, node1);
			case 11:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, node1);
			case 12:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 1:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 2:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 3:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 4:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 5:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 6:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 7:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 8:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 9:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, node1);
			case 10:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, node1);
			case 11:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, node1);
			case 12:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, node1);
			case 13:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 1:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 2:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 3:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 4:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 5:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 6:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 7:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 8:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, node1);
			case 9:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, node1);
			case 10:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, node1);
			case 11:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, node1);
			case 12:
				return nodeOf1x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node, node1);
				case 1:
					return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
				case 1:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
				case 2:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
				case 3:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13);
				case 4:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13);
				case 5:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13);
				case 6:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13);
				case 7:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13);
				case 8:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13, val13);
				case 9:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13);
				case 10:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13);
				case 11:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13);
				case 12:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13);
				case 13:
					return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map13To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map13To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 28;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 13;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 1:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 2:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 3:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 4:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 5:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 6:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 7:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 8:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 9:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, node1, node2);
			case 10:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, node1, node2);
			case 11:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, node1, node2);
			case 12:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2);
			case 1:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2);
			case 2:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2);
			case 3:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 4:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 5:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 6:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 7:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 8:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			case 9:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2);
			case 10:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, node1,
						node2);
			case 11:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, node1,
						node2);
			case 12:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, node1,
						node2);
			case 13:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, node1,
						node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 1:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 2:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 3:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 4:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 5:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 6:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 7:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 8:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 9:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, node1, node2);
			case 10:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, node1, node2);
			case 11:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, node1, node2);
			case 12:
				return nodeOf2x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node, node2);
			case 1:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node, node1, node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node1, node, node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node, node1, node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node1, node, node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node, node1, node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node1, node, node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node, node1, node2);
				case 1:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node1, node, node2);
				case 2:
					return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node2);
				case 1:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node2);
				case 2:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node2);
				case 3:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2);
				case 4:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2);
				case 5:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2);
				case 6:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2);
				case 7:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2);
				case 8:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2);
				case 9:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							node2);
				case 10:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							node2);
				case 11:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							node2);
				case 12:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							node2);
				case 13:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1);
				case 1:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1);
				case 2:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1);
				case 3:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
				case 4:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
				case 5:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
				case 6:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
				case 7:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
				case 8:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1);
				case 9:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							node1);
				case 10:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							node1);
				case 11:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							node1);
				case 12:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							node1);
				case 13:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map13To3Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final CompactMapNode node1;
		private final CompactMapNode node2;
		private final CompactMapNode node3;

		private Map13To3Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final CompactMapNode node1, final CompactMapNode node2, final CompactMapNode node3) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.node1 = node1;
			this.node2 = node2;
			this.node3 = node3;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 29;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node3;
			case 1:
				return node2;
			case 2:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2, node3);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 3;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 13;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 1:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 2:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 3:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 4:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 5:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 6:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 7:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 8:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 9:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 10:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, node1, node2, node3);
			case 11:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, node1, node2, node3);
			case 12:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf3x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2, node3);
			case 1:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2, node3);
			case 2:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2, node3);
			case 3:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
						node3);
			case 4:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
						node3);
			case 5:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
						node3);
			case 6:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
						node3);
			case 7:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
						node3);
			case 8:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
						node3);
			case 9:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, node1,
						node2, node3);
			case 10:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, node1,
						node2, node3);
			case 11:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, node1,
						node2, node3);
			case 12:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, node1,
						node2, node3);
			case 13:
				return nodeOf3x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, node1,
						node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf3x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 1:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 2:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 3:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 4:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 5:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 6:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 7:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 8:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 9:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, node1, node2, node3);
			case 10:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, node1, node2, node3);
			case 11:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, node1, node2, node3);
			case 12:
				return nodeOf3x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, node1, node2, node3);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node, node2, node3);
			case 1:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node, node3);
			case 2:
				return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node, node1,
							node2, node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node,
							node2, node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node, node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, node1, node2,
							node3, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node, node1, node2,
							node3);
				case 1:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node1, node, node2,
							node3);
				case 2:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node1, node2, node,
							node3);
				case 3:
					return nodeOf4x12(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, node1, node2, node3,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node2, node3);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node2, node3);
				case 2:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node2, node3);
				case 3:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2, node3);
				case 4:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2, node3);
				case 5:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2, node3);
				case 6:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2, node3);
				case 7:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2, node3);
				case 8:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node2, node3);
				case 9:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							node2, node3);
				case 10:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							node2, node3);
				case 11:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							node2, node3);
				case 12:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							node2, node3);
				case 13:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							node2, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node3);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node3);
				case 2:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node3);
				case 3:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node3);
				case 4:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node3);
				case 5:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node3);
				case 6:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node3);
				case 7:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node3);
				case 8:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node3);
				case 9:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node3);
				case 10:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							node1, node3);
				case 11:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							node1, node3);
				case 12:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							node1, node3);
				case 13:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							node1, node3);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (valIndex) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node2);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node2);
				case 2:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node2);
				case 3:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
				case 4:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
				case 5:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
				case 6:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
				case 7:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
				case 8:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, node1, node2);
				case 9:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							node1, node2);
				case 10:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							node1, node2);
				case 11:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							node1, node2);
				case 12:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							node1, node2);
				case 13:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							node1, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map14To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;

		private Map14To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 28;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
						val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 14;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 1:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 2:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 3:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 4:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 5:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 6:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 7:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 8:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 9:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, key14, val14);
			case 10:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, key14, val14);
			case 11:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, key14, val14);
			case 12:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, key14, val14);
			case 13:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x15(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14);
			case 1:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14);
			case 2:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14);
			case 3:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 4:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 5:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 6:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 7:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 8:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			case 9:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14);
			case 10:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, key14,
						val14);
			case 11:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, key14,
						val14);
			case 12:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, key14,
						val14);
			case 13:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, key14,
						val14);
			case 14:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key,
						val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 1:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 2:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 3:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 4:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 5:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 6:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 7:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 8:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 9:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, key14, val14);
			case 10:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, key14, val14);
			case 11:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, key14, val14);
			case 12:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key14, val14);
			case 13:
				return nodeOf0x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (idxNew) {
				case 0:
					return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map14To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final CompactMapNode node1;

		private Map14To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 29;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
						val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 14;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 1:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 2:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 3:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 4:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 5:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 6:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 7:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 8:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 9:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 10:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, key14, val14, node1);
			case 11:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, key14, val14, node1);
			case 12:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, key14, val14, node1);
			case 13:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x15(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1);
			case 1:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1);
			case 2:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1);
			case 3:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1);
			case 4:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1);
			case 5:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1);
			case 6:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1);
			case 7:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1);
			case 8:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1);
			case 9:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1);
			case 10:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, key14,
						val14, node1);
			case 11:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, key14,
						val14, node1);
			case 12:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, key14,
						val14, node1);
			case 13:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, key14,
						val14, node1);
			case 14:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key,
						val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 1:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 2:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 3:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 4:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 5:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 6:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 7:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 8:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 9:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, key14, val14, node1);
			case 10:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, key14, val14, node1);
			case 11:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, key14, val14, node1);
			case 12:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key14, val14, node1);
			case 13:
				return nodeOf1x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, node,
							node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, node1,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, node,
							node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, node1,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, node,
							node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, node1,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, node,
							node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, node1,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (idxNew) {
				case 0:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, node,
							node1);
				case 1:
					return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
							node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x15(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14);
				case 1:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14);
				case 2:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14);
				case 3:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
				case 4:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
				case 5:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
				case 6:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
				case 7:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
				case 8:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14);
				case 9:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14);
				case 10:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							key14, val14);
				case 11:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							key14, val14);
				case 12:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							key14, val14);
				case 13:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							key14, val14);
				case 14:
					return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map14To2Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final CompactMapNode node1;
		private final CompactMapNode node2;

		private Map14To2Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final CompactMapNode node1,
				final CompactMapNode node2) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.node1 = node1;
			this.node2 = node2;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 30;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
						val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node2;
			case 1:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1, node2);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 2;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 14;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 1:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 2:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 3:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 4:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 5:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 6:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 7:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 8:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 9:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, key14, val14, node1,
						node2);
			case 10:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, key14, val14, node1,
						node2);
			case 11:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, key14, val14, node1,
						node2);
			case 12:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, key14, val14, node1,
						node2);
			case 13:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val, node1,
						node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf2x15(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1, node2);
			case 1:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1, node2);
			case 2:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1, node2);
			case 3:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 4:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 5:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 6:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 7:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 8:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node2);
			case 9:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, node1, node2);
			case 10:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, key14,
						val14, node1, node2);
			case 11:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, key14,
						val14, node1, node2);
			case 12:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, key14,
						val14, node1, node2);
			case 13:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, key14,
						val14, node1, node2);
			case 14:
				return nodeOf2x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key,
						val, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf2x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 1:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 2:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 3:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 4:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 5:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 6:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 7:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 8:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 9:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, key14, val14, node1, node2);
			case 10:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, key14, val14, node1, node2);
			case 11:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, key14, val14, node1, node2);
			case 12:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key14, val14, node1, node2);
			case 13:
				return nodeOf2x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, node1, node2);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node,
						node2);
			case 1:
				return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						node1, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node, node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							node1, node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, node,
							node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, node1,
							node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, node,
							node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, node1,
							node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, node,
							node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, node1,
							node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, node,
							node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, node1,
							node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (idxNew) {
				case 0:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, node,
							node1, node2);
				case 1:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
							node, node2);
				case 2:
					return nodeOf3x13(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, node1,
							node2, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node2);
				case 1:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node2);
				case 2:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node2);
				case 3:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node2);
				case 4:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node2);
				case 5:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node2);
				case 6:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node2);
				case 7:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node2);
				case 8:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node2);
				case 9:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node2);
				case 10:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							key14, val14, node2);
				case 11:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							key14, val14, node2);
				case 12:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							key14, val14, node2);
				case 13:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							key14, val14, node2);
				case 14:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key, val, node2);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (valIndex) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node1);
				case 1:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node1);
				case 2:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node1);
				case 3:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
				case 4:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
				case 5:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
				case 6:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
				case 7:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
				case 8:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, node1);
				case 9:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, node1);
				case 10:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							key14, val14, node1);
				case 11:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							key14, val14, node1);
				case 12:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							key14, val14, node1);
				case 13:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							key14, val14, node1);
				case 14:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key, val, node1);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map15To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final int key15;
		private final int val15;

		private Map15To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.key15 = key15;
			this.val15 = val15;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 30;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			case 14:
				return val15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
						val14);
			case 14:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key15,
						val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 15;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 1:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 2:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 3:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 4:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 5:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 6:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 7:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 8:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 9:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, key14, val14, key15,
						val15);
			case 10:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, key14, val14, key15,
						val15);
			case 11:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, key14, val14, key15,
						val15);
			case 12:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, key14, val14, key15,
						val15);
			case 13:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val, key15,
						val15);
			case 14:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x16(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15);
			case 1:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15);
			case 2:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15);
			case 3:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 4:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 5:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 6:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 7:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 8:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			case 9:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15);
			case 10:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15);
			case 11:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, key14,
						val14, key15, val15);
			case 12:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, key14,
						val14, key15, val15);
			case 13:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, key14,
						val14, key15, val15);
			case 14:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key,
						val, key15, val15);
			case 15:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x14(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 1:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 2:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 3:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 4:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 5:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 6:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 7:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 8:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 9:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15);
			case 10:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, key14, val14, key15, val15);
			case 11:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, key14, val14, key15, val15);
			case 12:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key14, val14, key15, val15);
			case 13:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key15, val15);
			case 14:
				return nodeOf0x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, key15,
							val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, key15,
							val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, key15,
							val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, key15,
							val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key15,
							val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 14:
				switch (idxNew) {
				case 0:
					return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

	private static final class Map15To1Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactMixedMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final int key15;
		private final int val15;
		private final CompactMapNode node1;

		private Map15To1Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final CompactMapNode node1) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.key15 = key15;
			this.val15 = val15;
			this.node1 = node1;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 31;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			case 14:
				return val15;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
						val14);
			case 14:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key15,
						val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			switch (index) {
			case 0:
				return node1;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return ArrayIterator.of(node1);
		}

		boolean hasNodes() {
			return true;
		}

		int nodeArity() {
			return 1;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 15;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 1:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 2:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 3:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 4:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 5:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 6:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 7:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 8:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 9:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, key14, val14, key15,
						val15, node1);
			case 10:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, key14, val14, key15,
						val15, node1);
			case 11:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, key14, val14, key15,
						val15, node1);
			case 12:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, key14, val14, key15,
						val15, node1);
			case 13:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val, key15,
						val15, node1);
			case 14:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf1x16(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, node1);
			case 1:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, node1);
			case 2:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, node1);
			case 3:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 4:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 5:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 6:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 7:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 8:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node1);
			case 9:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, node1);
			case 10:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, node1);
			case 11:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, key14,
						val14, key15, val15, node1);
			case 12:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, key14,
						val14, key15, val15, node1);
			case 13:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, key14,
						val14, key15, val15, node1);
			case 14:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key,
						val, key15, val15, node1);
			case 15:
				return nodeOf1x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key, val, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf1x14(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 1:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 2:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 3:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 4:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 5:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 6:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 7:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 8:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 9:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 10:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, key14, val14, key15, val15, node1);
			case 11:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, key14, val14, key15, val15, node1);
			case 12:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key14, val14, key15, val15, node1);
			case 13:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key15, val15, node1);
			case 14:
				return nodeOf1x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, node1);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			final int index = nodeIndex(bitpos);

			final int nodeMap = this.nodeMap();
			final int dataMap = this.dataMap();

			switch (index) {
			case 0:
				return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, node);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, key15,
							val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, key15,
							val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, key15,
							val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, key15,
							val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, key15,
							val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, key15,
							val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, key15,
							val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, key15,
							val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key15,
							val15, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key15,
							val15, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 14:
				switch (idxNew) {
				case 0:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, node, node1);
				case 1:
					return nodeOf2x14(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, node1, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int bitIndex = nodeIndex(bitpos);
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() ^ bitpos);
			final int dataMap = (int) (this.dataMap() | bitpos);

			final int key = node.getKey(0);
			final int val = node.getValue(0);

			switch (bitIndex) {
			case 0:
				switch (valIndex) {
				case 0:
					return nodeOf0x16(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, key15, val15);
				case 1:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, key15, val15);
				case 2:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
							key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key9, val9, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, key15, val15);
				case 3:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
				case 4:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
				case 5:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
				case 6:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
				case 7:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8,
							val8, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
				case 8:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key,
							val, key9, val9, key10, val10, key11, val11, key12, val12, key13,
							val13, key14, val14, key15, val15);
				case 9:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key, val, key10, val10, key11, val11, key12, val12, key13, val13,
							key14, val14, key15, val15);
				case 10:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key, val, key11, val11, key12, val12, key13, val13,
							key14, val14, key15, val15);
				case 11:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key, val, key12, val12, key13, val13,
							key14, val14, key15, val15);
				case 12:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key, val, key13, val13,
							key14, val14, key15, val15);
				case 13:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key, val,
							key14, val14, key15, val15);
				case 14:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key, val, key15, val15);
				case 15:
					return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key15, val15, key, val);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

	}

	private static final class Map16To0Node_5Bits_Spec0To16_IntKey_IntValue extends
			CompactValuesOnlyMapNode {

		private final int key1;
		private final int val1;
		private final int key2;
		private final int val2;
		private final int key3;
		private final int val3;
		private final int key4;
		private final int val4;
		private final int key5;
		private final int val5;
		private final int key6;
		private final int val6;
		private final int key7;
		private final int val7;
		private final int key8;
		private final int val8;
		private final int key9;
		private final int val9;
		private final int key10;
		private final int val10;
		private final int key11;
		private final int val11;
		private final int key12;
		private final int val12;
		private final int key13;
		private final int val13;
		private final int key14;
		private final int val14;
		private final int key15;
		private final int val15;
		private final int key16;
		private final int val16;

		private Map16To0Node_5Bits_Spec0To16_IntKey_IntValue(final AtomicReference<Thread> mutator,
				final int nodeMap, final int dataMap, final int key1, final int val1,
				final int key2, final int val2, final int key3, final int val3, final int key4,
				final int val4, final int key5, final int val5, final int key6, final int val6,
				final int key7, final int val7, final int key8, final int val8, final int key9,
				final int val9, final int key10, final int val10, final int key11, final int val11,
				final int key12, final int val12, final int key13, final int val13,
				final int key14, final int val14, final int key15, final int val15,
				final int key16, final int val16) {
			super(mutator, nodeMap, dataMap);
			this.key1 = key1;
			this.val1 = val1;
			this.key2 = key2;
			this.val2 = val2;
			this.key3 = key3;
			this.val3 = val3;
			this.key4 = key4;
			this.val4 = val4;
			this.key5 = key5;
			this.val5 = val5;
			this.key6 = key6;
			this.val6 = val6;
			this.key7 = key7;
			this.val7 = val7;
			this.key8 = key8;
			this.val8 = val8;
			this.key9 = key9;
			this.val9 = val9;
			this.key10 = key10;
			this.val10 = val10;
			this.key11 = key11;
			this.val11 = val11;
			this.key12 = key12;
			this.val12 = val12;
			this.key13 = key13;
			this.val13 = val13;
			this.key14 = key14;
			this.val14 = val14;
			this.key15 = key15;
			this.val15 = val15;
			this.key16 = key16;
			this.val16 = val16;
		}

		boolean hasSlots() {
			return true;
		}

		int slotArity() {
			return 32;
		}

		Object getSlot(final int index) {
			final int boundary = TUPLE_LENGTH * payloadArity();

			if (index < boundary) {
				if (index % 2 == 0) {
					return getKey(index / 2);
				} else {
					return getValue(index / 2);
				}
			} else {
				return getNode(index - boundary);
			}
		}

		int getKey(final int index) {
			switch (index) {
			case 0:
				return key1;
			case 1:
				return key2;
			case 2:
				return key3;
			case 3:
				return key4;
			case 4:
				return key5;
			case 5:
				return key6;
			case 6:
				return key7;
			case 7:
				return key8;
			case 8:
				return key9;
			case 9:
				return key10;
			case 10:
				return key11;
			case 11:
				return key12;
			case 12:
				return key13;
			case 13:
				return key14;
			case 14:
				return key15;
			case 15:
				return key16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		int getValue(final int index) {
			switch (index) {
			case 0:
				return val1;
			case 1:
				return val2;
			case 2:
				return val3;
			case 3:
				return val4;
			case 4:
				return val5;
			case 5:
				return val6;
			case 6:
				return val7;
			case 7:
				return val8;
			case 8:
				return val9;
			case 9:
				return val10;
			case 10:
				return val11;
			case 11:
				return val12;
			case 12:
				return val13;
			case 13:
				return val14;
			case 14:
				return val15;
			case 15:
				return val16;
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		Map.Entry<java.lang.Integer, java.lang.Integer> getKeyValueEntry(final int index) {
			switch (index) {
			case 0:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key1,
						val1);
			case 1:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key2,
						val2);
			case 2:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key3,
						val3);
			case 3:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key4,
						val4);
			case 4:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key5,
						val5);
			case 5:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key6,
						val6);
			case 6:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key7,
						val7);
			case 7:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key8,
						val8);
			case 8:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key9,
						val9);
			case 9:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key10,
						val10);
			case 10:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key11,
						val11);
			case 11:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key12,
						val12);
			case 12:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key13,
						val13);
			case 13:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key14,
						val14);
			case 14:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key15,
						val15);
			case 15:
				return (java.util.Map.Entry<java.lang.Integer, java.lang.Integer>) entryOf(key16,
						val16);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode getNode(final int index) {
			throw new IllegalStateException("Index out of range.");
		}

		Iterator<? extends AbstractMapNode> nodeIterator() {
			return Collections.<CompactMapNode> emptyIterator();
		}

		boolean hasNodes() {
			return false;
		}

		int nodeArity() {
			return 0;
		}

		boolean hasPayload() {
			return true;
		}

		int payloadArity() {
			return 16;
		}

		byte sizePredicate() {
			return SIZE_MORE_THAN_ONE;
		}

		CompactMapNode copyAndSetValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int val) {
			final int idx = dataIndex(bitpos);

			final int nodeMap = nodeMap();
			final int dataMap = dataMap();

			switch (idx) {
			case 0:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 1:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 2:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 3:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 4:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 5:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 6:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 7:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 8:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 9:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val, key11, val11, key12, val12, key13, val13, key14, val14, key15,
						val15, key16, val16);
			case 10:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val, key12, val12, key13, val13, key14, val14, key15,
						val15, key16, val16);
			case 11:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val, key13, val13, key14, val14, key15,
						val15, key16, val16);
			case 12:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val, key14, val14, key15,
						val15, key16, val16);
			case 13:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val, key15,
						val15, key16, val16);
			case 14:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val, key16, val16);
			case 15:
				return nodeOf0x16(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndInsertValue(final AtomicReference<Thread> mutator, final int bitpos,
				final int key, final int val) {
			final int idx = dataIndex(bitpos);

			// TODO: improve naming of bitmaps in heterogeneous
			final int nodeMap = nodeMap();
			final int dataMap = dataMap() | bitpos;

			switch (idx) {
			case 0:
				return nodeOf0x17(mutator, nodeMap, dataMap, key, val, key1, val1, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 1:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key, val, key2, val2,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 2:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key, val,
						key3, val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
						key9, val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 3:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key, val, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 4:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key, val, key5, val5, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 5:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key, val, key6, val6, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 6:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key, val, key7, val7, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 7:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key, val, key8, val8, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 8:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key, val, key9,
						val9, key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16);
			case 9:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key, val, key10, val10, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 10:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key, val, key11, val11, key12, val12, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 11:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key, val, key12, val12, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 12:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key, val, key13, val13, key14,
						val14, key15, val15, key16, val16);
			case 13:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key, val, key14,
						val14, key15, val15, key16, val16);
			case 14:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14, key,
						val, key15, val15, key16, val16);
			case 15:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key, val, key16, val16);
			case 16:
				return nodeOf0x17(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15, key16, val16, key, val);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndRemoveValue(final AtomicReference<Thread> mutator, final int bitpos) {
			final int valIndex = dataIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap());
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (valIndex) {
			case 0:
				return nodeOf0x15(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 1:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 2:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4, val4,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 3:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key5, val5, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 4:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key6, val6, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 5:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key7, val7, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 6:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key8, val8, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 7:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key9, val9, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 8:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key10, val10,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 9:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key11, val11, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 10:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key12, val12, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 11:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key13, val13, key14, val14, key15, val15,
						key16, val16);
			case 12:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key14, val14, key15, val15,
						key16, val16);
			case 13:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key15, val15,
						key16, val16);
			case 14:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key16, val16);
			case 15:
				return nodeOf0x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3, val3,
						key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
						key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
						key15, val15);
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndSetNode(final AtomicReference<Thread> mutator, final int bitpos,
				final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

		CompactMapNode copyAndMigrateFromInlineToNode(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			final int idxOld = dataIndex(bitpos);
			final int idxNew = nodeIndex(bitpos);

			final int nodeMap = (int) (this.nodeMap() | bitpos);
			final int dataMap = (int) (this.dataMap() ^ bitpos);

			switch (idxOld) {
			case 0:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key2, val2, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 1:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key3, val3, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 2:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key4,
							val4, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 3:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key5, val5, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 4:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key6, val6, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 5:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key7, val7, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 6:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key8, val8, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 7:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key9, val9,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 8:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8,
							key10, val10, key11, val11, key12, val12, key13, val13, key14, val14,
							key15, val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 9:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key11, val11, key12, val12, key13, val13, key14, val14, key15,
							val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 10:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key12, val12, key13, val13, key14, val14, key15,
							val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 11:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key13, val13, key14, val14, key15,
							val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 12:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key14, val14, key15,
							val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 13:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key15,
							val15, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 14:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key16, val16, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			case 15:
				switch (idxNew) {
				case 0:
					return nodeOf1x15(mutator, nodeMap, dataMap, key1, val1, key2, val2, key3,
							val3, key4, val4, key5, val5, key6, val6, key7, val7, key8, val8, key9,
							val9, key10, val10, key11, val11, key12, val12, key13, val13, key14,
							val14, key15, val15, node);
				default:
					throw new IllegalStateException("Index out of range.");
				}
			default:
				throw new IllegalStateException("Index out of range.");
			}
		}

		CompactMapNode copyAndMigrateFromNodeToInline(final AtomicReference<Thread> mutator,
				final int bitpos, final CompactMapNode node) {
			throw new IllegalStateException("Index out of range.");
		}

	}

}